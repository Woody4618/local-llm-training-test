Directory structure:
└── coral-xyz-anchor/
    ├── README.md
    ├── CHANGELOG.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── Cargo.toml
    ├── LICENSE
    ├── Makefile
    ├── VERSION
    ├── setup-tests.sh
    ├── version-bump.sh
    ├── avm/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── lib.rs
    │       ├── main.rs
    │       └── anchor/
    │           └── main.rs
    ├── bench/
    │   ├── BINARY_SIZE.md
    │   ├── COMPUTE_UNITS.md
    │   └── STACK_MEMORY.md
    ├── cli/
    │   ├── Cargo.toml
    │   ├── npm-package/
    │   │   ├── anchor.js
    │   │   └── package.json
    │   └── src/
    │       ├── checks.rs
    │       ├── config.rs
    │       ├── lib.rs
    │       ├── rust_template.rs
    │       ├── solidity_template.rs
    │       └── bin/
    │           └── main.rs
    ├── client/
    │   ├── Cargo.toml
    │   ├── example/
    │   │   ├── Cargo.toml
    │   │   ├── run-test.sh
    │   │   └── src/
    │   │       ├── blocking.rs
    │   │       ├── main.rs
    │   │       └── nonblocking.rs
    │   └── src/
    │       ├── blocking.rs
    │       ├── cluster.rs
    │       ├── lib.rs
    │       └── nonblocking.rs
    ├── docker/
    │   ├── Makefile
    │   └── build/
    │       └── Dockerfile
    ├── docs/
    │   ├── README.md
    │   ├── jsconfig.json
    │   ├── next.config.js
    │   ├── package-lock.json
    │   ├── package.json
    │   ├── postcss.config.js
    │   ├── prettier.config.js
    │   ├── tailwind.config.js
    │   ├── vercel.sh
    │   ├── .env.example
    │   ├── .eslintrc.json
    │   ├── .gitignore
    │   ├── markdoc/
    │   │   ├── nodes.js
    │   │   └── tags.js
    │   ├── programs/
    │   │   └── tic-tac-toe/
    │   │       ├── Anchor.toml
    │   │       ├── Cargo.lock
    │   │       ├── Cargo.toml
    │   │       ├── package.json
    │   │       ├── tsconfig.json
    │   │       ├── yarn.lock
    │   │       ├── .gitignore
    │   │       ├── .mocharc.json
    │   │       ├── migrations/
    │   │       │   └── deploy.ts
    │   │       ├── programs/
    │   │       │   └── tic-tac-toe/
    │   │       │       ├── Cargo.toml
    │   │       │       ├── Xargo.toml
    │   │       │       └── src/
    │   │       │           ├── errors.rs
    │   │       │           ├── lib.rs
    │   │       │           ├── instructions/
    │   │       │           │   ├── mod.rs
    │   │       │           │   ├── play.rs
    │   │       │           │   └── setup_game.rs
    │   │       │           └── state/
    │   │       │               ├── game.rs
    │   │       │               └── mod.rs
    │   │       └── tests/
    │   │           └── tic-tac-toe.ts
    │   ├── public/
    │   │   └── fonts/
    │   │       ├── Inter-italic.var.woff2
    │   │       ├── Inter-roman.var.woff2
    │   │       ├── lexend.txt
    │   │       └── lexend.woff2
    │   └── src/
    │       ├── components/
    │       │   ├── Button.jsx
    │       │   ├── Callout.jsx
    │       │   ├── Fence.jsx
    │       │   ├── Hero.jsx
    │       │   ├── HeroBackground.jsx
    │       │   ├── Icon.jsx
    │       │   ├── Layout.jsx
    │       │   ├── LinkGrid.jsx
    │       │   ├── Logo.jsx
    │       │   ├── MobileNavigation.jsx
    │       │   ├── Navigation.jsx
    │       │   ├── Prose.jsx
    │       │   ├── Search.jsx
    │       │   ├── ThemeSelector.jsx
    │       │   └── icons/
    │       │       ├── InstallationIcon.jsx
    │       │       ├── LightbulbIcon.jsx
    │       │       ├── PluginsIcon.jsx
    │       │       ├── PresetsIcon.jsx
    │       │       ├── ThemingIcon.jsx
    │       │       └── WarningIcon.jsx
    │       ├── images/
    │       ├── pages/
    │       │   ├── _app.jsx
    │       │   ├── _document.jsx
    │       │   ├── index.md
    │       │   ├── docs/
    │       │   │   ├── account-constraints.md
    │       │   │   ├── account-types.md
    │       │   │   ├── avm.md
    │       │   │   ├── cli.md
    │       │   │   ├── contribution-guide.md
    │       │   │   ├── cross-program-invocations.md
    │       │   │   ├── errors.md
    │       │   │   ├── hello-world.md
    │       │   │   ├── high-level-overview.md
    │       │   │   ├── important-links.md
    │       │   │   ├── installation.md
    │       │   │   ├── intro-to-solana.md
    │       │   │   ├── javascript-anchor-types.md
    │       │   │   ├── manifest.md
    │       │   │   ├── pdas.md
    │       │   │   ├── publishing-source.md
    │       │   │   ├── security-exploits.md
    │       │   │   ├── solana-playground.md
    │       │   │   ├── space.md
    │       │   │   ├── the-accounts-struct.md
    │       │   │   ├── the-program-module.md
    │       │   │   ├── tic-tac-toe.md
    │       │   │   └── verifiable-builds.md
    │       │   └── release-notes/
    │       │       ├── 0.29.0.md
    │       │       ├── 0.30.0.md
    │       │       ├── 0.30.1.md
    │       │       └── changelog.md
    │       └── styles/
    │           ├── docsearch.css
    │           ├── fonts.css
    │           ├── prism.css
    │           └── tailwind.css
    ├── examples/
    │   ├── yarn.lock
    │   └── tutorial/
    │       ├── package.json
    │       ├── yarn.lock
    │       ├── basic-0/
    │       │   ├── Anchor.toml
    │       │   ├── Cargo.toml
    │       │   ├── client.js
    │       │   ├── package.json
    │       │   ├── programs/
    │       │   │   └── basic-0/
    │       │   │       ├── Cargo.toml
    │       │   │       ├── Xargo.toml
    │       │   │       └── src/
    │       │   │           └── lib.rs
    │       │   └── tests/
    │       │       └── basic-0.js
    │       ├── basic-1/
    │       │   ├── Anchor.toml
    │       │   ├── Cargo.toml
    │       │   ├── package.json
    │       │   ├── programs/
    │       │   │   └── basic-1/
    │       │   │       ├── Cargo.toml
    │       │   │       ├── Xargo.toml
    │       │   │       └── src/
    │       │   │           └── lib.rs
    │       │   └── tests/
    │       │       └── basic-1.js
    │       ├── basic-2/
    │       │   ├── Anchor.toml
    │       │   ├── Cargo.toml
    │       │   ├── package.json
    │       │   ├── programs/
    │       │   │   └── basic-2/
    │       │   │       ├── Cargo.toml
    │       │   │       ├── Xargo.toml
    │       │   │       └── src/
    │       │   │           └── lib.rs
    │       │   └── tests/
    │       │       └── basic-2.js
    │       ├── basic-3/
    │       │   ├── Anchor.toml
    │       │   ├── Cargo.toml
    │       │   ├── package.json
    │       │   ├── programs/
    │       │   │   ├── puppet/
    │       │   │   │   ├── Cargo.toml
    │       │   │   │   ├── Xargo.toml
    │       │   │   │   └── src/
    │       │   │   │       └── lib.rs
    │       │   │   └── puppet-master/
    │       │   │       ├── Cargo.toml
    │       │   │       ├── Xargo.toml
    │       │   │       └── src/
    │       │   │           └── lib.rs
    │       │   └── tests/
    │       │       └── basic-3.js
    │       ├── basic-4/
    │       │   ├── Anchor.toml
    │       │   ├── Cargo.toml
    │       │   ├── package.json
    │       │   ├── programs/
    │       │   │   └── basic-4/
    │       │   │       ├── Cargo.toml
    │       │   │       ├── Xargo.toml
    │       │   │       └── src/
    │       │   │           └── lib.rs
    │       │   └── tests/
    │       │       └── basic-4.js
    │       └── basic-5/
    │           ├── README.md
    │           ├── Anchor.toml
    │           ├── Cargo.toml
    │           ├── package.json
    │           ├── tsconfig.json
    │           ├── programs/
    │           │   └── basic-5/
    │           │       ├── Cargo.toml
    │           │       ├── Xargo.toml
    │           │       └── src/
    │           │           └── lib.rs
    │           └── tests/
    │               └── basic-5.ts
    ├── idl/
    │   ├── Cargo.toml
    │   ├── spec/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   └── src/
    │       ├── build.rs
    │       ├── convert.rs
    │       └── lib.rs
    ├── lang/
    │   ├── Cargo.toml
    │   ├── attribute/
    │   │   ├── access-control/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   ├── account/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       ├── id.rs
    │   │   │       ├── lazy.rs
    │   │   │       └── lib.rs
    │   │   ├── constant/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   ├── error/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   ├── event/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   └── program/
    │   │       ├── Cargo.toml
    │   │       └── src/
    │   │           ├── lib.rs
    │   │           └── declare_program/
    │   │               ├── common.rs
    │   │               ├── mod.rs
    │   │               └── mods/
    │   │                   ├── accounts.rs
    │   │                   ├── client.rs
    │   │                   ├── constants.rs
    │   │                   ├── cpi.rs
    │   │                   ├── events.rs
    │   │                   ├── internal.rs
    │   │                   ├── mod.rs
    │   │                   ├── program.rs
    │   │                   ├── types.rs
    │   │                   └── utils.rs
    │   ├── derive/
    │   │   ├── accounts/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       └── lib.rs
    │   │   ├── serde/
    │   │   │   ├── Cargo.toml
    │   │   │   └── src/
    │   │   │       ├── lazy.rs
    │   │   │       └── lib.rs
    │   │   └── space/
    │   │       ├── Cargo.toml
    │   │       └── src/
    │   │           └── lib.rs
    │   ├── src/
    │   │   ├── account_meta.rs
    │   │   ├── bpf_upgradeable_state.rs
    │   │   ├── bpf_writer.rs
    │   │   ├── common.rs
    │   │   ├── context.rs
    │   │   ├── error.rs
    │   │   ├── event.rs
    │   │   ├── idl.rs
    │   │   ├── lazy.rs
    │   │   ├── lib.rs
    │   │   ├── system_program.rs
    │   │   ├── vec.rs
    │   │   └── accounts/
    │   │       ├── account.rs
    │   │       ├── account_info.rs
    │   │       ├── account_loader.rs
    │   │       ├── boxed.rs
    │   │       ├── interface.rs
    │   │       ├── interface_account.rs
    │   │       ├── lazy_account.rs
    │   │       ├── mod.rs
    │   │       ├── option.rs
    │   │       ├── program.rs
    │   │       ├── signer.rs
    │   │       ├── system_account.rs
    │   │       ├── sysvar.rs
    │   │       └── unchecked_account.rs
    │   ├── syn/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── hash.rs
    │   │       ├── lib.rs
    │   │       ├── codegen/
    │   │       │   ├── error.rs
    │   │       │   ├── mod.rs
    │   │       │   ├── accounts/
    │   │       │   │   ├── __client_accounts.rs
    │   │       │   │   ├── __cpi_client_accounts.rs
    │   │       │   │   ├── bumps.rs
    │   │       │   │   ├── constraints.rs
    │   │       │   │   ├── exit.rs
    │   │       │   │   ├── mod.rs
    │   │       │   │   ├── to_account_infos.rs
    │   │       │   │   ├── to_account_metas.rs
    │   │       │   │   └── try_accounts.rs
    │   │       │   └── program/
    │   │       │       ├── accounts.rs
    │   │       │       ├── common.rs
    │   │       │       ├── cpi.rs
    │   │       │       ├── dispatch.rs
    │   │       │       ├── entry.rs
    │   │       │       ├── handlers.rs
    │   │       │       ├── idl.rs
    │   │       │       ├── instruction.rs
    │   │       │       └── mod.rs
    │   │       ├── idl/
    │   │       │   ├── accounts.rs
    │   │       │   ├── address.rs
    │   │       │   ├── common.rs
    │   │       │   ├── constant.rs
    │   │       │   ├── defined.rs
    │   │       │   ├── error.rs
    │   │       │   ├── event.rs
    │   │       │   ├── external.rs
    │   │       │   ├── mod.rs
    │   │       │   └── program.rs
    │   │       └── parser/
    │   │           ├── context.rs
    │   │           ├── docs.rs
    │   │           ├── error.rs
    │   │           ├── mod.rs
    │   │           ├── spl_interface.rs
    │   │           ├── accounts/
    │   │           │   ├── constraints.rs
    │   │           │   ├── event_cpi.rs
    │   │           │   └── mod.rs
    │   │           └── program/
    │   │               ├── instructions.rs
    │   │               └── mod.rs
    │   └── tests/
    │       ├── generics_test.rs
    │       ├── macros.rs
    │       ├── serialization.rs
    │       └── space.rs
    ├── spl/
    │   ├── Cargo.toml
    │   └── src/
    │       ├── associated_token.rs
    │       ├── governance.rs
    │       ├── idl_build.rs
    │       ├── lib.rs
    │       ├── memo.rs
    │       ├── metadata.rs
    │       ├── mint.rs
    │       ├── stake.rs
    │       ├── token.rs
    │       ├── token_2022.rs
    │       ├── token_interface.rs
    │       └── token_2022_extensions/
    │           ├── confidential_transfer.rs
    │           ├── confidential_transfer_fee.rs
    │           ├── cpi_guard.rs
    │           ├── default_account_state.rs
    │           ├── group_member_pointer.rs
    │           ├── group_pointer.rs
    │           ├── immutable_owner.rs
    │           ├── interest_bearing_mint.rs
    │           ├── memo_transfer.rs
    │           ├── metadata_pointer.rs
    │           ├── mint_close_authority.rs
    │           ├── mod.rs
    │           ├── non_transferable.rs
    │           ├── permanent_delegate.rs
    │           ├── token_group.rs
    │           ├── token_metadata.rs
    │           ├── transfer_fee.rs
    │           └── transfer_hook.rs
    ├── tests/
    │   ├── README.md
    │   ├── package.json
    │   ├── yarn.lock
    │   ├── .prettierignore
    │   ├── anchor-cli-account/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── account-command/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── account.ts
    │   ├── anchor-cli-idl/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── test.sh
    │   │   ├── tsconfig.json
    │   │   ├── keypairs/
    │   │   │   ├── deployer-keypair.json
    │   │   │   ├── idl_commands_one-keypair.json
    │   │   │   └── idl_commands_two-keypair.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   ├── idl-commands-one/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── idl-commands-two/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── idl.ts
    │   ├── auction-house/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── prebuilt-programs/
    │   │   ├── programs/
    │   │   │   └── auction-house/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           ├── lib.rs
    │   │   │           └── utils.rs
    │   │   └── tests/
    │   │       └── auction-house.ts
    │   ├── bench/
    │   │   ├── README.md
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── bench.json
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── locks/
    │   │   │   ├── 0.27.0.lock
    │   │   │   ├── 0.28.0.lock
    │   │   │   ├── 0.29.0.lock
    │   │   │   ├── 0.30.0.lock
    │   │   │   └── 0.30.1.lock
    │   │   ├── programs/
    │   │   │   └── bench/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   ├── scripts/
    │   │   │   ├── bump-version.ts
    │   │   │   ├── generate-ix.ts
    │   │   │   ├── sync-markdown.ts
    │   │   │   ├── sync.ts
    │   │   │   └── utils.ts
    │   │   └── tests/
    │   │       ├── binary-size.ts
    │   │       ├── compute-units.ts
    │   │       └── stack-memory.ts
    │   ├── bpf-upgradeable-state/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── bpf_upgradeable_state-keypair.json
    │   │   ├── package.json
    │   │   ├── program_with_different_programdata.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── bpf-upgradeable-state/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── bpf-upgradable-state.ts
    │   ├── cashiers-check/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── cashiers-check/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── cashiers-check.js
    │   ├── cfo/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── deps/
    │   │   │   ├── openbook-dex/
    │   │   │   ├── stake/
    │   │   │   └── swap/
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── cfo/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   ├── scripts/
    │   │   │   ├── common.sh
    │   │   │   ├── fees.js
    │   │   │   ├── list-market.js
    │   │   │   ├── localnet.sh
    │   │   │   ├── market-maker.json
    │   │   │   └── trade-bot.js
    │   │   └── tests/
    │   │       ├── cfo.js
    │   │       └── utils/
    │   │           ├── index.js
    │   │           └── stake.js
    │   ├── chat/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── chat/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── chat.js
    │   ├── composite/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── programs/
    │   │   │   └── composite/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── composite.js
    │   ├── cpi-returns/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   ├── callee/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── caller/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── cpi-return.ts
    │   ├── custom-coder/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   ├── native-system/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── spl-associated-token/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── spl-token/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── spl-associated-token-coder.ts
    │   │       ├── spl-token-coder.ts
    │   │       └── system-coder.ts
    │   ├── custom-discriminator/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   ├── ambiguous-discriminator/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── custom-discriminator/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── ambiguous-discriminator.ts
    │   │       └── custom-discriminator.ts
    │   ├── declare-id/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── declare-id/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── declare-id.ts
    │   ├── declare-program/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── idls/
    │   │   │   ├── amm_v3.json
    │   │   │   ├── external.json
    │   │   │   └── external_legacy.json
    │   │   ├── programs/
    │   │   │   ├── declare-program/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── external/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── declare-program.ts
    │   ├── errors/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── errors/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── errors.ts
    │   ├── escrow/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── escrow/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── escrow.ts
    │   ├── events/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── events/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── events.ts
    │   ├── floats/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── floats/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── floats.ts
    │   ├── idl/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── generate.sh
    │   │   ├── package.json
    │   │   ├── test.sh
    │   │   ├── tsconfig.json
    │   │   ├── idls/
    │   │   │   ├── generics.json
    │   │   │   ├── new.json
    │   │   │   ├── old.json
    │   │   │   └── relations.json
    │   │   ├── programs/
    │   │   │   ├── docs/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── external/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── generics/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── idl/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── new-idl/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── relations-derivation/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── docs.ts
    │   │       ├── idl.ts
    │   │       ├── new-idl.ts
    │   │       └── workspace.ts
    │   ├── ido-pool/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── ido-pool/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── ido-pool.js
    │   │       └── utils/
    │   │           └── index.js
    │   ├── lazy-account/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── lazy-account/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── lazy-account.ts
    │   ├── lockup/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── docs/
    │   │   │   ├── lockups.md
    │   │   │   └── staking.md
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   ├── lockup/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       ├── calculator.rs
    │   │   │   │       └── lib.rs
    │   │   │   └── registry/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── lockup.js
    │   │       └── utils.js
    │   ├── misc/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── ci.sh
    │   │   ├── miscNonRentExempt.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   ├── init-if-needed/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── lamports/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── misc/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       ├── account.rs
    │   │   │   │       ├── context.rs
    │   │   │   │       ├── event.rs
    │   │   │   │       └── lib.rs
    │   │   │   ├── misc-optional/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       ├── account.rs
    │   │   │   │       ├── context.rs
    │   │   │   │       ├── event.rs
    │   │   │   │       └── lib.rs
    │   │   │   ├── overflow-checks/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   ├── remaining-accounts/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       ├── account.rs
    │   │   │   │       ├── context.rs
    │   │   │   │       └── lib.rs
    │   │   │   └── shared/
    │   │   │       ├── Cargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── init-if-needed/
    │   │       │   ├── Test.toml
    │   │       │   └── init-if-needed.ts
    │   │       ├── lamports/
    │   │       │   ├── Test.toml
    │   │       │   └── lamports.ts
    │   │       ├── misc/
    │   │       │   ├── Test.toml
    │   │       │   └── misc.ts
    │   │       ├── overflow-checks/
    │   │       │   ├── Test.toml
    │   │       │   └── overflow-checks.ts
    │   │       └── remaining-accounts/
    │   │           ├── Test.toml
    │   │           └── remaining-accounts.ts
    │   ├── multiple-suites/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── multiple-suites/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── Test.base.toml
    │   │       ├── Test.root.base.toml
    │   │       ├── accounts/
    │   │       │   ├── ANOTHER_ACC.json
    │   │       │   ├── SOME_ACCOUNT.json
    │   │       │   └── SOME_TOKEN.json
    │   │       ├── another-suite/
    │   │       │   ├── Test.toml
    │   │       │   └── another-suite.ts
    │   │       ├── fourth-and-fifth-suite/
    │   │       │   ├── fifth-suite/
    │   │       │   │   ├── Test.toml
    │   │       │   │   └── fifthSuite.ts
    │   │       │   └── forth-suite/
    │   │       │       ├── Test.toml
    │   │       │       └── forth-suite.ts
    │   │       ├── multiple-suites/
    │   │       │   ├── Test.toml
    │   │       │   └── multiple-suites.ts
    │   │       └── third-suite/
    │   │           ├── Test.toml
    │   │           ├── sub-dir-one/
    │   │           │   └── subDirOne.ts
    │   │           └── sub-dir-two/
    │   │               └── subDirTwo.ts
    │   ├── multiple-suites-run-single/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── multiple-suites-run-single/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── should-not-run/
    │   │       │   ├── Test.toml
    │   │       │   └── shouldNotRun.ts
    │   │       └── should-run/
    │   │           ├── Test.toml
    │   │           └── shouldRun.ts
    │   ├── multisig/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── multisig/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── multisig.js
    │   ├── optional/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   ├── allow-missing-optionals/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   ├── Xargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── optional/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           ├── account.rs
    │   │   │           ├── context.rs
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── optional.ts
    │   ├── pda-derivation/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── pda-derivation/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           ├── lib.rs
    │   │   │           └── other.rs
    │   │   └── tests/
    │   │       └── typescript.spec.ts
    │   ├── pyth/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── Xargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── pyth/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           ├── lib.rs
    │   │   │           └── pc.rs
    │   │   └── tests/
    │   │       ├── oracleUtils.ts
    │   │       └── pyth.spec.ts
    │   ├── realloc/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── programs/
    │   │   │   └── realloc/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── realloc.ts
    │   ├── relations-derivation/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   └── relations-derivation/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── typescript.spec.ts
    │   ├── safety-checks/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── test.sh
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── programs/
    │   │       ├── account-info/
    │   │       │   ├── Cargo.toml
    │   │       │   ├── Xargo.toml
    │   │       │   └── src/
    │   │       │       └── lib.rs
    │   │       ├── ignore-non-accounts/
    │   │       │   ├── Cargo.toml
    │   │       │   ├── Xargo.toml
    │   │       │   └── src/
    │   │       │       └── lib.rs
    │   │       └── unchecked-account/
    │   │           ├── Cargo.toml
    │   │           ├── Xargo.toml
    │   │           └── src/
    │   │               └── lib.rs
    │   ├── solang/
    │   │   ├── Anchor.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierignore
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── solidity/
    │   │   │   └── flipper.sol
    │   │   └── tests/
    │   │       └── solang.ts
    │   ├── spl/
    │   │   ├── metadata/
    │   │   │   ├── Anchor.toml
    │   │   │   ├── Cargo.toml
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── programs/
    │   │   │   │   └── metadata/
    │   │   │   │       ├── Cargo.toml
    │   │   │   │       ├── Xargo.toml
    │   │   │   │       └── src/
    │   │   │   │           └── lib.rs
    │   │   │   └── tests/
    │   │   │       └── metadata.ts
    │   │   ├── token-extensions/
    │   │   │   ├── Anchor.toml
    │   │   │   ├── Cargo.toml
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── programs/
    │   │   │   │   └── token-extensions/
    │   │   │   │       ├── Cargo.toml
    │   │   │   │       ├── Xargo.toml
    │   │   │   │       └── src/
    │   │   │   │           ├── instructions.rs
    │   │   │   │           ├── lib.rs
    │   │   │   │           └── utils.rs
    │   │   │   └── tests/
    │   │   │       └── token-extensions.ts
    │   │   ├── token-proxy/
    │   │   │   ├── Anchor.toml
    │   │   │   ├── Cargo.toml
    │   │   │   ├── package.json
    │   │   │   ├── programs/
    │   │   │   │   └── token-proxy/
    │   │   │   │       ├── Cargo.toml
    │   │   │   │       ├── Xargo.toml
    │   │   │   │       └── src/
    │   │   │   │           └── lib.rs
    │   │   │   └── tests/
    │   │   │       └── token-proxy.js
    │   │   ├── token-wrapper/
    │   │   │   ├── Anchor.toml
    │   │   │   ├── Cargo.toml
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── programs/
    │   │   │   │   └── token-wrapper/
    │   │   │   │       ├── Cargo.toml
    │   │   │   │       ├── Xargo.toml
    │   │   │   │       └── src/
    │   │   │   │           └── lib.rs
    │   │   │   └── tests/
    │   │   │       └── wrapper.ts
    │   │   └── transfer-hook/
    │   │       ├── Anchor.toml
    │   │       ├── Cargo.toml
    │   │       ├── package.json
    │   │       ├── tsconfig.json
    │   │       ├── programs/
    │   │       │   └── transfer-hook/
    │   │       │       ├── Cargo.toml
    │   │       │       ├── Xargo.toml
    │   │       │       └── src/
    │   │       │           └── lib.rs
    │   │       └── tests/
    │   │           └── transfer-hook.ts
    │   ├── swap/
    │   │   ├── README.md
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── prebuilt-programs/
    │   │   ├── programs/
    │   │   │   └── swap/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       ├── swap.js
    │   │       └── utils/
    │   │           └── index.js
    │   ├── system-accounts/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── programs/
    │   │   │   └── system-accounts/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── system-accounts.js
    │   ├── sysvars/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── programs/
    │   │   │   └── sysvars/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── sysvars.js
    │   ├── tictactoe/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── migrations/
    │   │   │   └── deploy.js
    │   │   ├── programs/
    │   │   │   └── tictactoe/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── tictactoe.js
    │   ├── typescript/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── migrations/
    │   │   │   └── deploy.ts
    │   │   ├── programs/
    │   │   │   ├── shared/
    │   │   │   │   ├── Cargo.toml
    │   │   │   │   └── src/
    │   │   │   │       └── lib.rs
    │   │   │   └── typescript/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── typescript.spec.ts
    │   ├── validator-clone/
    │   │   ├── Anchor.toml
    │   │   ├── Cargo.toml
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── accounts-snapshot/
    │   │   │   └── usdc-mint.json
    │   │   ├── programs/
    │   │   │   └── validator-clone/
    │   │   │       ├── Cargo.toml
    │   │   │       ├── Xargo.toml
    │   │   │       └── src/
    │   │   │           └── lib.rs
    │   │   └── tests/
    │   │       └── validator-clone.ts
    │   └── zero-copy/
    │       ├── Anchor.toml
    │       ├── Cargo.toml
    │       ├── package.json
    │       ├── migrations/
    │       │   └── deploy.js
    │       ├── programs/
    │       │   ├── shared/
    │       │   │   ├── Cargo.toml
    │       │   │   └── src/
    │       │   │       └── lib.rs
    │       │   ├── zero-copy/
    │       │   │   ├── Cargo.toml
    │       │   │   ├── Xargo.toml
    │       │   │   ├── src/
    │       │   │   │   └── lib.rs
    │       │   │   └── tests/
    │       │   │       └── compute_unit_test.rs
    │       │   └── zero-cpi/
    │       │       ├── Cargo.toml
    │       │       ├── Xargo.toml
    │       │       └── src/
    │       │           └── lib.rs
    │       └── tests/
    │           └── zero-copy.js
    ├── ts/
    │   ├── build-packages.sh
    │   ├── package.json
    │   ├── yarn.lock
    │   ├── packages/
    │   │   ├── anchor/
    │   │   │   ├── README.md
    │   │   │   ├── jest.config.js
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── src/
    │   │   │   │   ├── error.ts
    │   │   │   │   ├── idl.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── nodewallet.ts
    │   │   │   │   ├── provider.ts
    │   │   │   │   ├── workspace.ts
    │   │   │   │   ├── coder/
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── borsh/
    │   │   │   │   │   │   ├── accounts.ts
    │   │   │   │   │   │   ├── event.ts
    │   │   │   │   │   │   ├── idl.ts
    │   │   │   │   │   │   ├── index.ts
    │   │   │   │   │   │   ├── instruction.ts
    │   │   │   │   │   │   └── types.ts
    │   │   │   │   │   └── system/
    │   │   │   │   │       ├── accounts.ts
    │   │   │   │   │       ├── events.ts
    │   │   │   │   │       ├── index.ts
    │   │   │   │   │       ├── instruction.ts
    │   │   │   │   │       └── types.ts
    │   │   │   │   ├── native/
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   └── system.ts
    │   │   │   │   ├── program/
    │   │   │   │   │   ├── accounts-resolver.ts
    │   │   │   │   │   ├── common.ts
    │   │   │   │   │   ├── context.ts
    │   │   │   │   │   ├── event.ts
    │   │   │   │   │   ├── index.ts
    │   │   │   │   │   ├── token-account-layout.ts
    │   │   │   │   │   └── namespace/
    │   │   │   │   │       ├── account.ts
    │   │   │   │   │       ├── index.ts
    │   │   │   │   │       ├── instruction.ts
    │   │   │   │   │       ├── methods.ts
    │   │   │   │   │       ├── rpc.ts
    │   │   │   │   │       ├── simulate.ts
    │   │   │   │   │       ├── transaction.ts
    │   │   │   │   │       ├── types.ts
    │   │   │   │   │       └── views.ts
    │   │   │   │   └── utils/
    │   │   │   │       ├── common.ts
    │   │   │   │       ├── features.ts
    │   │   │   │       ├── index.ts
    │   │   │   │       ├── pubkey.ts
    │   │   │   │       ├── registry.ts
    │   │   │   │       ├── rpc.ts
    │   │   │   │       ├── sha256.ts
    │   │   │   │       ├── token.ts
    │   │   │   │       └── bytes/
    │   │   │   │           ├── base64.ts
    │   │   │   │           ├── bs58.ts
    │   │   │   │           ├── hex.ts
    │   │   │   │           ├── index.ts
    │   │   │   │           └── utf8.ts
    │   │   │   ├── tests/
    │   │   │   │   ├── coder-accounts.spec.ts
    │   │   │   │   ├── coder-instructions.spec.ts
    │   │   │   │   ├── coder-types.spec.ts
    │   │   │   │   ├── error.spec.ts
    │   │   │   │   ├── events.spec.ts
    │   │   │   │   ├── program-common.spec.ts
    │   │   │   │   └── transaction.spec.ts
    │   │   │   └── types/
    │   │   │       └── buffer-layout/
    │   │   │           └── index.d.ts
    │   │   ├── anchor-errors/
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   └── src/
    │   │   │       └── index.ts
    │   │   ├── borsh/
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── src/
    │   │   │   │   └── index.ts
    │   │   │   └── types/
    │   │   │       └── buffer-layout/
    │   │   │           └── index.d.ts
    │   │   ├── spl-associated-token-account/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-binary-option/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-binary-oracle-pair/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-feature-proposal/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-governance/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-memo/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-name-service/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-record/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-stake-pool/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-stateless-asks/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-token/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   ├── spl-token-lending/
    │   │   │   ├── idl.json
    │   │   │   ├── package.json
    │   │   │   ├── rollup.config.ts
    │   │   │   ├── tsconfig.base.json
    │   │   │   ├── tsconfig.cjs.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── program/
    │   │   │   │   └── lib.rs
    │   │   │   └── src/
    │   │   │       ├── index.ts
    │   │   │       ├── program.ts
    │   │   │       └── coder/
    │   │   │           ├── accounts.ts
    │   │   │           ├── events.ts
    │   │   │           ├── index.ts
    │   │   │           ├── instructions.ts
    │   │   │           └── types.ts
    │   │   └── spl-token-swap/
    │   │       ├── idl.json
    │   │       ├── package.json
    │   │       ├── rollup.config.ts
    │   │       ├── tsconfig.base.json
    │   │       ├── tsconfig.cjs.json
    │   │       ├── tsconfig.json
    │   │       ├── program/
    │   │       │   └── lib.rs
    │   │       └── src/
    │   │           ├── index.ts
    │   │           ├── program.ts
    │   │           └── coder/
    │   │               ├── accounts.ts
    │   │               ├── events.ts
    │   │               ├── index.ts
    │   │               ├── instructions.ts
    │   │               └── types.ts
    │   └── tests/
    │       ├── package.json
    │       ├── tsconfig.json
    │       └── src/
    │           ├── constants.ts
    │           ├── index.ts
    │           ├── utils.ts
    │           └── spl/
    │               ├── associated-token-account.ts
    │               ├── binary-option.ts
    │               ├── binary-oracle-pair.ts
    │               ├── feature-proposal.ts
    │               ├── index.ts
    │               ├── memo.ts
    │               ├── name-service.ts
    │               ├── record.ts
    │               ├── stake-pool.ts
    │               ├── stateless-asks.ts
    │               ├── token-lending.ts
    │               ├── token-swap.ts
    │               └── token.ts
    └── .github/
        ├── issue_template.md
        ├── actions/
        │   ├── git-diff/
        │   │   └── action.yaml
        │   ├── setup/
        │   │   └── action.yaml
        │   ├── setup-solana/
        │   │   └── action.yaml
        │   └── setup-ts/
        │       └── action.yaml
        └── workflows/
            ├── no-caching-tests.yaml
            ├── release.yaml
            ├── reusable-tests.yaml
            └── tests.yaml

================================================
File: CODE_OF_CONDUCT.md
================================================
# Code of Conduct

The Anchor repository follows the Rust [Code of Conduct](https://www.rust-lang.org/policies/code-of-conduct).


================================================
File: CONTRIBUTING.md
================================================
# Contributing to Anchor

Thank you for your interest in contributing to Anchor! All contributions are welcome no
matter how big or small. This includes (but is not limited to) filing issues,
adding documentation, fixing bugs, creating examples, and implementing features.

## Finding issues to work on

If you're looking to get started,
check out [good first issues](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22)
or issues where [help is wanted](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22).
For simple documentation changes or typos, feel free to just open a pull request.

If you're considering larger changes or self motivated features, please file an issue
and engage with the maintainers in [Discord](https://discord.gg/NHHGSXAnXk).

## Choosing an issue

If you'd like to contribute, please claim an issue by commenting, forking, and
opening a pull request, even if empty. This allows the maintainers to track who
is working on what issue as to not overlap work.

## Issue Guidelines

Please follow these guidelines:

Before coding:

- choose a branch name that describes the issue you're working on
- enable [commit signing](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits)

While coding:

- Submit a draft PR asap
- Only change code directly relevant to your PR. Sometimes you might find some code that could really need some refactoring. However, if it's not relevant to your PR, do not touch it. File an issue instead. This allows the reviewer to focus on a single problem at a time.
- If you write comments, do not exceed 80 chars per line. This allows contributors who work with multiple open windows to still read the comments without horizontally scrolling.
- Write adversarial tests. For example, if you're adding a new account type, do not only write tests where the instruction succeeds. Also write tests that test whether the instruction fails, if a check inside the new type is violated.

After coding:

- If you've moved code around, build the docs with `cargo doc --open` and adjust broken links
- Adjust the cli templates if necessary
- If you've added a new folder to the `tests` directory, add it to the [CI](./.github/workflows/tests.yaml).


================================================
File: Cargo.toml
================================================
[profile.release]
lto = true

[profile.release.package.anchor-cli]
codegen-units = 1

[workspace]
members = [
    "avm",
    "cli",
    "client",
    "idl",
    "lang",
    "lang/attribute/*",
    "lang/derive/*",
    "lang/syn",
    "spl",
]
exclude = [
    "tests/swap/deps/openbook-dex",
    "tests/cfo/deps/openbook-dex",
]
resolver = "2"


================================================
File: Makefile
================================================
.PHONY: build-cli
build-cli:
	cargo build -p anchor-cli --release
	cp target/release/anchor cli/npm-package/anchor

.PHONY: clean
clean:
	find . -type d -name .anchor -print0 | xargs -0 rm -rf
	find . -type d -name node_modules -print0 | xargs -0 rm -rf
	find . -type d -name target -print0 | xargs -0 rm -rf

.PHONY: publish
publish:
	cd lang/syn/ && cargo publish && cd ../../
	sleep 25
	cd lang/derive/accounts/ && cargo publish && cd ../../../
	sleep 25
	cd lang/derive/serde/ && cargo publish && cd ../../../
	sleep 25
	cd lang/derive/space/ && cargo publish && cd ../../../
	sleep 25
	cd lang/attribute/access-control/ && cargo publish && cd ../../../
	sleep 25
	cd lang/attribute/account/ && cargo publish && cd ../../../
	sleep 25
	cd lang/attribute/constant/ && cargo publish && cd ../../../
	sleep 25
	cd lang/attribute/error/ && cargo publish && cd ../../../
	sleep 25
	cd lang/attribute/program/ && cargo publish && cd ../../..
	sleep 25
	cd lang/attribute/event/ && cargo publish && cd ../../../
	sleep 25
	cd lang/ && cargo publish && cd ../
	sleep 25
	cd spl/ && cargo publish && cd ../
	sleep 25
	cd client/ && cargo publish && cd ../
	sleep 25
	cd cli/ && cargo publish && cd ../
	sleep 25


================================================
File: VERSION
================================================
0.30.1


================================================
File: setup-tests.sh
================================================
#!/bin/bash

active_version=$(solana -V | awk '{print $2}')
if [ "$active_version" != "2.1.0" ]; then
  agave-install init 2.1.0
fi

git submodule update --init --recursive --depth 1
cd ts/packages/borsh && yarn --frozen-lockfile && yarn build && yarn link --force && cd ../../../
cd ts/packages/anchor-errors && yarn --frozen-lockfile && yarn build && yarn link --force && cd ../../../
cd ts/packages/anchor && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
cd ts/packages/spl-associated-token-account && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
cd ts/packages/spl-token && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
cd examples/tutorial && yarn link @coral-xyz/anchor @coral-xyz/borsh && yarn --frozen-lockfile && cd ../../
cd tests && yarn link @coral-xyz/anchor @coral-xyz/borsh @coral-xyz/spl-associated-token-account @coral-xyz/spl-token && yarn --frozen-lockfile && cd ..
cargo install --path cli anchor-cli --locked --force --debug


================================================
File: version-bump.sh
================================================
#!/bin/bash

set -e

if [ $# -eq 0 ]; then
    echo "Usage $0 VERSION"
    exit 1
fi

version=$1

echo "Bumping versions to $version"

# GNU/BSD compat
sedi=(-i)
case "$(uname)" in
  # For macOS, use two parameters
  Darwin*) sedi=(-i "")
esac

# Only replace version with the following globs
allow_globs=":**/Cargo.toml **/Makefile docs/src/pages/docs/*.md client/src/lib.rs"
git grep -l $(cat VERSION) -- $allow_globs |
    xargs sed "${sedi[@]}" \
    -e "s/$(cat VERSION)/$version/g"

# Potential for collisions in `package.json` files, handle those separately
# Replace only matching "version": "x.xx.x" and "@coral-xyz/anchor": "x.xx.x"
git grep -l $(cat VERSION) -- "**/package.json" | \
    xargs sed "${sedi[@]}" \
    -e "s/@coral-xyz\/anchor\": \"$(cat VERSION)\"/@coral-xyz\/anchor\": \"$version\"/g" \
    -e "s/\"version\": \"$(cat VERSION)\"/\"version\": \"$version\"/g"

# Insert version number into CHANGELOG
sed "${sedi[@]}" -e \
    "s/## \[Unreleased\]/## [Unreleased]\n\n### Features\n\n### Fixes\n\n### Breaking\n\n## [$version] - $(date '+%Y-%m-%d')/g" \
    CHANGELOG.md

pushd ts && yarn && popd
pushd tests && yarn && popd
pushd examples && yarn && pushd tutorial && yarn && popd && popd

# Bump benchmark files
pushd tests/bench && anchor run bump-version -- --anchor-version $version && popd

echo $version > VERSION

echo "$(git diff --stat | tail -n1) files modified"

echo " $(cat VERSION) changeset generated, commit and tag"


================================================
File: avm/Cargo.toml
================================================
[package]
name = "avm"
version = "0.30.1"
edition = "2021"

[[bin]]
name = "avm"
path = "src/main.rs"

[[bin]]
name = "anchor"
path = "src/anchor/main.rs"

[dependencies]
anyhow = "1.0.32"
cargo_toml = "0.19.2"
cfg-if = "1.0.0"
chrono = "0.4"
clap = { version = "4.5.17", features = ["derive"] }
clap_complete = "4.5.26"
dirs = "4.0.0"
reqwest = { version = "0.11.9", default-features = false, features = ["blocking", "json", "rustls-tls"] }
semver = "1.0.4"
serde = { version = "1.0.136", features = ["derive"] }

[dev-dependencies]
tempfile = "3.3.0"


================================================
File: avm/src/anchor/main.rs
================================================
use std::{env, process::Command};

fn main() -> anyhow::Result<()> {
    let args = env::args().skip(1).collect::<Vec<String>>();

    let version = avm::current_version()
        .map_err(|_e| anyhow::anyhow!("Anchor version not set. Please run `avm use latest`."))?;

    let binary_path = avm::version_binary_path(&version);
    if !binary_path.exists() {
        anyhow::bail!(
            "anchor-cli {} not installed. Please run `avm use {}`.",
            version,
            version
        );
    }

    let exit = Command::new(binary_path)
        .args(args)
        .spawn()?
        .wait_with_output()
        .expect("Failed to run anchor-cli");

    if !exit.status.success() {
        std::process::exit(exit.status.code().unwrap_or(1));
    }

    Ok(())
}


================================================
File: bench/BINARY_SIZE.md
================================================
# Binary Size

All notable changes in program binary size will be documented in this file.

The changes are calculated by comparing the current results with the last version's results. Increase in size is shown with 🔴 and decrease is shown with 🟢.

The programs and their tests are located in [/tests/bench](https://github.com/coral-xyz/anchor/tree/master/tests/bench).

> **Note**
> Results documented in this file are autogenerated. Running the tests will update the current results when necessary, manually editing the results should be avoided.

> **Warning**
> Results may vary depending on Solana version.

## [Unreleased]

Solana version: 2.1.0

| Program | Binary Size | -                        |
| ------- | ----------- | ------------------------ |
| bench   | 1,041,928   | 🔴 **+250,920 (31.72%)** |

### Notable changes

- lang: Use closures for `init` constraints to reduce the stack usage of `try_accounts`. Note that the binary size increase is exaggerated for the bench program because it uses unusual number of `init` constraints. Impact for normal programs will be a lot less severe. ([#2939](https://github.com/coral-xyz/anchor/pull/2939)).
- Upgrade to Solana `2.1.0`. This upgrade decreased the binary size ~5% (55,000 bytes) ([#3339](https://github.com/coral-xyz/anchor/pull/3339)).

---

## [0.30.1]

Solana version: 1.18.17

| Program | Binary Size | -   |
| ------- | ----------- | --- |
| bench   | 791,008     | -   |

### Notable changes

---

## [0.30.0]

Solana version: 1.18.8

| Program | Binary Size | -                      |
| ------- | ----------- | ---------------------- |
| bench   | 791,008     | 🔴 **+47,952 (6.45%)** |

### Notable changes

- Upgrade Solana to `1.18.8` ([#2867](https://github.com/coral-xyz/anchor/pull/2867)).

---

## [0.29.0]

Solana version: 1.17.0

| Program | Binary Size | +/-                      |
| ------- | ----------- | ------------------------ |
| bench   | 743,056     | 🟢 **-417,904 (36.00%)** |

### Notable changes

- `Box` the `anchor_lang::Result` error variants ([#2600](https://github.com/coral-xyz/anchor/pull/2600)).
- Change all accounts to have a reference to `AccountInfo` instead of cloning ([#2656](https://github.com/coral-xyz/anchor/pull/2656)).
- Reduce unnecessary cloning ([#2663](https://github.com/coral-xyz/anchor/pull/2663)).

---

## [0.28.0]

Solana version: 1.16.0

| Program | Binary Size | +/-                    |
| ------- | ----------- | ---------------------- |
| bench   | 1,160,960   | 🔴 **+23,272 (2.05%)** |

### Notable changes

- Upgrading Solana to `1.16`. The difference in binary size between `0.27.0` and `0.28.0` is the direct result of upgrading Solana version(both build tools and crates) ([#2512](https://github.com/coral-xyz/anchor/pull/2512)).

---

## [0.27.0]

Solana version: 1.14.16

| Program | Binary Size | +/- |
| ------- | ----------- | --- |
| bench   | 1,137,688   | N/A |

---


================================================
File: cli/Cargo.toml
================================================
[package]
name = "anchor-cli"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
edition = "2021"
repository = "https://github.com/coral-xyz/anchor"
description = "Anchor CLI"
license = "Apache-2.0"

[[bin]]
name = "anchor"
path = "src/bin/main.rs"

[features]
dev = []

[dependencies]
anchor-client = { path = "../client", version = "0.30.1" }
anchor-lang-idl = { path = "../idl", version = "0.1.1", features = ["build", "convert"] }
anchor-lang = { path = "../lang", version = "0.30.1" }
anyhow = "1.0.32"
base64 = "0.21"
bincode = "1.3.3"
cargo_toml = "0.19.2"
chrono = "0.4.19"
clap = { version = "4.5.17", features = ["derive"] }
clap_complete = "4.5.26"
dirs = "4.0"
flate2 = "1.0.19"
heck = "0.4.0"
pathdiff = "0.2.0"
portpicker = "0.1.1"
regex = "1.8.3"
reqwest = { version = "0.11.4", default-features = false, features = ["multipart", "blocking", "rustls-tls"] }
semver = "1.0.4"
serde = { version = "1.0.122", features = ["derive"] }
serde_json = "1.0"
shellexpand = "2.1.0"
solana-client = "2"
solana-cli-config = "2"
solana-faucet = "2"
solana-sdk = "2"
# Pin solang-parser because it may break in a backwards incompatible way in minor versions
solang-parser = "=0.3.3"
syn = { version = "1.0.60", features = ["full", "extra-traits"] }
tar = "0.4.35"
toml = "0.7.6"
walkdir = "2.3.2"


================================================
File: cli/npm-package/anchor.js
================================================
#!/usr/bin/env node
const fs = require("fs");
const { spawn, spawnSync } = require("child_process");
const path = require("path");
const { arch, platform } = require("os");
const { version } = require("./package.json");

const PACKAGE_VERSION = `anchor-cli ${version}`;
const PACKAGE_ANCHOR_PATH = path.join(__dirname, "anchor");

function getBinaryVersion(location) {
  const result = spawnSync(location, ["--version"]);
  const error =
    (result.error && result.error.toString()) ||
    (result.stderr.length > 0 && result.stderr.toString().trim()) ||
    null;
  return [error, result.stdout && result.stdout.toString().trim()];
}

function runAnchor(location) {
  const args = process.argv.slice(2);
  const anchor = spawn(location, args, { stdio: "inherit" });
  anchor.on("exit", (code, signal) => {
    process.on("exit", () => {
      if (signal) {
        process.kill(process.pid, signal);
      } else {
        process.exit(code);
      }
    });
  });

  process.on("SIGINT", function () {
    anchor.kill("SIGINT");
    anchor.kill("SIGTERM");
  });
}

function tryPackageAnchor() {
  if (arch() !== "x64" || platform() !== "linux") {
    console.error(`Only x86_64 / Linux distributed in NPM package right now.`);
    return false;
  }

  const [error, binaryVersion] = getBinaryVersion(PACKAGE_ANCHOR_PATH);
  if (error !== null) {
    console.error(`Failed to get version of local binary: ${error}`);
    return false;
  }
  if (binaryVersion !== PACKAGE_VERSION) {
    console.error(
      `Package binary version is not correct. Expected "${PACKAGE_VERSION}", found "${binaryVersion}".`
    );
    return false;
  }

  runAnchor(PACKAGE_ANCHOR_PATH);
  return true;
}

function trySystemAnchor() {
  console.error("Trying globally installed anchor.");

  const absolutePath = process.env.PATH.split(":")
    .filter((dir) => dir !== path.dirname(process.argv[1]))
    .find((dir) => {
      try {
        fs.accessSync(`${dir}/anchor`, fs.constants.X_OK);
      } catch {
        return false;
      }
      return true;
    });

  if (!absolutePath) {
    console.error(`Could not find globally installed anchor, install with cargo.`);
    process.exit();
  }

  const absoluteBinaryPath = `${absolutePath}/anchor`;

  const [error, binaryVersion] = getBinaryVersion(absoluteBinaryPath);
  if (error !== null) {
    console.error(`Failed to get version of global binary: ${error}`);
    return;
  }
  if (binaryVersion !== PACKAGE_VERSION) {
    console.error(
      `Globally installed anchor version is not correct. Expected "${PACKAGE_VERSION}", found "${binaryVersion}".`
    );
    return;
  }

  runAnchor(absoluteBinaryPath);
}

tryPackageAnchor() || trySystemAnchor();


================================================
File: cli/npm-package/package.json
================================================
{
  "name": "@coral-xyz/anchor-cli",
  "version": "0.30.1",
  "description": "Anchor CLI tool",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "license": "(MIT OR Apache-2.0)",
  "bin": {
    "anchor": "./anchor.js"
  },
  "scripts": {
    "prepack": "[ \"$(uname -op)\" != \"x86_64 GNU/Linux\" ] && (echo Can be packed only on x86_64 GNU/Linux && exit 1) || ([ \"$(./anchor --version)\" != \"anchor-cli $(jq -r .version package.json)\" ] && (echo Check anchor binary version && exit 2) || exit 0)"
  },
  "publishConfig": {
    "access": "public"
  }
}


================================================
File: cli/src/bin/main.rs
================================================
use anchor_cli::Opts;
use anyhow::Result;
use clap::Parser;

fn main() -> Result<()> {
    anchor_cli::entry(Opts::parse())
}


================================================
File: client/Cargo.toml
================================================
[package]
name = "anchor-client"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
edition = "2021"
license = "Apache-2.0"
description = "An RPC client to interact with Anchor programs"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
async = []
debug = []
mock = []

[dependencies]
anchor-lang = { path = "../lang", version = "0.30.1" }
anyhow = "1"
futures = "0.3"
regex = "1"
serde = { version = "1", features = ["derive"] }
solana-account-decoder = "2"
solana-client = "2"
solana-sdk = "2"
thiserror = "1"
tokio = { version = "1", features = ["rt", "sync"] }
url = "2"


================================================
File: client/example/Cargo.toml
================================================
[package]
name = "example"
version = "0.1.0"
authors = ["Armani Ferrante <armaniferrante@gmail.com>"]
edition = "2021"

[workspace]

[features]
async = ["anchor-client/async"]

[dependencies]
anchor-client = { path = "../", features = ["debug"] }
basic-2 = { path = "../../examples/tutorial/basic-2/programs/basic-2", features = ["no-entrypoint"] }
basic-4 = { path = "../../examples/tutorial/basic-4/programs/basic-4", features = ["no-entrypoint"] }
composite = { path = "../../tests/composite/programs/composite", features = ["no-entrypoint"] }
optional = { path = "../../tests/optional/programs/optional", features = ["no-entrypoint"] }
events = { path = "../../tests/events/programs/events", features = ["no-entrypoint"] }
anyhow = "1.0.32"
clap = { version = "4.2.4", features = ["derive"] }
shellexpand = "2.1.0"
solana-sdk = "2"
tokio = { version = "1", features = ["full"] }


================================================
File: client/example/src/main.rs
================================================
use anchor_client::solana_sdk::pubkey::Pubkey;
use anyhow::Result;
use clap::Parser;

#[cfg(not(feature = "async"))]
mod blocking;

#[cfg(feature = "async")]
mod nonblocking;

#[derive(Parser, Debug)]
pub struct Opts {
    #[clap(long)]
    composite_pid: Pubkey,
    #[clap(long)]
    basic_2_pid: Pubkey,
    #[clap(long)]
    basic_4_pid: Pubkey,
    #[clap(long)]
    events_pid: Pubkey,
    #[clap(long)]
    optional_pid: Pubkey,
    #[clap(long, default_value = "false")]
    multithreaded: bool,
}

// This example assumes a local validator is running with the programs
// deployed at the addresses given by the CLI args.
#[cfg(not(feature = "async"))]
fn main() -> Result<()> {
    blocking::main()
}

#[cfg(feature = "async")]
#[tokio::main]
async fn main() -> Result<()> {
    nonblocking::main().await
}


================================================
File: docker/Makefile
================================================
WORKDIR=$(PWD)
#
# Anchor version.
#
ANCHOR_CLI=v0.30.1
#
# Solana toolchain.
#
SOLANA_CLI=v2.1.0
#
# Build version should match the Anchor cli version.
#
IMG_ORG ?= backpackapp
IMG_VER ?= $(ANCHOR_CLI)

.PHONY: build build-push build-shell publish

default:

build: build/Dockerfile
	@docker build \
	--build-arg ANCHOR_CLI=$(ANCHOR_CLI) \
	--build-arg SOLANA_CLI=$(SOLANA_CLI) \
	$@ -t $(IMG_ORG)/$@:$(IMG_VER)

build-push:
	@docker push $(IMG_ORG)/build:$(IMG_VER)

build-shell:
	@docker run -ti --rm --net=host \
		-v $(WORKDIR)/..:/workdir \
		$(IMG_ORG)/build:$(IMG_VER) bash

publish: build build-push


================================================
File: docker/build/Dockerfile
================================================
#
# Docker image to generate deterministic, verifiable builds of Anchor programs.
# This must be run *after* a given ANCHOR_CLI version is published and a git tag
# is released on GitHub.
#

FROM ubuntu:22.04

ARG DEBIAN_FRONTEND=noninteractive

ARG SOLANA_CLI
ARG ANCHOR_CLI
ARG NODE_VERSION="v20.16.0"

ENV HOME="/root"
ENV PATH="${HOME}/.cargo/bin:${PATH}"
ENV PATH="${HOME}/.local/share/solana/install/active_release/bin:${PATH}"
ENV PATH="${HOME}/.nvm/versions/node/${NODE_VERSION}/bin:${PATH}"

# Install base utilities.
RUN mkdir -p /workdir && mkdir -p /tmp && \
    apt-get update -qq && apt-get upgrade -qq && apt-get install -qq \
    build-essential git curl wget jq pkg-config python3-pip \
    libssl-dev libudev-dev

# Install rust.
RUN curl "https://sh.rustup.rs" -sfo rustup.sh && \
    sh rustup.sh -y && \
    rustup component add rustfmt clippy

# Install node / npm / yarn.
RUN curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
ENV NVM_DIR="${HOME}/.nvm"
RUN . $NVM_DIR/nvm.sh && \
    nvm install ${NODE_VERSION} && \
    nvm use ${NODE_VERSION} && \
    nvm alias default node && \
    npm install -g yarn

# Install Solana tools.
RUN sh -c "$(curl -sSfL https://release.anza.xyz/${SOLANA_CLI}/install)"

# Install anchor.
RUN cargo install --git https://github.com/coral-xyz/anchor --tag ${ANCHOR_CLI} anchor-cli --locked

# Build a dummy program to bootstrap the BPF SDK (doing this speeds up builds).
RUN mkdir -p /tmp && cd tmp && anchor init dummy && cd dummy && anchor build

WORKDIR /workdir


================================================
File: docs/README.md
================================================
# Anchor Docs

## Getting started

```bash
npm install
cp .env.example .env.local
```

Next, run the development server:

```bash
npm run dev
```

Finally, open [http://localhost:3000](http://localhost:3000) in your browser to view the website.

## Customizing

You can start editing this template by modifying the files in the `/src` folder. The site will auto-update as you edit these files.


================================================
File: docs/jsconfig.json
================================================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}


================================================
File: docs/next.config.js
================================================
const withMarkdoc = require('@markdoc/next.js')
const { withPlausibleProxy } = require('next-plausible')

/** @type {import('next').NextConfig} */
const nextConfig = withMarkdoc()({
  swcMinify: true,
  reactStrictMode: true,
  pageExtensions: ['js', 'jsx', 'md'],
  experimental: {
    scrollRestoration: true,
    legacyBrowsers: false,
    images: { allowFutureImage: true },
  },
})

module.exports = withPlausibleProxy()(nextConfig)


================================================
File: docs/package.json
================================================
{
  "name": "anchor-docs",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "publish:typedoc": "gh-pages -d ./src/.vuepress/dist"
  },
  "browserslist": "defaults, not ie <= 11",
  "dependencies": {
    "@docsearch/react": "^3.1.1",
    "@headlessui/react": "^1.6.6",
    "@markdoc/markdoc": "^0.1.3",
    "@markdoc/next.js": "^0.1.6",
    "@sindresorhus/slugify": "^2.1.0",
    "@tailwindcss/typography": "^0.5.3",
    "autoprefixer": "^10.4.7",
    "clsx": "^1.2.1",
    "focus-visible": "^5.2.0",
    "gh-pages": "^5.0.0",
    "next": "12.2.1",
    "next-plausible": "^3.2.0",
    "postcss-focus-visible": "^6.0.4",
    "postcss-import": "^14.1.0",
    "prism-react-renderer": "^1.3.5",
    "prismjs": "^1.28.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "tailwindcss": "^3.1.5"
  },
  "devDependencies": {
    "eslint": "8.19.0",
    "eslint-config-next": "12.2.1",
    "prettier": "^2.7.1",
    "prettier-plugin-tailwindcss": "^0.1.12"
  }
}


================================================
File: docs/postcss.config.js
================================================
module.exports = {
  plugins: {
    'postcss-import': {},
    tailwindcss: {},
    'postcss-focus-visible': {
      replaceWith: '[data-focus-visible-added]',
    },
    autoprefixer: {},
  },
}


================================================
File: docs/prettier.config.js
================================================
module.exports = {
  singleQuote: true,
  semi: false,
  plugins: [require('prettier-plugin-tailwindcss')],
}


================================================
File: docs/tailwind.config.js
================================================
const defaultTheme = require('tailwindcss/defaultTheme')

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx}'],
  darkMode: 'class',
  theme: {
    fontSize: {
      xs: ['0.75rem', { lineHeight: '1rem' }],
      sm: ['0.875rem', { lineHeight: '1.5rem' }],
      base: ['1rem', { lineHeight: '2rem' }],
      lg: ['1.125rem', { lineHeight: '1.75rem' }],
      xl: ['1.25rem', { lineHeight: '2rem' }],
      '2xl': ['1.5rem', { lineHeight: '2.5rem' }],
      '3xl': ['2rem', { lineHeight: '2.5rem' }],
      '4xl': ['2.5rem', { lineHeight: '3rem' }],
      '5xl': ['3rem', { lineHeight: '3.5rem' }],
      '6xl': ['3.75rem', { lineHeight: '1' }],
      '7xl': ['4.5rem', { lineHeight: '1' }],
      '8xl': ['6rem', { lineHeight: '1' }],
      '9xl': ['8rem', { lineHeight: '1' }],
    },
    extend: {
      fontFamily: {
        sans: ['Inter', ...defaultTheme.fontFamily.sans],
        display: ['Lexend', ...defaultTheme.fontFamily.sans],
      },
      maxWidth: {
        '8xl': '88rem',
      },
    },
  },
  plugins: [require('@tailwindcss/typography')],
}


================================================
File: docs/vercel.sh
================================================
#!/bin/bash

git diff --quiet HEAD^ HEAD ./
has_changes=$?
echo ">> Diff status $has_changes"

if [[ $VERCEL_GIT_COMMIT_REF == "master" ]] || [ $has_changes == 1 ]; then
  echo ">> Proceeding with deployment."
  exit 1;
else
  echo ">> Skipping deployment."
  exit 0;
fi


================================================
File: docs/.env.example
================================================
NEXT_PUBLIC_DOCSEARCH_APP_ID=
NEXT_PUBLIC_DOCSEARCH_API_KEY=
NEXT_PUBLIC_DOCSEARCH_INDEX_NAME=


================================================
File: docs/.eslintrc.json
================================================
{
  "extends": "next/core-web-vitals"
}


================================================
File: docs/.gitignore
================================================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

.vscode/
.idea

================================================
File: docs/markdoc/nodes.js
================================================
import { Fence } from '@/components/Fence'

const nodes = {
  document: {
    render: undefined,
  },
  th: {
    attributes: {
      scope: {
        type: String,
        default: 'col',
      },
    },
    render: (props) => <th {...props} />,
  },
  fence: {
    render: Fence,
    attributes: {
      language: {
        type: String,
      },
    },
  },
}

export default nodes


================================================
File: docs/markdoc/tags.js
================================================
import { Callout } from '@/components/Callout'
import { LinkGrid } from '@/components/LinkGrid'

const tags = {
  callout: {
    attributes: {
      title: { type: String },
      type: {
        type: String,
        default: 'note',
        matches: ['note', 'warning'],
        errorLevel: 'critical',
      },
    },
    render: Callout,
  },
  figure: {
    selfClosing: true,
    attributes: {
      src: { type: String },
      alt: { type: String },
      caption: { type: String },
    },
    render: ({ src, alt = '', caption }) => (
      <figure>
        {/* eslint-disable-next-line @next/next/no-img-element */}
        <img src={src} alt={alt} />
        <figcaption>{caption}</figcaption>
      </figure>
    ),
  },
  'link-grid': {
    render: LinkGrid,
  },
  'link-grid-link': {
    selfClosing: true,
    render: LinkGrid.Link,
    attributes: {
      title: { type: String },
      description: { type: String },
      icon: { type: String },
      href: { type: String },
    },
  },
}

export default tags


================================================
File: docs/programs/tic-tac-toe/Anchor.toml
================================================
[programs.localnet]
tic_tac_toe = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run mocha"


================================================
File: docs/programs/tic-tac-toe/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: docs/programs/tic-tac-toe/package.json
================================================
{
    "type": "module",
    "dependencies": {
        "@coral-xyz/anchor": "^0.30.1"
    },
    "devDependencies": {
        "@types/chai": "^4.3.0",
        "@types/mocha": "^9.0.0",
        "chai": "^5.1.1",
        "mocha": "^10.7.0",
        "tsx": "^4.16.2",
        "typescript": "^4.3.5"
    }
}


================================================
File: docs/programs/tic-tac-toe/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "module": "ESNext",
    "target": "ESNext",
    "moduleResolution": "Node",
    "esModuleInterop": true,
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules"]
}


================================================
File: docs/programs/tic-tac-toe/.gitignore
================================================

.anchor
.DS_Store
target
**/*.rs.bk
node_modules


================================================
File: docs/programs/tic-tac-toe/.mocharc.json
================================================
{
  "node-option": ["import=tsx"],
  "extensions": ["ts"],
  "timeout": 1000000,
  "spec": [
    "tests/**/*.ts"
  ]
}

================================================
File: docs/programs/tic-tac-toe/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@project-serum/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
}


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/Cargo.toml
================================================
[package]
name = "tic-tac-toe"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "tic_tac_toe"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = "=0.30.1"
num-traits = "0.2"
num-derive = "0.3"


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/errors.rs
================================================
use anchor_lang::error_code;

#[error_code]
pub enum TicTacToeError {
    TileOutOfBounds,
    TileAlreadySet,
    GameAlreadyOver,
    NotPlayersTurn,
    GameAlreadyStarted,
}


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/lib.rs
================================================
use anchor_lang::prelude::*;
use instructions::*;
use state::game::Tile;

pub mod errors;
pub mod instructions;
pub mod state;

// this key needs to be changed to whatever public key is returned by "anchor keys list"
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod tic_tac_toe {
    use super::*;

    pub fn setup_game(ctx: Context<SetupGame>, player_two: Pubkey) -> Result<()> {
        instructions::setup_game::setup_game(ctx, player_two)
    }

    pub fn play(ctx: Context<Play>, tile: Tile) -> Result<()> {
        instructions::play::play(ctx, tile)
    }
}


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/instructions/mod.rs
================================================
pub use play::*;
pub use setup_game::*;

pub mod play;
pub mod setup_game;


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/instructions/play.rs
================================================
use crate::errors::TicTacToeError;
use crate::state::game::*;
use anchor_lang::prelude::*;

pub fn play(ctx: Context<Play>, tile: Tile) -> Result<()> {
    let game = &mut ctx.accounts.game;

    require_keys_eq!(
        game.current_player(),
        ctx.accounts.player.key(),
        TicTacToeError::NotPlayersTurn
    );

    game.play(&tile)
}

#[derive(Accounts)]
pub struct Play<'info> {
    #[account(mut)]
    pub game: Account<'info, Game>,
    pub player: Signer<'info>,
}


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/instructions/setup_game.rs
================================================
use crate::state::game::*;
use anchor_lang::prelude::*;

pub fn setup_game(ctx: Context<SetupGame>, player_two: Pubkey) -> Result<()> {
    ctx.accounts
        .game
        .start([ctx.accounts.player_one.key(), player_two])
}

#[derive(Accounts)]
pub struct SetupGame<'info> {
    #[account(init, payer = player_one, space = Game::MAXIMUM_SIZE + 8)]
    pub game: Account<'info, Game>,
    #[account(mut)]
    pub player_one: Signer<'info>,
    pub system_program: Program<'info, System>,
}


================================================
File: docs/programs/tic-tac-toe/programs/tic-tac-toe/src/state/mod.rs
================================================
pub use game::*;

pub mod game;


================================================
File: docs/src/components/Button.jsx
================================================
import Link from 'next/link'
import clsx from 'clsx'

const styles = {
  primary:
    'rounded-full bg-sky-300 py-2 px-4 text-sm font-semibold text-slate-900 hover:bg-sky-200 active:bg-sky-500 focus:outline-none focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-sky-300/50',
  secondary:
    'rounded-full bg-slate-800 py-2 px-4 text-sm font-medium text-white hover:bg-slate-700 active:text-slate-400 focus:outline-none focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white/50',
}

export function Button({ variant = 'primary', className, ...props }) {
  return <button className={clsx(styles[variant], className)} {...props} />
}

export function ButtonLink({ variant = 'primary', className, href, ...props }) {
  return (
    <Link href={href}>
      <a className={clsx(styles[variant], className)} {...props} />
    </Link>
  )
}


================================================
File: docs/src/components/Callout.jsx
================================================
import clsx from 'clsx'

import { Icon } from '@/components/Icon'

const styles = {
  note: {
    container:
      'bg-sky-50 dark:bg-slate-800/60 dark:ring-1 dark:ring-slate-300/10',
    title: 'text-sky-900 dark:text-sky-400',
    body: 'text-sky-800 prose-code:text-sky-900 dark:text-slate-300 dark:prose-code:text-slate-300 prose-a:text-sky-900 [--tw-prose-background:theme(colors.sky.50)]',
  },
  warning: {
    container:
      'bg-amber-50 dark:bg-slate-800/60 dark:ring-1 dark:ring-slate-300/10',
    title: 'text-amber-900 dark:text-amber-500',
    body: 'text-amber-800 prose-code:text-amber-900 prose-a:text-amber-900 [--tw-prose-underline:theme(colors.amber.400)] dark:[--tw-prose-underline:theme(colors.sky.700)] [--tw-prose-background:theme(colors.amber.50)] dark:text-slate-300 dark:prose-code:text-slate-300',
  },
}

const icons = {
  note: (props) => <Icon icon="lightbulb" {...props} />,
  warning: (props) => <Icon icon="warning" color="amber" {...props} />,
}

export function Callout({ type = 'note', title, children }) {
  let IconComponent = icons[type]

  return (
    <div className={clsx('my-8 flex rounded-3xl p-6', styles[type].container)}>
      <IconComponent className="h-8 w-8 flex-none" />
      <div className="ml-4 flex-auto">
        <p className={clsx('m-0 font-display text-xl', styles[type].title)}>
          {title}
        </p>
        <div className={clsx('prose mt-2.5', styles[type].body)}>
          {children}
        </div>
      </div>
    </div>
  )
}


================================================
File: docs/src/components/Fence.jsx
================================================
import { Fragment } from 'react'
import Highlight, { defaultProps } from 'prism-react-renderer'

export function Fence({ children, language }) {
  return (
    <Highlight
      {...defaultProps}
      code={children.trimEnd()}
      language={language}
      theme={undefined}
    >
      {({ className, style, tokens, getTokenProps }) => (
        <pre className={className} style={style}>
          <code>
            {tokens.map((line, index) => (
              <Fragment key={index}>
                {line.map((token, index) => (
                  <span key={index} {...getTokenProps({ token })} />
                ))}
                {'\n'}
              </Fragment>
            ))}
          </code>
        </pre>
      )}
    </Highlight>
  )
}


================================================
File: docs/src/components/Icon.jsx
================================================
import { useId } from 'react'
import clsx from 'clsx'

import { InstallationIcon } from '@/components/icons/InstallationIcon'
import { LightbulbIcon } from '@/components/icons/LightbulbIcon'
import { PluginsIcon } from '@/components/icons/PluginsIcon'
import { PresetsIcon } from '@/components/icons/PresetsIcon'
import { ThemingIcon } from '@/components/icons/ThemingIcon'
import { WarningIcon } from '@/components/icons/WarningIcon'

const icons = {
  installation: InstallationIcon,
  presets: PresetsIcon,
  plugins: PluginsIcon,
  theming: ThemingIcon,
  lightbulb: LightbulbIcon,
  warning: WarningIcon,
}

const iconStyles = {
  blue: '[--icon-foreground:theme(colors.slate.900)] [--icon-background:theme(colors.white)]',
  amber:
    '[--icon-foreground:theme(colors.amber.900)] [--icon-background:theme(colors.amber.100)]',
}

export function Icon({ color = 'blue', icon, className, ...props }) {
  let id = useId()
  let IconComponent = icons[icon]

  return (
    <svg
      aria-hidden="true"
      viewBox="0 0 32 32"
      fill="none"
      className={clsx(className, iconStyles[color])}
      {...props}
    >
      <IconComponent id={id} color={color} />
    </svg>
  )
}

const gradients = {
  blue: [
    { stopColor: '#0EA5E9' },
    { stopColor: '#22D3EE', offset: '.527' },
    { stopColor: '#818CF8', offset: 1 },
  ],
  amber: [
    { stopColor: '#FDE68A', offset: '.08' },
    { stopColor: '#F59E0B', offset: '.837' },
  ],
}

export function Gradient({ color = 'blue', ...props }) {
  return (
    <radialGradient
      cx={0}
      cy={0}
      r={1}
      gradientUnits="userSpaceOnUse"
      {...props}
    >
      {gradients[color].map((stop, index) => (
        <stop key={index} {...stop} />
      ))}
    </radialGradient>
  )
}

export function LightMode({ className, ...props }) {
  return <g className={clsx('dark:hidden', className)} {...props} />
}

export function DarkMode({ className, ...props }) {
  return <g className={clsx('hidden dark:inline', className)} {...props} />
}


================================================
File: docs/src/components/LinkGrid.jsx
================================================
import NextLink from 'next/link'

import { Icon } from '@/components/Icon'

export function LinkGrid({ children }) {
  return (
    <div className="not-prose my-12 grid grid-cols-1 gap-6 sm:grid-cols-2">
      {children}
    </div>
  )
}

LinkGrid.Link = function Link({ title, description, href, icon }) {
  return (
    <div className="group relative rounded-xl border border-slate-200 dark:border-slate-800">
      <div className="absolute -inset-px rounded-xl border-2 border-transparent opacity-0 [background:linear-gradient(var(--link-grid-hover-bg,theme(colors.sky.50)),var(--link-grid-hover-bg,theme(colors.sky.50)))_padding-box,linear-gradient(to_top,theme(colors.indigo.400),theme(colors.cyan.400),theme(colors.sky.500))_border-box] group-hover:opacity-100 dark:[--link-grid-hover-bg:theme(colors.slate.800)]" />
      <div className="relative overflow-hidden rounded-xl p-6">
        <Icon icon={icon} className="h-8 w-8" />
        <h2 className="mt-4 font-display text-base text-slate-900 dark:text-white">
          <NextLink href={href}>
            <a>
              <span className="absolute -inset-px rounded-xl" />
              {title}
            </a>
          </NextLink>
        </h2>
        <p className="mt-1 text-sm text-slate-700 dark:text-slate-400">
          {description}
        </p>
      </div>
    </div>
  )
}


================================================
File: docs/src/components/Logo.jsx
================================================
import Image from 'next/image'

export function Logo() {
  return (
    <div className="hidden min-w-full items-center gap-2 lg:flex">
      <Image src="/logo.png" alt="Logo" width={30} height={30} />
      <span className="text-xl font-semibold dark:text-white">Anchor</span>
    </div>
  )
}


================================================
File: docs/src/components/MobileNavigation.jsx
================================================
import { useEffect, useState } from 'react'
import Link from 'next/link'
import { useRouter } from 'next/router'
import { Dialog } from '@headlessui/react'

import { Logo } from '@/components/Logo'
import { Navigation } from '@/components/Navigation'

export function MobileNavigation({ navigation }) {
  let router = useRouter()
  let [isOpen, setIsOpen] = useState(false)

  useEffect(() => {
    if (!isOpen) return

    function onRouteChange() {
      setIsOpen(false)
    }

    router.events.on('routeChangeComplete', onRouteChange)
    router.events.on('routeChangeError', onRouteChange)

    return () => {
      router.events.off('routeChangeComplete', onRouteChange)
      router.events.off('routeChangeError', onRouteChange)
    }
  }, [router, isOpen])

  return (
    <>
      <button
        type="button"
        onClick={() => setIsOpen(true)}
        className="relative"
      >
        <span className="sr-only">Open navigation</span>
        <svg
          aria-hidden="true"
          className="h-6 w-6 stroke-slate-500"
          fill="none"
          strokeWidth="2"
          strokeLinecap="round"
        >
          <path d="M4 7h16M4 12h16M4 17h16" />
        </svg>
      </button>
      <Dialog
        open={isOpen}
        onClose={setIsOpen}
        className="fixed inset-0 z-50 flex items-start overflow-y-auto bg-slate-900/50 pr-10 backdrop-blur lg:hidden"
      >
        <Dialog.Panel className="min-h-full w-full max-w-xs bg-white px-4 pt-5 pb-12 dark:bg-slate-900 sm:px-6">
          <Dialog.Title className="sr-only">Navigation</Dialog.Title>
          <div className="flex items-center">
            <button type="button" onClick={() => setIsOpen(false)}>
              <span className="sr-only">Close navigation</span>
              <svg
                aria-hidden="true"
                className="h-6 w-6 stroke-slate-500"
                fill="none"
                strokeWidth="2"
                strokeLinecap="round"
              >
                <path d="M5 5l14 14M19 5l-14 14" />
              </svg>
            </button>
            <Link href="/">
              <a className="ml-6 block w-10 overflow-hidden lg:w-auto">
                <span className="sr-only">Home page</span>
                <Logo />
              </a>
            </Link>
          </div>
          <Navigation navigation={navigation} className="mt-5 px-1" />
        </Dialog.Panel>
      </Dialog>
    </>
  )
}


================================================
File: docs/src/components/Navigation.jsx
================================================
import Link from 'next/link'
import { useRouter } from 'next/router'
import clsx from 'clsx'

export function Navigation({ navigation, className }) {
  let router = useRouter()

  return (
    <nav className={clsx('text-base lg:text-sm', className)}>
      <ul className="space-y-9">
        {navigation.map((section) => (
          <li key={section.title}>
            <h2 className="font-display font-medium text-slate-900 dark:text-white">
              {section.title}
            </h2>
            <ul className="mt-2 space-y-2 border-l-2 border-slate-100 dark:border-slate-800 lg:mt-4 lg:space-y-4 lg:border-slate-200">
              {section.links.map((link) => (
                <li key={link.href} className="relative">
                  <Link href={link.href}>
                    <a
                      {...(link.href.startsWith('/')
                        ? {}
                        : { target: '_blank', rel: 'noopener noreferrer' })}
                      className={clsx(
                        'block w-full pl-3.5 before:pointer-events-none before:absolute before:-left-1 before:top-1/2 before:h-1.5 before:w-1.5 before:-translate-y-1/2 before:rounded-full',
                        {
                          'font-semibold text-sky-500 before:bg-sky-500':
                            link.href === router.pathname,
                          'text-slate-500 before:hidden before:bg-slate-300 hover:text-slate-600 hover:before:block dark:text-slate-400 dark:before:bg-slate-700 dark:hover:text-slate-300':
                            link.href !== router.pathname,
                        }
                      )}
                    >
                      {link.title}
                    </a>
                  </Link>
                </li>
              ))}
            </ul>
          </li>
        ))}
      </ul>
    </nav>
  )
}


================================================
File: docs/src/components/Prose.jsx
================================================
import clsx from 'clsx'

export function Prose({ as: Component = 'div', className, ...props }) {
  return (
    <Component
      className={clsx(
        className,
        'prose prose-slate max-w-none dark:prose-invert dark:text-slate-400',
        // headings
        'prose-headings:scroll-mt-28 prose-headings:font-display prose-headings:font-normal lg:prose-headings:scroll-mt-[8.5rem]',
        // lead
        'prose-lead:text-slate-500 dark:prose-lead:text-slate-400',
        // links
        'prose-a:font-semibold dark:prose-a:text-sky-400',
        // link underline
        'prose-a:no-underline prose-a:shadow-[inset_0_-2px_0_0_var(--tw-prose-background,#fff),inset_0_calc(-1*(var(--tw-prose-underline-size,4px)+2px))_0_0_var(--tw-prose-underline,theme(colors.sky.300))] hover:prose-a:[--tw-prose-underline-size:6px] dark:[--tw-prose-background:theme(colors.slate.900)] dark:prose-a:shadow-[inset_0_calc(-1*var(--tw-prose-underline-size,2px))_0_0_var(--tw-prose-underline,theme(colors.sky.800))] dark:hover:prose-a:[--tw-prose-underline-size:6px]',
        // pre
        'prose-pre:rounded-xl prose-pre:bg-slate-900 prose-pre:shadow-lg dark:prose-pre:bg-slate-800/60 dark:prose-pre:shadow-none dark:prose-pre:ring-1 dark:prose-pre:ring-slate-300/10',
        // hr
        'dark:prose-hr:border-slate-800'
      )}
      {...props}
    />
  )
}


================================================
File: docs/src/components/Search.jsx
================================================
import { useCallback, useEffect, useState } from 'react'
import { createPortal } from 'react-dom'
import Link from 'next/link'
import Router from 'next/router'
import { DocSearchModal, useDocSearchKeyboardEvents } from '@docsearch/react'

const docSearchConfig = {
  appId: process.env.NEXT_PUBLIC_DOCSEARCH_APP_ID,
  apiKey: process.env.NEXT_PUBLIC_DOCSEARCH_API_KEY,
  indexName: process.env.NEXT_PUBLIC_DOCSEARCH_INDEX_NAME,
}

function Hit({ hit, children }) {
  return (
    <Link href={hit.url}>
      <a>{children}</a>
    </Link>
  )
}

export function Search() {
  let [isOpen, setIsOpen] = useState(false)
  let [modifierKey, setModifierKey] = useState()

  const onOpen = useCallback(() => {
    setIsOpen(true)
  }, [setIsOpen])

  const onClose = useCallback(() => {
    setIsOpen(false)
  }, [setIsOpen])

  useDocSearchKeyboardEvents({ isOpen, onOpen, onClose })

  useEffect(() => {
    setModifierKey(
      /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) ? '⌘' : 'Ctrl '
    )
  }, [])

  return (
    <>
      <button
        type="button"
        className="group flex h-6 w-6 items-center justify-center sm:justify-start md:h-auto md:w-80 md:flex-none md:rounded-lg md:py-2.5 md:pl-4 md:pr-3.5 md:text-sm md:ring-1 md:ring-slate-200 md:hover:ring-slate-300 dark:md:bg-slate-800/75 dark:md:ring-inset dark:md:ring-white/5 dark:md:hover:bg-slate-700/40 dark:md:hover:ring-slate-500 lg:w-96"
        onClick={onOpen}
      >
        <svg
          aria-hidden="true"
          className="h-5 w-5 flex-none fill-slate-400 group-hover:fill-slate-500 dark:fill-slate-500 md:group-hover:fill-slate-400"
        >
          <path d="M16.293 17.707a1 1 0 0 0 1.414-1.414l-1.414 1.414ZM9 14a5 5 0 0 1-5-5H2a7 7 0 0 0 7 7v-2ZM4 9a5 5 0 0 1 5-5V2a7 7 0 0 0-7 7h2Zm5-5a5 5 0 0 1 5 5h2a7 7 0 0 0-7-7v2Zm8.707 12.293-3.757-3.757-1.414 1.414 3.757 3.757 1.414-1.414ZM14 9a4.98 4.98 0 0 1-1.464 3.536l1.414 1.414A6.98 6.98 0 0 0 16 9h-2Zm-1.464 3.536A4.98 4.98 0 0 1 9 14v2a6.98 6.98 0 0 0 4.95-2.05l-1.414-1.414Z" />
        </svg>
        <span className="sr-only md:not-sr-only md:ml-2 md:text-slate-500 md:dark:text-slate-400">
          Search docs
        </span>
        {modifierKey && (
          <kbd className="ml-auto hidden font-medium text-slate-400 dark:text-slate-500 md:block">
            <kbd className="font-sans">{modifierKey}</kbd>
            <kbd className="font-sans">K</kbd>
          </kbd>
        )}
      </button>
      {isOpen &&
        createPortal(
          <DocSearchModal
            {...docSearchConfig}
            initialScrollY={window.scrollY}
            onClose={onClose}
            hitComponent={Hit}
            navigator={{
              navigate({ itemUrl }) {
                Router.push(itemUrl)
              },
            }}
          />,
          document.body
        )}
    </>
  )
}


================================================
File: docs/src/components/icons/InstallationIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function InstallationIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 12 3)"
        />
        <Gradient
          id={`${id}-gradient-dark`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 16 7)"
        />
      </defs>
      <LightMode>
        <circle cx={12} cy={12} r={12} fill={`url(#${id}-gradient)`} />
        <path
          d="m8 8 9 21 2-10 10-2L8 8Z"
          fillOpacity={0.5}
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </LightMode>
      <DarkMode>
        <path
          d="m4 4 10.286 24 2.285-11.429L28 14.286 4 4Z"
          fill={`url(#${id}-gradient-dark)`}
          stroke={`url(#${id}-gradient-dark)`}
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/components/icons/LightbulbIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function LightbulbIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 20 11)"
        />
        <Gradient
          id={`${id}-gradient-dark`}
          color={color}
          gradientTransform="matrix(0 24.5001 -19.2498 0 16 5.5)"
        />
      </defs>
      <LightMode>
        <circle cx={20} cy={20} r={12} fill={`url(#${id}-gradient)`} />
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M20 24.995c0-1.855 1.094-3.501 2.427-4.792C24.61 18.087 26 15.07 26 12.231 26 7.133 21.523 3 16 3S6 7.133 6 12.23c0 2.84 1.389 5.857 3.573 7.973C10.906 21.494 12 23.14 12 24.995V27a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-2.005Z"
          className="fill-[var(--icon-background)]"
          fillOpacity={0.5}
        />
        <path
          d="M25 12.23c0 2.536-1.254 5.303-3.269 7.255l1.391 1.436c2.354-2.28 3.878-5.547 3.878-8.69h-2ZM16 4c5.047 0 9 3.759 9 8.23h2C27 6.508 21.998 2 16 2v2Zm-9 8.23C7 7.76 10.953 4 16 4V2C10.002 2 5 6.507 5 12.23h2Zm3.269 7.255C8.254 17.533 7 14.766 7 12.23H5c0 3.143 1.523 6.41 3.877 8.69l1.392-1.436ZM13 27v-2.005h-2V27h2Zm1 1a1 1 0 0 1-1-1h-2a3 3 0 0 0 3 3v-2Zm4 0h-4v2h4v-2Zm1-1a1 1 0 0 1-1 1v2a3 3 0 0 0 3-3h-2Zm0-2.005V27h2v-2.005h-2ZM8.877 20.921C10.132 22.136 11 23.538 11 24.995h2c0-2.253-1.32-4.143-2.731-5.51L8.877 20.92Zm12.854-1.436C20.32 20.852 19 22.742 19 24.995h2c0-1.457.869-2.859 2.122-4.074l-1.391-1.436Z"
          className="fill-[var(--icon-foreground)]"
        />
        <path
          d="M20 26a1 1 0 1 0 0-2v2Zm-8-2a1 1 0 1 0 0 2v-2Zm2 0h-2v2h2v-2Zm1 1V13.5h-2V25h2Zm-5-11.5v1h2v-1h-2Zm3.5 4.5h5v-2h-5v2Zm8.5-3.5v-1h-2v1h2ZM20 24h-2v2h2v-2Zm-2 0h-4v2h4v-2Zm-1-10.5V25h2V13.5h-2Zm2.5-2.5a2.5 2.5 0 0 0-2.5 2.5h2a.5.5 0 0 1 .5-.5v-2Zm2.5 2.5a2.5 2.5 0 0 0-2.5-2.5v2a.5.5 0 0 1 .5.5h2ZM18.5 18a3.5 3.5 0 0 0 3.5-3.5h-2a1.5 1.5 0 0 1-1.5 1.5v2ZM10 14.5a3.5 3.5 0 0 0 3.5 3.5v-2a1.5 1.5 0 0 1-1.5-1.5h-2Zm2.5-3.5a2.5 2.5 0 0 0-2.5 2.5h2a.5.5 0 0 1 .5-.5v-2Zm2.5 2.5a2.5 2.5 0 0 0-2.5-2.5v2a.5.5 0 0 1 .5.5h2Z"
          className="fill-[var(--icon-foreground)]"
        />
      </LightMode>
      <DarkMode>
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M16 2C10.002 2 5 6.507 5 12.23c0 3.144 1.523 6.411 3.877 8.691.75.727 1.363 1.52 1.734 2.353.185.415.574.726 1.028.726H12a1 1 0 0 0 1-1v-4.5a.5.5 0 0 0-.5-.5A3.5 3.5 0 0 1 9 14.5V14a3 3 0 1 1 6 0v9a1 1 0 1 0 2 0v-9a3 3 0 1 1 6 0v.5a3.5 3.5 0 0 1-3.5 3.5.5.5 0 0 0-.5.5V23a1 1 0 0 0 1 1h.36c.455 0 .844-.311 1.03-.726.37-.833.982-1.626 1.732-2.353 2.354-2.28 3.878-5.547 3.878-8.69C27 6.507 21.998 2 16 2Zm5 25a1 1 0 0 0-1-1h-8a1 1 0 0 0-1 1 3 3 0 0 0 3 3h4a3 3 0 0 0 3-3Zm-8-13v1.5a.5.5 0 0 1-.5.5 1.5 1.5 0 0 1-1.5-1.5V14a1 1 0 1 1 2 0Zm6.5 2a.5.5 0 0 1-.5-.5V14a1 1 0 1 1 2 0v.5a1.5 1.5 0 0 1-1.5 1.5Z"
          fill={`url(#${id}-gradient-dark)`}
        />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/components/icons/PluginsIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function PluginsIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 20 11)"
        />
        <Gradient
          id={`${id}-gradient-dark-1`}
          color={color}
          gradientTransform="matrix(0 22.75 -22.75 0 16 6.25)"
        />
        <Gradient
          id={`${id}-gradient-dark-2`}
          color={color}
          gradientTransform="matrix(0 14 -14 0 16 10)"
        />
      </defs>
      <LightMode>
        <circle cx={20} cy={20} r={12} fill={`url(#${id}-gradient)`} />
        <g
          fillOpacity={0.5}
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M3 9v14l12 6V15L3 9Z" />
          <path d="M27 9v14l-12 6V15l12-6Z" />
        </g>
        <path
          d="M11 4h8v2l6 3-10 6L5 9l6-3V4Z"
          fillOpacity={0.5}
          className="fill-[var(--icon-background)]"
        />
        <g
          className="stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M20 5.5 27 9l-12 6L3 9l7-3.5" />
          <path d="M20 5c0 1.105-2.239 2-5 2s-5-.895-5-2m10 0c0-1.105-2.239-2-5-2s-5 .895-5 2m10 0v3c0 1.105-2.239 2-5 2s-5-.895-5-2V5" />
        </g>
      </LightMode>
      <DarkMode strokeWidth={2} strokeLinecap="round" strokeLinejoin="round">
        <path
          d="M17.676 3.38a3.887 3.887 0 0 0-3.352 0l-9 4.288C3.907 8.342 3 9.806 3 11.416v9.168c0 1.61.907 3.073 2.324 3.748l9 4.288a3.887 3.887 0 0 0 3.352 0l9-4.288C28.093 23.657 29 22.194 29 20.584v-9.168c0-1.61-.907-3.074-2.324-3.748l-9-4.288Z"
          stroke={`url(#${id}-gradient-dark-1)`}
        />
        <path
          d="M16.406 8.087a.989.989 0 0 0-.812 0l-7 3.598A1.012 1.012 0 0 0 8 12.61v6.78c0 .4.233.762.594.925l7 3.598a.989.989 0 0 0 .812 0l7-3.598c.361-.163.594-.525.594-.925v-6.78c0-.4-.233-.762-.594-.925l-7-3.598Z"
          fill={`url(#${id}-gradient-dark-2)`}
          stroke={`url(#${id}-gradient-dark-2)`}
        />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/components/icons/PresetsIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function PresetsIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 20 3)"
        />
        <Gradient
          id={`${id}-gradient-dark`}
          color={color}
          gradientTransform="matrix(0 22.75 -22.75 0 16 6.25)"
        />
      </defs>
      <LightMode>
        <circle cx={20} cy={12} r={12} fill={`url(#${id}-gradient)`} />
        <g
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          fillOpacity={0.5}
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M3 5v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2Z" />
          <path d="M18 17v10a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V17a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2Z" />
          <path d="M18 5v4a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-7a2 2 0 0 0-2 2Z" />
          <path d="M3 25v2a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2Z" />
        </g>
      </LightMode>
      <DarkMode fill={`url(#${id}-gradient-dark)`}>
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M3 17V4a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm16 10v-9a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2Zm0-23v5a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-8a1 1 0 0 0-1 1ZM3 28v-3a1 1 0 0 1 1-1h9a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Z"
        />
        <path d="M2 4v13h2V4H2Zm2-2a2 2 0 0 0-2 2h2V2Zm8 0H4v2h8V2Zm2 2a2 2 0 0 0-2-2v2h2Zm0 13V4h-2v13h2Zm-2 2a2 2 0 0 0 2-2h-2v2Zm-8 0h8v-2H4v2Zm-2-2a2 2 0 0 0 2 2v-2H2Zm16 1v9h2v-9h-2Zm3-3a3 3 0 0 0-3 3h2a1 1 0 0 1 1-1v-2Zm6 0h-6v2h6v-2Zm3 3a3 3 0 0 0-3-3v2a1 1 0 0 1 1 1h2Zm0 9v-9h-2v9h2Zm-3 3a3 3 0 0 0 3-3h-2a1 1 0 0 1-1 1v2Zm-6 0h6v-2h-6v2Zm-3-3a3 3 0 0 0 3 3v-2a1 1 0 0 1-1-1h-2Zm2-18V4h-2v5h2Zm0 0h-2a2 2 0 0 0 2 2V9Zm8 0h-8v2h8V9Zm0 0v2a2 2 0 0 0 2-2h-2Zm0-5v5h2V4h-2Zm0 0h2a2 2 0 0 0-2-2v2Zm-8 0h8V2h-8v2Zm0 0V2a2 2 0 0 0-2 2h2ZM2 25v3h2v-3H2Zm2-2a2 2 0 0 0-2 2h2v-2Zm9 0H4v2h9v-2Zm2 2a2 2 0 0 0-2-2v2h2Zm0 3v-3h-2v3h2Zm-2 2a2 2 0 0 0 2-2h-2v2Zm-9 0h9v-2H4v2Zm-2-2a2 2 0 0 0 2 2v-2H2Z" />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/components/icons/ThemingIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function ThemingIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="matrix(0 21 -21 0 12 11)"
        />
        <Gradient
          id={`${id}-gradient-dark`}
          color={color}
          gradientTransform="matrix(0 24.5 -24.5 0 16 5.5)"
        />
      </defs>
      <LightMode>
        <circle cx={12} cy={20} r={12} fill={`url(#${id}-gradient)`} />
        <path
          d="M27 12.13 19.87 5 13 11.87v14.26l14-14Z"
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          fillOpacity={0.5}
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M3 3h10v22a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4V3Z"
          className="fill-[var(--icon-background)]"
          fillOpacity={0.5}
        />
        <path
          d="M3 9v16a4 4 0 0 0 4 4h2a4 4 0 0 0 4-4V9M3 9V3h10v6M3 9h10M3 15h10M3 21h10"
          className="stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M29 29V19h-8.5L13 26c0 1.5-2.5 3-5 3h21Z"
          fillOpacity={0.5}
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </LightMode>
      <DarkMode>
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M3 2a1 1 0 0 0-1 1v21a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H3Zm16.752 3.293a1 1 0 0 0-1.593.244l-1.045 2A1 1 0 0 0 17 8v13a1 1 0 0 0 1.71.705l7.999-8.045a1 1 0 0 0-.002-1.412l-6.955-6.955ZM26 18a1 1 0 0 0-.707.293l-10 10A1 1 0 0 0 16 30h13a1 1 0 0 0 1-1V19a1 1 0 0 0-1-1h-3ZM5 18a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H5Zm-1-5a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H5a1 1 0 0 1-1-1Zm1-7a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2H5Z"
          fill={`url(#${id}-gradient-dark)`}
        />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/components/icons/WarningIcon.jsx
================================================
import { DarkMode, Gradient, LightMode } from '@/components/Icon'

export function WarningIcon({ id, color }) {
  return (
    <>
      <defs>
        <Gradient
          id={`${id}-gradient`}
          color={color}
          gradientTransform="rotate(65.924 1.519 20.92) scale(25.7391)"
        />
        <Gradient
          id={`${id}-gradient-dark`}
          color={color}
          gradientTransform="matrix(0 24.5 -24.5 0 16 5.5)"
        />
      </defs>
      <LightMode>
        <circle cx={20} cy={20} r={12} fill={`url(#${id}-gradient)`} />
        <path
          d="M3 16c0 7.18 5.82 13 13 13s13-5.82 13-13S23.18 3 16 3 3 8.82 3 16Z"
          fillOpacity={0.5}
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="m15.408 16.509-1.04-5.543a1.66 1.66 0 1 1 3.263 0l-1.039 5.543a.602.602 0 0 1-1.184 0Z"
          className="fill-[var(--icon-foreground)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
        <path
          d="M16 23a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
          fillOpacity={0.5}
          stroke="currentColor"
          className="fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]"
          strokeWidth={2}
          strokeLinecap="round"
          strokeLinejoin="round"
        />
      </LightMode>
      <DarkMode>
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M2 16C2 8.268 8.268 2 16 2s14 6.268 14 14-6.268 14-14 14S2 23.732 2 16Zm11.386-4.85a2.66 2.66 0 1 1 5.228 0l-1.039 5.543a1.602 1.602 0 0 1-3.15 0l-1.04-5.543ZM16 20a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z"
          fill={`url(#${id}-gradient-dark)`}
        />
      </DarkMode>
    </>
  )
}


================================================
File: docs/src/pages/_document.jsx
================================================
import { Head, Html, Main, NextScript } from 'next/document'

const themeScript = `
  let mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')

  function updateTheme(savedTheme) {
    let theme = 'system'
    try {
      if (!savedTheme) {
        savedTheme = window.localStorage.theme
      }
      if (savedTheme === 'dark') {
        theme = 'dark'
        document.documentElement.classList.add('dark')
      } else if (savedTheme === 'light') {
        theme = 'light'
        document.documentElement.classList.remove('dark')
      } else if (mediaQuery.matches) {
        document.documentElement.classList.add('dark')
      } else {
        document.documentElement.classList.remove('dark')
      }
    } catch {
      theme = 'light'
      document.documentElement.classList.remove('dark')
    }
    return theme
  }

  function updateThemeWithoutTransitions(savedTheme) {
    updateTheme(savedTheme)
    document.documentElement.classList.add('[&_*]:!transition-none')
    window.setTimeout(() => {
      document.documentElement.classList.remove('[&_*]:!transition-none')
    }, 0)
  }

  document.documentElement.setAttribute('data-theme', updateTheme())

  new MutationObserver(([{ oldValue }]) => {
    let newValue = document.documentElement.getAttribute('data-theme')
    if (newValue !== oldValue) {
      try {
        window.localStorage.setItem('theme', newValue)
      } catch {}
      updateThemeWithoutTransitions(newValue)
    }
  }).observe(document.documentElement, { attributeFilter: ['data-theme'], attributeOldValue: true })

  mediaQuery.addEventListener('change', updateThemeWithoutTransitions)
  window.addEventListener('storage', updateThemeWithoutTransitions)
`

export default function Document() {
  return (
    <Html className="antialiased [font-feature-settings:'ss01']" lang="en">
      <Head>
        <script dangerouslySetInnerHTML={{ __html: themeScript }} />
      </Head>
      <body className="bg-white dark:bg-slate-900">
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}


================================================
File: docs/src/pages/index.md
================================================
---
title: Introduction
pageTitle: Anchor - Introduction
description: Anchor is a framework for building secure Solana programs, often called 'smart contracts'.
---

Anchor is a framework for quickly building secure Solana programs.{% .lead %}

{% link-grid %}

{% link-grid-link title="Installation" icon="installation" href="/docs/installation" description="Step-by-step guides to setting up your system and installing Anchor." /%}

{% link-grid-link title="Intro to Solana" icon="presets" href="/docs/intro-to-solana" description="Brief intro to programming on Solana." /%}

{% link-grid-link title="High-Level Overview" icon="plugins" href="/docs/high-level-overview" description="High-Level Overview of an Anchor program." /%}

{% link-grid-link title="CLI reference" icon="theming" href="/docs/cli" description="A CLI is provided to support building and managing an Anchor workspace." /%}

{% /link-grid %}

---

## What is Anchor

With Anchor you can quickly build secure Solana programs, sometimes called 'smart contracts', because: 

 - Anchor writes various boilerplate for you such as (de)serialization of accounts and instruction data.
 - Anchor handles certain security checks for you, and allows you to succinctly define additional checks and keep them separate from your business logic.

Both of these aspects mean that instead of working on the tedious parts of raw Solana programs, you can spend more time working on what matters most, your product.

### Twitter

[Stay up to date on Twitter](https://twitter.com/anchorlang)

### Join the community

[Discord Invitation](https://discord.gg/NHHGSXAnXk)


================================================
File: docs/src/pages/docs/avm.md
================================================
---
title: Anchor Version Manager
description: Anchor - Anchor Version Manager
---

Anchor Version Manager (avm) is provided to manage multiple installations of the anchor-cli binary. This may be required to produce verifiable builds, or if you'd prefer to work with an alternate version.

---

```shell
Anchor version manager

USAGE:
    avm <SUBCOMMAND>

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    help         Print this message or the help of the given subcommand(s)
    install      Install a version of Anchor
    list         List available versions of Anchor
    uninstall    Uninstall a version of Anchor
    use          Use a specific version of Anchor
```

## Install

```shell
avm install <VERSION_OR_COMMIT>
```

Install the specified version of anchor-cli. The version argument should follow semver versioning. It is also possible to use `latest` as the version argument to install the latest version.

It's also possible to install based on a specific commit hash:

```shell
# <VERSION>-<COMMIT>
avm install 0.30.1-cfe82aa682138f7c6c58bf7a78f48f7d63e9e466

# Full commit hash
avm install cfe82aa682138f7c6c58bf7a78f48f7d63e9e466

# Short commit hash
avm install cfe82aa
```

## List

```shell
avm list
```

Lists available versions of anchor-cli.

```shell
0.3.0
0.4.0
0.4.1
0.4.2
0.4.3
0.4.4
0.4.5
0.5.0
0.6.0
0.7.0
0.8.0
0.9.0
0.10.0
0.11.0
0.11.1
0.12.0
0.13.0
0.13.1
0.13.2
0.14.0
0.15.0
0.16.0
0.16.1
0.16.2
0.17.0
0.18.0
0.18.2
0.19.0
0.20.0  (installed)
0.20.1  (latest, installed, current)
```

## Uninstall

```shell
avm uninstall <version>
```

## Use

```shell
avm use <version>
```

Use a specific version. This version will remain in use until you change it by calling the same command again. Similarly to `avm install`, you can also use `latest` for the version.


================================================
File: docs/src/pages/docs/contribution-guide.md
================================================
---
title: Contribution Guide
description: Anchor - Contribution Guide
---

Thank you for your interest in contributing to Anchor! All contributions are welcome no
matter how big or small. This includes (but is not limited to) filing issues,
adding documentation, fixing bugs, creating examples, and implementing features.

---

## Finding issues to work on

If you're looking to get started,
check out [good first issues](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22)
or issues where [help is wanted](https://github.com/coral-xyz/anchor/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22).
For simple documentation changes or typos, feel free to just open a pull request.

If you're considering larger changes or self motivated features, please file an issue
and engage with the maintainers in [Discord](https://discord.gg/NHHGSXAnXk).

## Choosing an issue

If you'd like to contribute, please claim an issue by commenting, forking, and
opening a pull request, even if empty. This allows the maintainers to track who
is working on what issue as to not overlap work.

## Issue Guidelines

Please follow these guidelines:

Before coding:

- choose a branch name that describes the issue you're working on
- enable [commit signing](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits)

While coding:

- Submit a draft PR asap
- Only change code directly relevant to your PR. Sometimes you might find some code that could really need some refactoring. However, if it's not relevant to your PR, do not touch it. File an issue instead. This allows the reviewer to focus on a single problem at a time.
- If you write comments, do not exceed 80 chars per line. This allows contributors who work with multiple open windows to still read the comments without horizontally scrolling.
- Write adversarial tests. For example, if you're adding a new account type, do not only write tests where the instruction succeeds. Also write tests that test whether the instruction fails, if a check inside the new type is violated.

After coding:

- If you've moved code around, build the docs with `cargo doc --open` and adjust broken links
- Adjust the cli templates if necessary
- If you made a change to anchor's periphery (avm or cli), make a PR to the `anchor-book` repo if necessary
- If you've added a new folder to the `tests` directory, add it to the [CI](./.github/workflows/tests.yaml).


================================================
File: docs/src/pages/docs/hello-world.md
================================================
---
title: Hello World
description: Anchor - Hello World
---

To initialize a new project, simply run:

```shell
anchor init <new-workspace-name>
```

This creates a new anchor workspace you can move into. The following are some of the important files in the folder:

- The `.anchor` folder: It includes the most recent program logs and a local ledger that is used for testing
- The `app` folder: An empty folder that you can use to hold your frontend if you use a monorepo
- The `programs` folder: This folder contains your programs. It can contain multiple but initially only contains a program with the same name as `<new-workspace-name>`. This program already contains a `lib.rs` file with some sample code.
- The `tests` folder: The folder that contains your E2E tests. It will already include a file that tests the sample code in the `programs/<new-workspace-name>`.
- The `migrations` folder: In this folder you can save your deploy and migration scripts for your programs.
- The `Anchor.toml` file: This file configures workspace wide settings for your programs. Initially, it configures
  - The addresses of your programs on localnet (`[programs.localnet]`)
  - A registry your program can be pushed to (`[registry]`)
  - A provider which can be used in your tests (`[provider]`)
  - Scripts that Anchor executes for you (`[scripts]`). The `test` script is run when running `anchor test`. You can run your own scripts with `anchor run <script_name>`.


================================================
File: docs/src/pages/docs/high-level-overview.md
================================================
---
title: High-level Overview
description: Anchor - High-level Overview
---

An Anchor program consists of three parts. The `program` module, the Accounts structs which are marked with `#[derive(Accounts)]`, and the `declare_id` macro. The `program` module is where you write your business logic. The Accounts structs is where you validate accounts. The`declare_id` macro creates an `ID` field that stores the address of your program. Anchor uses this hardcoded `ID` for security checks and it also allows other crates to access your program's address.

When you start up a new Anchor project, you'll see the following:

```rust
// use this import to gain access to common anchor features
use anchor_lang::prelude::*;

// declare an id for your program
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

// write your business logic here
#[program]
mod hello_anchor {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

// validate incoming accounts here
#[derive(Accounts)]
pub struct Initialize {}
```

We'll go into more detail in the next sections but for now, note that the way an endpoint is connected to its corresponding Accounts struct is the `ctx` argument in the endpoint. The argument is of type `Context` which is generic over an Accounts struct, i.e. this is where you put the name of your account validation struct. In this example, it's `Initialize`.


================================================
File: docs/src/pages/docs/important-links.md
================================================
---
title: Important Links
description: Anchor - Important Links
---

- [Accounts Reference](https://docs.rs/anchor-lang/latest/anchor_lang/accounts/index.html)
- [Constraints Reference](https://docs.rs/anchor-lang/latest/anchor_lang/derive.Accounts.html)
- [Error Codes](https://docs.rs/anchor-lang/latest/anchor_lang/error/enum.ErrorCode.html)


================================================
File: docs/src/pages/docs/javascript-anchor-types.md
================================================
---
title: Javascript Anchor Types Reference
description: Anchor - Javascript Anchor Types Reference
---

This reference shows you how Anchor maps Rust types to JavaScript/TypeScript types in the client.

---

{% table %}
* Type
* Rust
* TypeScript
* Example
---
* ## Boolean
* `bool`
* `boolean`
* ```typescript
  true
  ```
---
* ## Integer
* `u8/u16/u32/i8/i16/i32`
* `number`
* ```typescript
  99
  ```
---
* ## Big integer
* `u64/u128/i64/i128`
* `anchor.BN`
* ```typescript
  new anchor.BN(99)
  ```
---
* ## Float
* `f32/f64`
* `number`
* ```typescript
  1.0
  ```
---
* ## String
* `String`
* `string`
* ```typescript
  "hello"
  ```
---
* ## Array
* `[T; N]`
* `Array<T>`
* ```typescript
  [1, 2, 3]
  ```
---
* ## Vector
* `Vec<T>`
* `Array<T>`
* ```typescript
  [1, 2, 3]
  ```
---
* ## Option
* `Option<T>`
* `T | null | undefined`
* `None`:
  ```typescript
  null
  ```
  `Some(val)`:
  ```typescript
  42
  ```
---
* ## Struct
* `Struct`
* `object`
* ```rust
  struct MyStruct {
    val: u16,
  }
  ```
  ```typescript
  { val: 99 }
  ```
---
* ## Enum
* `Enum`
* `object`
* ```rust
  enum MyEnum {
      One,
      Two { val: u32 },
      Three(u8, i16),
  }
  ```
  Unit variant:
  ```typescript
  { one : {} }
  ```
  Named variant:
  ```typescript
  { two: { val: 99 } }
  ```
  Unnamed (tuple) variant:
  ```typescript
  { three: [12, -34] }
  ```
{% /table %}


================================================
File: docs/src/pages/docs/security-exploits.md
================================================
---
title: Sealevel Attacks
description: Anchor - Sealevel Attacks
---

Anchor uses a lot of magic to help eliminate footguns, but if you're shipping anything to mainnet,
it's important you understand every bit of that magic and the motivation behind it. A list of common
attacks can be found [here](https://github.com/coral-xyz/sealevel-attacks), providing three different
examples for each example attack

1. insecure - represents flawed code that may be insecure
2. secure - represents a fix
3. recommended - represents a fix with idiomatic Anchor code

Note that none of these examples are not necessarily secure, but they are meant to showcase a specific issue
and a recommended fix in isolation. One can find some nice explanations of these sealevel attacks
[here](https://twitter.com/pencilflip/status/1483880018858201090). It's strongly recommended to study each
of these cases when building protocols on Solana.


================================================
File: docs/src/pages/docs/the-program-module.md
================================================
---
title: The Program Module
description: Anchor - The Program Module
---

The program module is where you define your business logic. You do so by writing functions which can be called by clients or other programs. You've already seen one example of such a function, the `set_data` function from the previous section.

---

```rust
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {
        if ctx.accounts.token_account.amount > 0 {
            ctx.accounts.my_account.data = data;
        }
        Ok(())
    }
}
```

## Context

> [Context Reference](https://docs.rs/anchor-lang/latest/anchor_lang/context/index.html)

Each endpoint function takes a `Context` type as its first argument. Through this context argument it can access the accounts (`ctx.accounts`), the program id (`ctx.program_id`) of the executing program, and the remaining accounts (`ctx.remaining_accounts`). `remaining_accounts` is a vector that contains all accounts that were passed into the instruction but are not declared in the `Accounts` struct. This is useful when you want your function to handle a variable amount of accounts, e.g. when initializing a game with a variable number of players.

## Instruction Data

If your function requires instruction data, you can add it by adding arguments to the function after the context argument. Anchor will then automatically deserialize the instruction data into the arguments. You can have as many as you like. You can even pass in your own types as long as you use`#[derive(AnchorDeserialize)]` on them or implement `AnchorDeserialize` for them yourself. Here's an example with a custom type used as an instruction data arg:

```rust
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: Data) -> Result<()> {
        ctx.accounts.my_account.data = data.data;
        ctx.accounts.my_account.age = data.age;
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}

#[derive(AnchorSerialize, AnchorDeserialize, Eq, PartialEq, Clone, Copy, Debug)]
pub struct Data {
    pub data: u64,
    pub age: u8
}
```

Conveniently, `#[account]` implements `Anchor(De)Serialize` for `MyAccount`, so the example above can be simplified.

```rust
#[program]
mod hello_anchor {
    use super::*;
    pub fn set_data(ctx: Context<SetData>, data: MyAccount) -> Result<()> {
        ctx.accounts.my_account.set_inner(data);
        Ok(())
    }
}

#[account]
#[derive(Default)]
pub struct MyAccount {
    pub data: u64,
    pub age: u8
}
```


================================================
File: docs/src/pages/docs/verifiable-builds.md
================================================
---
title: Verifiable Builds
description: Anchor - Verifiable Builds
---

Building programs with the Solana CLI may embed machine specific
code into the resulting binary. As a result, building the same program
on different machines may produce different executables. To get around this
problem, one can build inside a docker image with pinned dependencies to produce
a verifiable build.

---

Anchor makes this easy by providing CLI commands to build and take care of
docker for you. To get started, first make sure you
[install](https://docs.docker.com/get-docker/) docker on your local machine.

## Building

To produce a verifiable build, run

```shell
anchor build --verifiable
```

## Verifying

To verify a build against a program deployed on mainnet, run

```shell
anchor verify -p <lib-name> <program-id>
```

where the `<lib-name>` is defined by your program's Cargo.toml.

If the program has an IDL, it will also check the IDL deployed on chain matches.

## Images

A docker image for each version of Anchor is published on [Docker Hub](https://hub.docker.com/r/backpackapp/build). They are tagged in the form `backpackapp/build:<version>`. For example, to get the image for Anchor `v0.30.1` one can run

```shell
docker pull backpackapp/build:v0.30.1
```

## Removing an Image

In the event you run a verifiable build from the CLI and exit prematurely,
it's possible the docker image may still be building in the background.

To remove, run

```shell
docker rm -f anchor-program
```

where `anchor-program` is the name of the image created by default from within
the Anchor CLI.


================================================
File: docs/src/styles/fonts.css
================================================
@font-face {
  font-family: 'Lexend';
  font-style: normal;
  font-weight: 100 900;
  font-display: swap;
  src: url(/fonts/lexend.woff2) format('woff2');
}
@font-face {
  font-family: 'Inter';
  font-weight: 100 900;
  font-display: block;
  font-style: normal;
  font-named-instance: 'Regular';
  src: url('/fonts/Inter-roman.var.woff2') format('woff2');
}
@font-face {
  font-family: 'Inter';
  font-weight: 100 900;
  font-display: block;
  font-style: italic;
  font-named-instance: 'Italic';
  src: url('/fonts/Inter-italic.var.woff2') format('woff2');
}


================================================
File: docs/src/styles/prism.css
================================================
pre[class*='language-'] {
  color: theme('colors.slate.50');
}

.token.tag,
.token.class-name,
.token.selector,
.token.selector .class,
.token.selector.class,
.token.function {
  color: theme('colors.pink.400');
}

.token.attr-name,
.token.keyword,
.token.rule,
.token.pseudo-class,
.token.important {
  color: theme('colors.slate.300');
}

.token.module {
  color: theme('colors.pink.400');
}

.token.attr-value,
.token.class,
.token.string,
.token.property {
  color: theme('colors.sky.300');
}

.token.punctuation,
.token.attr-equals {
  color: theme('colors.slate.500');
}

.token.unit,
.language-css .token.function {
  color: theme('colors.teal.200');
}

.token.comment,
.token.operator,
.token.combinator {
  color: theme('colors.slate.400');
}


================================================
File: docs/src/styles/tailwind.css
================================================
@import 'tailwindcss/base';
@import './fonts.css';
@import './docsearch.css';
@import './prism.css';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';


================================================
File: examples/yarn.lock
================================================
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1




================================================
File: examples/tutorial/package.json
================================================
{
  "name": "anchor-examples",
  "private": true,
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "workspaces": [
    "basic-0",
    "basic-1",
    "basic-2",
    "basic-3",
    "basic-4",
    "basic-5"
  ],
  "devDependencies": {
    "mocha": "^9.2.2",
    "prettier": "^2.5.1",
    "@types/mocha": "^9.1.1",
    "ts-mocha": "^10.0.0",
    "typescript": "^4.9.5"
  }
}


================================================
File: examples/tutorial/basic-0/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_0 = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: examples/tutorial/basic-0/Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
  "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-0/client.js
================================================
// client.js is used to introduce the reader to generating clients from IDLs.
// It is not expected users directly test with this example. For a more
// ergonomic example, see `tests/basic-0.js` in this workspace.

const anchor = require("@coral-xyz/anchor");

// Configure the local cluster.
anchor.setProvider(anchor.AnchorProvider.local());

async function main() {
  // #region main
  // Read the generated IDL.
  const idl = require("./target/idl/basic_0.json");

  // Generate the program client from IDL.
  const program = new anchor.Program(idl);

  // Execute the RPC.
  await program.rpc.initialize();
  // #endregion main
}

console.log("Running client.");
main().then(() => console.log("Success"));


================================================
File: examples/tutorial/basic-0/package.json
================================================
{
  "name": "basic-0",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-0/programs/basic-0/Cargo.toml
================================================
[package]
name = "basic-0"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "basic_0"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }


================================================
File: examples/tutorial/basic-0/programs/basic-0/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-0/programs/basic-0/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod basic_0 {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: examples/tutorial/basic-0/tests/basic-0.js
================================================
const anchor = require("@coral-xyz/anchor");

describe("basic-0", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.local());

  it("Uses the workspace to invoke the initialize instruction", async () => {
    // #region code
    // Read the deployed program from the workspace.
    const program = anchor.workspace.Basic0;

    // Execute the RPC.
    await program.methods.initialize().rpc();
    // #endregion code
  });
});


================================================
File: examples/tutorial/basic-1/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_1 = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: examples/tutorial/basic-1/Cargo.toml
================================================
[workspace]
resolver = "2"

members = [
  "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-1/package.json
================================================
{
  "name": "basic-1",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-1/programs/basic-1/Cargo.toml
================================================
[package]
name = "basic-1"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "basic_1"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }


================================================
File: examples/tutorial/basic-1/programs/basic-1/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-1/programs/basic-1/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod basic_1 {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }

    pub fn update(ctx: Context<Update>, data: u64) -> Result<()> {
        let my_account = &mut ctx.accounts.my_account;
        my_account.data = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    pub my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    pub data: u64,
}


================================================
File: examples/tutorial/basic-1/tests/basic-1.js
================================================
const assert = require("assert");
const anchor = require("@coral-xyz/anchor");
const { SystemProgram } = anchor.web3;

describe("basic-1", () => {
  // Use a local provider.
  const provider = anchor.AnchorProvider.local();

  // Configure the client to use the local cluster.
  anchor.setProvider(provider);

  it("Creates and initializes an account in a single atomic transaction (simplified)", async () => {
    // #region code-simplified
    // The program to execute.
    const program = anchor.workspace.Basic1;

    // The Account to create.
    const myAccount = anchor.web3.Keypair.generate();

    // Create the new account and initialize it with the program.
    // #region code-simplified
    await program.methods
      .initialize(new anchor.BN(1234))
      .accounts({
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([myAccount])
      .rpc();
    // #endregion code-simplified

    // Fetch the newly created account from the cluster.
    const account = await program.account.myAccount.fetch(myAccount.publicKey);

    // Check it's state was initialized.
    assert.ok(account.data.eq(new anchor.BN(1234)));

    // Store the account for the next test.
    _myAccount = myAccount;
  });

  it("Updates a previously created account", async () => {
    const myAccount = _myAccount;

    // #region update-test

    // The program to execute.
    const program = anchor.workspace.Basic1;

    // Invoke the update rpc.
    await program.methods
      .update(new anchor.BN(4321))
      .accounts({
        myAccount: myAccount.publicKey,
      })
      .rpc();

    // Fetch the newly updated account.
    const account = await program.account.myAccount.fetch(myAccount.publicKey);

    // Check it's state was mutated.
    assert.ok(account.data.eq(new anchor.BN(4321)));

    // #endregion update-test
  });
});


================================================
File: examples/tutorial/basic-2/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_2 = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: examples/tutorial/basic-2/Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
  "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-2/package.json
================================================
{
  "name": "basic-2",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-2/programs/basic-2/Cargo.toml
================================================
[package]
name = "basic-2"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "basic_2"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }


================================================
File: examples/tutorial/basic-2/programs/basic-2/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-2/programs/basic-2/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod basic_2 {
    use super::*;

    pub fn create(ctx: Context<Create>, authority: Pubkey) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.authority = authority;
        counter.count = 0;
        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        let counter = &mut ctx.accounts.counter;
        counter.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = user, space = 8 + 40)]
    pub counter: Account<'info, Counter>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut, has_one = authority)]
    pub counter: Account<'info, Counter>,
    pub authority: Signer<'info>,
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
}


================================================
File: examples/tutorial/basic-2/tests/basic-2.js
================================================
const assert = require("assert");
const anchor = require("@coral-xyz/anchor");
const { SystemProgram } = anchor.web3;

describe("basic-2", () => {
  const provider = anchor.AnchorProvider.local();

  // Configure the client to use the local cluster.
  anchor.setProvider(provider);

  // Counter for the tests.
  const counter = anchor.web3.Keypair.generate();

  // Program for the tests.
  const program = anchor.workspace.Basic2;

  it("Creates a counter", async () => {
    await program.methods
      .create(provider.wallet.publicKey)
      .accounts({
        counter: counter.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([counter])
      .rpc();

    let counterAccount = await program.account.counter.fetch(counter.publicKey);

    assert.ok(counterAccount.authority.equals(provider.wallet.publicKey));
    assert.ok(counterAccount.count.toNumber() === 0);
  });

  it("Updates a counter", async () => {
    await program.methods
      .increment()
      .accounts({
        counter: counter.publicKey,
        authority: provider.wallet.publicKey,
      })
      .rpc();

    const counterAccount = await program.account.counter.fetch(
      counter.publicKey
    );

    assert.ok(counterAccount.authority.equals(provider.wallet.publicKey));
    assert.ok(counterAccount.count.toNumber() == 1);
  });
});


================================================
File: examples/tutorial/basic-3/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
puppet = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
puppet_master = "HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: examples/tutorial/basic-3/Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
    "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-3/package.json
================================================
{
  "name": "basic-3",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-3/programs/puppet/Cargo.toml
================================================
[package]
name = "puppet"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "puppet"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }


================================================
File: examples/tutorial/basic-3/programs/puppet/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-3/programs/puppet/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod puppet {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn set_data(ctx: Context<SetData>, data: u64) -> Result<()> {
        let puppet = &mut ctx.accounts.puppet;
        puppet.data = data;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub puppet: Account<'info, Data>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SetData<'info> {
    #[account(mut)]
    pub puppet: Account<'info, Data>,
}

#[account]
pub struct Data {
    pub data: u64,
}


================================================
File: examples/tutorial/basic-3/programs/puppet-master/Cargo.toml
================================================
[package]
name = "puppet-master"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "puppet_master"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }
puppet = { path = "../puppet", features = ["cpi"] }


================================================
File: examples/tutorial/basic-3/programs/puppet-master/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-3/programs/puppet-master/src/lib.rs
================================================
// #region core
use anchor_lang::prelude::*;
use puppet::cpi::accounts::SetData;
use puppet::program::Puppet;
use puppet::{self, Data};

declare_id!("HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L");

#[program]
mod puppet_master {
    use super::*;
    pub fn pull_strings(ctx: Context<PullStrings>, data: u64) -> anchor_lang::Result<()> {
        let cpi_program = ctx.accounts.puppet_program.to_account_info();
        let cpi_accounts = SetData {
            puppet: ctx.accounts.puppet.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        puppet::cpi::set_data(cpi_ctx, data)
    }
}

#[derive(Accounts)]
pub struct PullStrings<'info> {
    #[account(mut)]
    pub puppet: Account<'info, Data>,
    pub puppet_program: Program<'info, Puppet>,
}
// #endregion core


================================================
File: examples/tutorial/basic-3/tests/basic-3.js
================================================
const assert = require("assert");
const anchor = require("@coral-xyz/anchor");
const { SystemProgram } = anchor.web3;

describe("basic-3", () => {
  const provider = anchor.AnchorProvider.local();

  // Configure the client to use the local cluster.
  anchor.setProvider(provider);

  it("Performs CPI from puppet master to puppet", async () => {
    const puppetMaster = anchor.workspace.PuppetMaster;
    const puppet = anchor.workspace.Puppet;

    // Initialize a new puppet account.
    const newPuppetAccount = anchor.web3.Keypair.generate();
    const tx = await puppet.methods
      .initialize()
      .accounts({
        puppet: newPuppetAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([newPuppetAccount])
      .rpc();

    // Invoke the puppet master to perform a CPI to the puppet.
    await puppetMaster.methods
      .pullStrings(new anchor.BN(111))
      .accounts({
        puppet: newPuppetAccount.publicKey,
        puppetProgram: puppet.programId,
      })
      .rpc();

    // Check the state updated.
    puppetAccount = await puppet.account.data.fetch(newPuppetAccount.publicKey);
    assert.ok(puppetAccount.data.eq(new anchor.BN(111)));
  });
});


================================================
File: examples/tutorial/basic-4/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_4 = "CwrqeMj2U8tFr1Rhkgwc84tpAsqbt9pTt2a4taoTADPr"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: examples/tutorial/basic-4/Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
    "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-4/package.json
================================================
{
  "name": "basic-4",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-4/programs/basic-4/Cargo.toml
================================================
[package]
name = "basic-4"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "basic_4"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }


================================================
File: examples/tutorial/basic-4/programs/basic-4/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: examples/tutorial/basic-4/programs/basic-4/src/lib.rs
================================================
use anchor_lang::prelude::*;
use std::ops::DerefMut;

declare_id!("CwrqeMj2U8tFr1Rhkgwc84tpAsqbt9pTt2a4taoTADPr");

#[program]
pub mod basic_4 {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let counter = ctx.accounts.counter.deref_mut();
        let bump = ctx.bumps.counter;

        *counter = Counter {
            authority: *ctx.accounts.authority.key,
            count: 0,
            bump,
        };

        Ok(())
    }

    pub fn increment(ctx: Context<Increment>) -> Result<()> {
        require_keys_eq!(
            ctx.accounts.authority.key(),
            ctx.accounts.counter.authority,
            ErrorCode::Unauthorized
        );

        ctx.accounts.counter.count += 1;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        space = Counter::SIZE,
        seeds = [b"counter"],
        bump
    )]
    counter: Account<'info, Counter>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(
        mut,
        seeds = [b"counter"],
        bump = counter.bump
    )]
    counter: Account<'info, Counter>,
    authority: Signer<'info>,
}

#[account]
pub struct Counter {
    pub authority: Pubkey,
    pub count: u64,
    pub bump: u8,
}

impl Counter {
    pub const SIZE: usize = 8 + 32 + 8 + 1;
}

#[error_code]
pub enum ErrorCode {
    #[msg("You are not authorized to perform this action.")]
    Unauthorized,
}


================================================
File: examples/tutorial/basic-4/tests/basic-4.js
================================================
const assert = require("assert");
const anchor = require("@coral-xyz/anchor");

describe("basic-4", () => {
  const provider = anchor.AnchorProvider.local();

  // Configure the client to use the local cluster.
  anchor.setProvider(provider);

  const program = anchor.workspace.Basic4,
    counterSeed = anchor.utils.bytes.utf8.encode("counter");

  let counterPubkey;

  before(async () => {
    [counterPubkey] = await anchor.web3.PublicKey.findProgramAddress(
      [counterSeed],
      program.programId
    );
  });

  it("Is runs the constructor", async () => {
    // Initialize the program's state struct.
    await program.methods
      .initialize()
      .accounts({
        counter: counterPubkey,
        authority: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

    // Fetch the state struct from the network.
    const counterAccount = await program.account.counter.fetch(counterPubkey);

    assert.ok(counterAccount.count.eq(new anchor.BN(0)));
  });

  it("Executes a method on the program", async () => {
    await program.methods
      .increment()
      .accounts({
        counter: counterPubkey,
        authority: provider.wallet.publicKey,
      })
      .rpc();

    const counterAccount = await program.account.counter.fetch(counterPubkey);
    assert.ok(counterAccount.count.eq(new anchor.BN(1)));
  });
});


================================================
File: examples/tutorial/basic-5/README.md
================================================
# basic-5

This is a robot program developed as a Rust Smart Contract(running on Solana Blockchain).
It simplifies actions of a robot on-chain. 
This program acts as an example for developers who are new to Solana ecosystem to learn on how the typescript client interacts with the program on-chain. 

Instructions of the program:

1. Create
2. Walk
3. Run
4. Jump
5. Reset

================================================
File: examples/tutorial/basic-5/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
basic_5 = "DuT6R8tQGYa8ACYXyudFJtxDppSALLcmK39b7918jeSC"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

================================================
File: examples/tutorial/basic-5/Cargo.toml
================================================
[workspace]
resolver = "2"
members = [
    "programs/*"
]

[profile.release]
overflow-checks = true


================================================
File: examples/tutorial/basic-5/package.json
================================================
{
  "name": "basic-5",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint && anchor clean"
  }
}


================================================
File: examples/tutorial/basic-5/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: examples/tutorial/basic-5/programs/basic-5/Cargo.toml
================================================
[package]
name = "basic-5"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "basic_5"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }

================================================
File: examples/tutorial/basic-5/programs/basic-5/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: idl/Cargo.toml
================================================
[package]
name = "anchor-lang-idl"
version = "0.1.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
edition = "2021"
license = "Apache-2.0"
description = "Anchor framework IDL"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
build = ["regex"]
convert = ["heck", "sha2"]

[dependencies]
anchor-lang-idl-spec = { path = "./spec", version = "0.1.0" }
anyhow = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# `build` feature only
regex = { version = "1", optional = true }

# `convert` feature only
heck = { version = "0.3", optional = true }
sha2 = { version = "0.10", optional = true }


================================================
File: idl/spec/Cargo.toml
================================================
[package]
name = "anchor-lang-idl-spec"
version = "0.1.0"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
edition = "2021"
license = "Apache-2.0"
description = "Anchor framework IDL spec"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[dependencies]
anyhow = "1"
serde = { version = "1", features = ["derive"] }


================================================
File: idl/src/lib.rs
================================================
//! Anchor IDL.

#[cfg(feature = "build")]
pub mod build;

#[cfg(feature = "convert")]
pub mod convert;

pub use anchor_lang_idl_spec as types;

#[cfg(feature = "build")]
pub use serde_json;


================================================
File: lang/Cargo.toml
================================================
[package]
name = "anchor-lang"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
edition = "2021"
license = "Apache-2.0"
description = "Solana Sealevel eDSL"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
allow-missing-optionals = ["anchor-derive-accounts/allow-missing-optionals"]
anchor-debug = [
    "anchor-attribute-access-control/anchor-debug",
    "anchor-attribute-account/anchor-debug",
    "anchor-attribute-constant/anchor-debug",
    "anchor-attribute-error/anchor-debug",
    "anchor-attribute-event/anchor-debug",
    "anchor-attribute-program/anchor-debug",
    "anchor-derive-accounts/anchor-debug"
]
derive = []
event-cpi = ["anchor-attribute-event/event-cpi"]
idl-build = [
    "anchor-attribute-account/idl-build",
    "anchor-attribute-constant/idl-build",
    "anchor-attribute-event/idl-build",
    "anchor-attribute-error/idl-build",
    "anchor-attribute-program/idl-build",
    "anchor-derive-accounts/idl-build",
    "anchor-derive-serde/idl-build",
    "anchor-lang-idl/build",
]
init-if-needed = ["anchor-derive-accounts/init-if-needed"]
interface-instructions = ["anchor-attribute-program/interface-instructions"]
lazy-account = ["anchor-attribute-account/lazy-account", "anchor-derive-serde/lazy-account"]

[dependencies]
anchor-attribute-access-control = { path = "./attribute/access-control", version = "0.30.1" }
anchor-attribute-account = { path = "./attribute/account", version = "0.30.1" }
anchor-attribute-constant = { path = "./attribute/constant", version = "0.30.1" }
anchor-attribute-error = { path = "./attribute/error", version = "0.30.1" }
anchor-attribute-event = { path = "./attribute/event", version = "0.30.1" }
anchor-attribute-program = { path = "./attribute/program", version = "0.30.1" }
anchor-derive-accounts = { path = "./derive/accounts", version = "0.30.1" }
anchor-derive-serde = { path = "./derive/serde", version = "0.30.1" }
anchor-derive-space = { path = "./derive/space", version = "0.30.1" }

# `anchor-lang-idl` should only be included with `idl-build` feature
anchor-lang-idl = { path = "../idl", version = "0.1.1", optional = true }

base64 = "0.21"
bincode = "1"
borsh = "0.10.3"
bytemuck = "1"
solana-program = "2"
thiserror = "1"


================================================
File: lang/attribute/access-control/Cargo.toml
================================================
[package]
name = "anchor-attribute-access-control"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for instruction access control"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1" }
proc-macro2 = "1"
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/access-control/src/lib.rs
================================================
extern crate proc_macro;

use quote::quote;
use syn::parse_macro_input;

/// Executes the given access control method before running the decorated
/// instruction handler. Any method in scope of the attribute can be invoked
/// with any arguments from the associated instruction handler.
///
/// # Example
///
/// ```ignore
/// use anchor_lang::prelude::*;
///
/// #[program]
/// mod errors {
///     use super::*;
///
///     #[access_control(Create::accounts(&ctx, bump_seed))]
///     pub fn create(ctx: Context<Create>, bump_seed: u8) -> Result<()> {
///       let my_account = &mut ctx.accounts.my_account;
///       my_account.bump_seed = bump_seed;
///     }
/// }
///
/// #[derive(Accounts)]
/// pub struct Create {
///   #[account(init)]
///   my_account: Account<'info, MyAccount>,
/// }
///
/// impl Create {
///   pub fn accounts(ctx: &Context<Create>, bump_seed: u8) -> Result<()> {
///     let seeds = &[ctx.accounts.my_account.to_account_info().key.as_ref(), &[bump_seed]];
///     Pubkey::create_program_address(seeds, ctx.program_id)
///       .map_err(|_| ErrorCode::InvalidNonce)?;
///     Ok(())
///   }
/// }
/// ```
///
/// This example demonstrates a useful pattern. Not only can you use
/// `#[access_control]` to ensure any invariants or preconditions hold prior to
/// executing an instruction, but also it can be used to finish any validation
/// on the `Accounts` struct, particularly when instruction arguments are
/// needed. Here, we use the given `bump_seed` to verify it creates a valid
/// program-derived address.
#[proc_macro_attribute]
pub fn access_control(
    args: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    let mut args = args.to_string();
    args.retain(|c| !c.is_whitespace());
    let access_control: Vec<proc_macro2::TokenStream> = args
        .split(')')
        .filter(|ac| !ac.is_empty())
        .map(|ac| format!("{ac})")) // Put back on the split char.
        .map(|ac| format!("{ac}?;")) // Add `?;` syntax.
        .map(|ac| ac.parse().unwrap())
        .collect();

    let item_fn = parse_macro_input!(input as syn::ItemFn);

    let fn_attrs = item_fn.attrs;
    let fn_vis = item_fn.vis;
    let fn_sig = item_fn.sig;
    let fn_block = item_fn.block;

    let fn_stmts = fn_block.stmts;

    proc_macro::TokenStream::from(quote! {
        #(#fn_attrs)*
        #fn_vis #fn_sig {

            #(#access_control)*

            #(#fn_stmts)*
        }
    })
}


================================================
File: lang/attribute/account/Cargo.toml
================================================
[package]
name = "anchor-attribute-account"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for defining an account"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]
idl-build = ["anchor-syn/idl-build"]
lazy-account = []

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1", features = ["hash"] }
bs58 = "0.5"
proc-macro2 = "1"
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/constant/Cargo.toml
================================================
[package]
name = "anchor-attribute-constant"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for creating constant types"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]
idl-build = ["anchor-syn/idl-build"]

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1" }
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/constant/src/lib.rs
================================================
extern crate proc_macro;

/// A marker attribute used to mark const values that should be included in the
/// generated IDL but functionally does nothing.
#[proc_macro_attribute]
pub fn constant(
    _attr: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    #[cfg(feature = "idl-build")]
    {
        use quote::quote;

        let ts = match syn::parse(input).unwrap() {
            syn::Item::Const(item) => {
                let idl_print = anchor_syn::idl::gen_idl_print_fn_constant(&item);
                quote! {
                    #item
                    #idl_print
                }
            }
            item => quote! {#item},
        };

        return proc_macro::TokenStream::from(quote! {
            #ts
        });
    };

    #[allow(unreachable_code)]
    input
}


================================================
File: lang/attribute/error/Cargo.toml
================================================
[package]
name = "anchor-attribute-error"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for creating error types"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]
idl-build = ["anchor-syn/idl-build"]

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1" }
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/event/Cargo.toml
================================================
[package]
name = "anchor-attribute-event"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for defining an event"
rust-version = "1.60"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]
event-cpi = ["anchor-syn/event-cpi"]
idl-build = ["anchor-syn/idl-build"]

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1", features = ["hash"] }
proc-macro2 = "1"
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/program/Cargo.toml
================================================
[package]
name = "anchor-attribute-program"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor attribute macro for defining a program"
edition = "2021"

[lib]
proc-macro = true

[features]
anchor-debug = ["anchor-syn/anchor-debug"]
idl-build = ["anchor-syn/idl-build"]
interface-instructions = ["anchor-syn/interface-instructions"]

[dependencies]
anchor-lang-idl = { path = "../../../idl", version = "0.1.1", features = ["convert"] }
anchor-syn = { path = "../../syn", version = "0.30.1" }
anyhow = "1"
bs58 = "0.5"
heck = "0.3"
proc-macro2 = "1"
quote = "1"
serde_json = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/attribute/program/src/declare_program/mods/client.rs
================================================
use anchor_lang_idl::types::Idl;
use quote::quote;

use super::common::gen_accounts_common;

pub fn gen_client_mod(idl: &Idl) -> proc_macro2::TokenStream {
    let client_args_mod = gen_client_args_mod();
    let client_accounts_mod = gen_client_accounts_mod(idl);

    quote! {
        /// Off-chain client helpers.
        pub mod client {
            use super::*;

            #client_args_mod
            #client_accounts_mod
        }
    }
}

fn gen_client_args_mod() -> proc_macro2::TokenStream {
    quote! {
        /// Client args.
        pub mod args {
            pub use super::internal::args::*;
        }
    }
}

fn gen_client_accounts_mod(idl: &Idl) -> proc_macro2::TokenStream {
    gen_accounts_common(idl, "client")
}


================================================
File: lang/attribute/program/src/declare_program/mods/constants.rs
================================================
use anchor_lang_idl::types::{Idl, IdlType};
use quote::{format_ident, quote, ToTokens};

use super::common::{convert_idl_type_to_syn_type, gen_docs};

pub fn gen_constants_mod(idl: &Idl) -> proc_macro2::TokenStream {
    let constants = idl.constants.iter().map(|c| {
        let name = format_ident!("{}", c.name);
        let docs = gen_docs(&c.docs);
        let val = syn::parse_str::<syn::Expr>(&c.value)
            .unwrap()
            .to_token_stream();
        let (ty, val) = match &c.ty {
            IdlType::Bytes => (quote!(&[u8]), quote! { &#val }),
            IdlType::String => (quote!(&str), val),
            _ => (convert_idl_type_to_syn_type(&c.ty).to_token_stream(), val),
        };

        quote! {
            #docs
            pub const #name: #ty = #val;
        }
    });

    quote! {
        /// Program constants.
        pub mod constants {
            #(#constants)*
        }
    }
}


================================================
File: lang/attribute/program/src/declare_program/mods/events.rs
================================================
use anchor_lang_idl::types::Idl;
use quote::{format_ident, quote};

use super::common::{convert_idl_type_def_to_ts, gen_discriminator};

pub fn gen_events_mod(idl: &Idl) -> proc_macro2::TokenStream {
    let events = idl.events.iter().map(|ev| {
        let name = format_ident!("{}", ev.name);
        let discriminator = gen_discriminator(&ev.discriminator);

        let ty_def = idl
            .types
            .iter()
            .find(|ty| ty.name == ev.name)
            .map(|ty| convert_idl_type_def_to_ts(ty, &idl.types))
            .expect("Type must exist");

        quote! {
            #ty_def

            impl anchor_lang::Event for #name {
                fn data(&self) -> Vec<u8> {
                    let mut data = Vec::with_capacity(256);
                    data.extend_from_slice(&#discriminator);
                    self.serialize(&mut data).unwrap();
                    data
                }
            }

            impl anchor_lang::Discriminator for #name {
                const DISCRIMINATOR: &'static [u8] = &#discriminator;
            }
        }
    });

    quote! {
        /// Program event type definitions.
        pub mod events {
            use super::*;

            #(#events)*
        }
    }
}


================================================
File: lang/attribute/program/src/declare_program/mods/mod.rs
================================================
pub mod accounts;
pub mod client;
pub mod constants;
pub mod cpi;
pub mod events;
pub mod internal;
pub mod program;
pub mod types;
pub mod utils;

use super::common;


================================================
File: lang/attribute/program/src/declare_program/mods/program.rs
================================================
use heck::CamelCase;
use quote::{format_ident, quote};

use super::common::get_canonical_program_id;

pub fn gen_program_mod(program_name: &str) -> proc_macro2::TokenStream {
    let name = format_ident!("{}", program_name.to_camel_case());
    let id = get_canonical_program_id();
    quote! {
        /// Program definition.
        pub mod program {
            use super::*;

            /// Program type
            #[derive(Clone)]
            pub struct #name;

            impl anchor_lang::Id for #name {
                fn id() -> Pubkey {
                    #id
                }
            }
        }
    }
}


================================================
File: lang/attribute/program/src/declare_program/mods/types.rs
================================================
use anchor_lang_idl::types::Idl;
use quote::quote;

use super::common::convert_idl_type_def_to_ts;

pub fn gen_types_mod(idl: &Idl) -> proc_macro2::TokenStream {
    let types = idl
        .types
        .iter()
        .filter(|ty| {
            // Skip accounts and events
            !(idl.accounts.iter().any(|acc| acc.name == ty.name)
                || idl.events.iter().any(|ev| ev.name == ty.name))
        })
        .map(|ty| convert_idl_type_def_to_ts(ty, &idl.types));

    quote! {
        /// Program type definitions.
        ///
        /// Note that account and event type definitions are not included in this module, as they
        /// have their own dedicated modules.
        pub mod types {
            use super::*;

            #(#types)*
        }
    }
}


================================================
File: lang/derive/accounts/Cargo.toml
================================================
[package]
name = "anchor-derive-accounts"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor Derive macro for accounts"
edition = "2021"

[lib]
proc-macro = true

[features]
allow-missing-optionals = ["anchor-syn/allow-missing-optionals"]
anchor-debug = ["anchor-syn/anchor-debug"]
idl-build = ["anchor-syn/idl-build"]
init-if-needed = ["anchor-syn/init-if-needed"]

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1" }
quote = "1"
syn = { version = "1", features = ["full"] }


================================================
File: lang/derive/serde/Cargo.toml
================================================
[package]
name = "anchor-derive-serde"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor Derive macro for serialization and deserialization"
edition = "2021"

[lib]
proc-macro = true

[features]
idl-build = ["anchor-syn/idl-build"]
lazy-account = []

[dependencies]
anchor-syn = { path = "../../syn", version = "0.30.1" }
borsh-derive-internal = "0.10.3"
proc-macro2 = "1"
syn = { version = "1", features = ["full"] }
quote = "1"


================================================
File: lang/derive/serde/src/lazy.rs
================================================
use proc_macro2::Literal;
use quote::{format_ident, quote};
use syn::{spanned::Spanned, Fields, Item};

pub fn gen_lazy(input: proc_macro::TokenStream) -> syn::Result<proc_macro2::TokenStream> {
    let item = syn::parse::<Item>(input)?;
    let (name, generics, size, sized) = match &item {
        Item::Struct(strct) => (
            &strct.ident,
            &strct.generics,
            sum_fields(&strct.fields),
            strct
                .fields
                .iter()
                .map(|field| &field.ty)
                .map(|ty| quote! { <#ty as anchor_lang::__private::Lazy>::SIZED })
                .fold(quote!(true), |acc, sized| quote! { #acc && #sized }),
        ),
        Item::Enum(enm) => {
            let arms = enm
                .variants
                .iter()
                .map(|variant| sum_fields(&variant.fields))
                .enumerate()
                .map(|(i, size)| (Literal::usize_unsuffixed(i), size))
                .map(|(i, size)| quote! { Some(#i) => { #size } });

            (
                &enm.ident,
                &enm.generics,
                quote! {
                    1 + match buf.first() {
                        #(#arms,)*
                        _ => unreachable!(),
                    }
                },
                quote!(false),
            )
        }
        Item::Union(_) => return Err(syn::Error::new(item.span(), "Unions are not supported")),
        _ => unreachable!(),
    };

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    Ok(quote! {
        impl #impl_generics anchor_lang::__private::Lazy for #name #ty_generics #where_clause {
            const SIZED: bool = #sized;

            #[inline(always)]
            fn size_of(buf: &[u8]) -> usize {
                #size
            }
        }
    })
}

fn sum_fields(fields: &Fields) -> proc_macro2::TokenStream {
    let names = fields
        .iter()
        .enumerate()
        .map(|(i, _)| format_ident!("s{i}"))
        .collect::<Vec<_>>();
    let declarations = fields.iter().enumerate().map(|(i, field)| {
        let ty = &field.ty;
        let name = &names[i];
        let sum = &names[..i];
        let buf = quote! { &buf[0 #(+ #sum)*..] };
        quote! { let #name = <#ty as anchor_lang::__private::Lazy>::size_of(#buf) }
    });

    quote! {
       #(#declarations;)*
       0 #(+ #names)*
    }
}


================================================
File: lang/derive/serde/src/lib.rs
================================================
extern crate proc_macro;

#[cfg(feature = "lazy-account")]
mod lazy;

use borsh_derive_internal::*;
use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use syn::{Ident, Item};

fn gen_borsh_serialize(input: TokenStream) -> TokenStream2 {
    let cratename = Ident::new("borsh", Span::call_site());

    let item: Item = syn::parse(input).unwrap();
    let res = match item {
        Item::Struct(item) => struct_ser(&item, cratename),
        Item::Enum(item) => enum_ser(&item, cratename),
        Item::Union(item) => union_ser(&item, cratename),
        // Derive macros can only be defined on structs, enums, and unions.
        _ => unreachable!(),
    };

    match res {
        Ok(res) => res,
        Err(err) => err.to_compile_error(),
    }
}

#[proc_macro_derive(AnchorSerialize, attributes(borsh_skip))]
pub fn anchor_serialize(input: TokenStream) -> TokenStream {
    #[cfg(not(feature = "idl-build"))]
    let ret = gen_borsh_serialize(input);
    #[cfg(feature = "idl-build")]
    let ret = gen_borsh_serialize(input.clone());

    #[cfg(feature = "idl-build")]
    {
        use anchor_syn::idl::*;
        use quote::quote;

        let idl_build_impl = match syn::parse(input).unwrap() {
            Item::Struct(item) => impl_idl_build_struct(&item),
            Item::Enum(item) => impl_idl_build_enum(&item),
            Item::Union(item) => impl_idl_build_union(&item),
            // Derive macros can only be defined on structs, enums, and unions.
            _ => unreachable!(),
        };

        return TokenStream::from(quote! {
            #ret
            #idl_build_impl
        });
    };

    #[allow(unreachable_code)]
    TokenStream::from(ret)
}

fn gen_borsh_deserialize(input: TokenStream) -> TokenStream2 {
    let cratename = Ident::new("borsh", Span::call_site());

    let item: Item = syn::parse(input).unwrap();
    let res = match item {
        Item::Struct(item) => struct_de(&item, cratename),
        Item::Enum(item) => enum_de(&item, cratename),
        Item::Union(item) => union_de(&item, cratename),
        // Derive macros can only be defined on structs, enums, and unions.
        _ => unreachable!(),
    };

    match res {
        Ok(res) => res,
        Err(err) => err.to_compile_error(),
    }
}

#[proc_macro_derive(AnchorDeserialize, attributes(borsh_skip, borsh_init))]
pub fn borsh_deserialize(input: TokenStream) -> TokenStream {
    #[cfg(feature = "lazy-account")]
    {
        let deser = gen_borsh_deserialize(input.clone());
        let lazy = lazy::gen_lazy(input).unwrap_or_else(|e| e.to_compile_error());
        quote::quote! {
            #deser
            #lazy
        }
        .into()
    }
    #[cfg(not(feature = "lazy-account"))]
    gen_borsh_deserialize(input).into()
}

#[cfg(feature = "lazy-account")]
#[proc_macro_derive(Lazy)]
pub fn lazy(input: TokenStream) -> TokenStream {
    lazy::gen_lazy(input)
        .unwrap_or_else(|e| e.to_compile_error())
        .into()
}


================================================
File: lang/derive/space/Cargo.toml
================================================
[package]
name = "anchor-derive-space"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor Derive macro to automatically calculate the size of a structure or an enum"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1"
quote = "1"
syn = { version = "1", features = ["extra-traits"] }


================================================
File: lang/src/account_meta.rs
================================================
use crate::ToAccountMetas;
use solana_program::instruction::AccountMeta;

impl ToAccountMetas for AccountMeta {
    fn to_account_metas(&self, _is_signer: Option<bool>) -> Vec<AccountMeta> {
        vec![self.clone()]
    }
}


================================================
File: lang/src/bpf_upgradeable_state.rs
================================================
use crate::error::ErrorCode;
use crate::{AccountDeserialize, AccountSerialize, Owner, Result};
use solana_program::{
    bpf_loader_upgradeable::UpgradeableLoaderState, program_error::ProgramError, pubkey::Pubkey,
};

#[derive(Clone)]
pub struct ProgramData {
    pub slot: u64,
    pub upgrade_authority_address: Option<Pubkey>,
}

impl AccountDeserialize for ProgramData {
    fn try_deserialize(buf: &mut &[u8]) -> Result<Self> {
        ProgramData::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
        let program_state = AccountDeserialize::try_deserialize_unchecked(buf)?;

        match program_state {
            UpgradeableLoaderState::Uninitialized => Err(ErrorCode::AccountNotProgramData.into()),
            UpgradeableLoaderState::Buffer {
                authority_address: _,
            } => Err(ErrorCode::AccountNotProgramData.into()),
            UpgradeableLoaderState::Program {
                programdata_address: _,
            } => Err(ErrorCode::AccountNotProgramData.into()),
            UpgradeableLoaderState::ProgramData {
                slot,
                upgrade_authority_address,
            } => Ok(ProgramData {
                slot,
                upgrade_authority_address,
            }),
        }
    }
}

impl AccountSerialize for ProgramData {
    fn try_serialize<W: std::io::Write>(&self, _writer: &mut W) -> Result<()> {
        // no-op
        Ok(())
    }
}

impl Owner for ProgramData {
    fn owner() -> solana_program::pubkey::Pubkey {
        anchor_lang::solana_program::bpf_loader_upgradeable::ID
    }
}

impl Owner for UpgradeableLoaderState {
    fn owner() -> Pubkey {
        anchor_lang::solana_program::bpf_loader_upgradeable::ID
    }
}

impl AccountSerialize for UpgradeableLoaderState {
    fn try_serialize<W: std::io::Write>(&self, _writer: &mut W) -> Result<()> {
        // no-op
        Ok(())
    }
}

impl AccountDeserialize for UpgradeableLoaderState {
    fn try_deserialize(buf: &mut &[u8]) -> Result<Self> {
        UpgradeableLoaderState::try_deserialize_unchecked(buf)
    }

    fn try_deserialize_unchecked(buf: &mut &[u8]) -> Result<Self> {
        bincode::deserialize(buf).map_err(|_| ProgramError::InvalidAccountData.into())
    }
}

#[cfg(feature = "idl-build")]
mod idl_build {
    use super::*;

    impl crate::IdlBuild for ProgramData {}
    impl crate::Discriminator for ProgramData {
        const DISCRIMINATOR: &'static [u8] = &[];
    }
}


================================================
File: lang/src/bpf_writer.rs
================================================
use solana_program::program_memory::sol_memcpy;
use std::cmp;
use std::io::{self, Write};

#[derive(Debug, Default)]
pub struct BpfWriter<T> {
    inner: T,
    pos: u64,
}

impl<T> BpfWriter<T> {
    pub fn new(inner: T) -> Self {
        Self { inner, pos: 0 }
    }
}

impl Write for BpfWriter<&mut [u8]> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        if self.pos >= self.inner.len() as u64 {
            return Ok(0);
        }

        let amt = cmp::min(
            self.inner.len().saturating_sub(self.pos as usize),
            buf.len(),
        );
        sol_memcpy(&mut self.inner[(self.pos as usize)..], buf, amt);
        self.pos += amt as u64;
        Ok(amt)
    }

    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {
        if self.write(buf)? == buf.len() {
            Ok(())
        } else {
            Err(io::Error::new(
                io::ErrorKind::WriteZero,
                "failed to write whole buffer",
            ))
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        Ok(())
    }
}


================================================
File: lang/src/common.rs
================================================
use crate::prelude::{Id, System};
use crate::Result;
use solana_program::account_info::AccountInfo;
use solana_program::system_program;

pub fn close<'info>(info: AccountInfo<'info>, sol_destination: AccountInfo<'info>) -> Result<()> {
    // Transfer tokens from the account to the sol_destination.
    let dest_starting_lamports = sol_destination.lamports();
    **sol_destination.lamports.borrow_mut() =
        dest_starting_lamports.checked_add(info.lamports()).unwrap();
    **info.lamports.borrow_mut() = 0;

    info.assign(&system_program::ID);
    info.realloc(0, false).map_err(Into::into)
}

pub fn is_closed(info: &AccountInfo) -> bool {
    info.owner == &System::id() && info.data_is_empty()
}


================================================
File: lang/src/event.rs
================================================
// Sha256(anchor:event)[..8]
pub const EVENT_IX_TAG: u64 = 0x1d9acb512ea545e4;
pub const EVENT_IX_TAG_LE: &[u8] = EVENT_IX_TAG.to_le_bytes().as_slice();


================================================
File: lang/src/vec.rs
================================================
use crate::{Accounts, Result, ToAccountInfos, ToAccountMetas};
use solana_program::account_info::AccountInfo;
use solana_program::instruction::AccountMeta;
use solana_program::pubkey::Pubkey;
use std::collections::BTreeSet;

impl<'info, T: ToAccountInfos<'info>> ToAccountInfos<'info> for Vec<T> {
    fn to_account_infos(&self) -> Vec<AccountInfo<'info>> {
        self.iter()
            .flat_map(|item| item.to_account_infos())
            .collect()
    }
}

impl<T: ToAccountMetas> ToAccountMetas for Vec<T> {
    fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<AccountMeta> {
        self.iter()
            .flat_map(|item| (*item).to_account_metas(is_signer))
            .collect()
    }
}

impl<'info, B, T: Accounts<'info, B>> Accounts<'info, B> for Vec<T> {
    fn try_accounts(
        program_id: &Pubkey,
        accounts: &mut &'info [AccountInfo<'info>],
        ix_data: &[u8],
        bumps: &mut B,
        reallocs: &mut BTreeSet<Pubkey>,
    ) -> Result<Self> {
        let mut vec: Vec<T> = Vec::new();
        T::try_accounts(program_id, accounts, ix_data, bumps, reallocs)
            .map(|item| vec.push(item))?;
        Ok(vec)
    }
}

#[cfg(test)]
mod tests {
    use solana_program::clock::Epoch;
    use solana_program::pubkey::Pubkey;

    use super::*;

    #[derive(Accounts)]
    pub struct Test<'info> {
        #[account(signer)]
        test: AccountInfo<'info>,
    }

    #[test]
    fn test_accounts_trait_for_vec() {
        let program_id = Pubkey::default();

        let key = Pubkey::default();
        let mut lamports1 = 0;
        let mut data1 = vec![0; 10];
        let owner = Pubkey::default();
        let account1 = AccountInfo::new(
            &key,
            true,
            true,
            &mut lamports1,
            &mut data1,
            &owner,
            false,
            Epoch::default(),
        );

        let mut lamports2 = 0;
        let mut data2 = vec![0; 10];
        let account2 = AccountInfo::new(
            &key,
            true,
            true,
            &mut lamports2,
            &mut data2,
            &owner,
            false,
            Epoch::default(),
        );
        let mut bumps = TestBumps::default();
        let mut reallocs = std::collections::BTreeSet::new();
        let mut accounts = &[account1, account2][..];
        let parsed_accounts =
            Vec::<Test>::try_accounts(&program_id, &mut accounts, &[], &mut bumps, &mut reallocs)
                .unwrap();

        assert_eq!(accounts.len(), parsed_accounts.len());
    }

    #[test]
    #[should_panic]
    fn test_accounts_trait_for_vec_empty() {
        let program_id = Pubkey::default();
        let mut bumps = TestBumps::default();
        let mut reallocs = std::collections::BTreeSet::new();
        let mut accounts = &[][..];
        Vec::<Test>::try_accounts(&program_id, &mut accounts, &[], &mut bumps, &mut reallocs)
            .unwrap();
    }
}


================================================
File: lang/src/accounts/account_info.rs
================================================
//! AccountInfo can be used as a type but
//! [Unchecked Account](crate::accounts::unchecked_account::UncheckedAccount)
//! should be used instead.

use crate::error::ErrorCode;
use crate::{Accounts, AccountsExit, Key, Result, ToAccountInfos, ToAccountMetas};
use solana_program::account_info::AccountInfo;
use solana_program::instruction::AccountMeta;
use solana_program::pubkey::Pubkey;
use std::collections::BTreeSet;

impl<'info, B> Accounts<'info, B> for AccountInfo<'info> {
    fn try_accounts(
        _program_id: &Pubkey,
        accounts: &mut &[AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut B,
        _reallocs: &mut BTreeSet<Pubkey>,
    ) -> Result<Self> {
        if accounts.is_empty() {
            return Err(ErrorCode::AccountNotEnoughKeys.into());
        }
        let account = &accounts[0];
        *accounts = &accounts[1..];
        Ok(account.clone())
    }
}

impl ToAccountMetas for AccountInfo<'_> {
    fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<AccountMeta> {
        let is_signer = is_signer.unwrap_or(self.is_signer);
        let meta = match self.is_writable {
            false => AccountMeta::new_readonly(*self.key, is_signer),
            true => AccountMeta::new(*self.key, is_signer),
        };
        vec![meta]
    }
}

impl<'info> ToAccountInfos<'info> for AccountInfo<'info> {
    fn to_account_infos(&self) -> Vec<AccountInfo<'info>> {
        vec![self.clone()]
    }
}

impl<'info> AccountsExit<'info> for AccountInfo<'info> {}

impl Key for AccountInfo<'_> {
    fn key(&self) -> Pubkey {
        *self.key
    }
}


================================================
File: lang/src/accounts/boxed.rs
================================================
//! Box<T> type to save stack space.
//!
//! Sometimes accounts are too large for the stack,
//! leading to stack violations.
//!
//! Boxing the account can help.
//!
//! # Example
//! ```ignore
//! #[derive(Accounts)]
//! pub struct Example {
//!     pub my_acc: Box<Account<'info, MyData>>
//! }
//! ```

use crate::{Accounts, AccountsClose, AccountsExit, Result, ToAccountInfos, ToAccountMetas};
use solana_program::account_info::AccountInfo;
use solana_program::instruction::AccountMeta;
use solana_program::pubkey::Pubkey;
use std::collections::BTreeSet;
use std::ops::Deref;

impl<'info, B, T: Accounts<'info, B>> Accounts<'info, B> for Box<T> {
    fn try_accounts(
        program_id: &Pubkey,
        accounts: &mut &'info [AccountInfo<'info>],
        ix_data: &[u8],
        bumps: &mut B,
        reallocs: &mut BTreeSet<Pubkey>,
    ) -> Result<Self> {
        T::try_accounts(program_id, accounts, ix_data, bumps, reallocs).map(Box::new)
    }
}

impl<'info, T: AccountsExit<'info>> AccountsExit<'info> for Box<T> {
    fn exit(&self, program_id: &Pubkey) -> Result<()> {
        T::exit(Deref::deref(self), program_id)
    }
}

impl<'info, T: ToAccountInfos<'info>> ToAccountInfos<'info> for Box<T> {
    fn to_account_infos(&self) -> Vec<AccountInfo<'info>> {
        T::to_account_infos(self)
    }
}

impl<T: ToAccountMetas> ToAccountMetas for Box<T> {
    fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<AccountMeta> {
        T::to_account_metas(self, is_signer)
    }
}

impl<'info, T: AccountsClose<'info>> AccountsClose<'info> for Box<T> {
    fn close(&self, sol_destination: AccountInfo<'info>) -> Result<()> {
        T::close(self, sol_destination)
    }
}


================================================
File: lang/src/accounts/mod.rs
================================================
//! Account types that can be used in the account validation struct.

pub mod account;
pub mod account_info;
pub mod account_loader;
pub mod boxed;
pub mod interface;
pub mod interface_account;
pub mod option;
pub mod program;
pub mod signer;
pub mod system_account;
pub mod sysvar;
pub mod unchecked_account;

#[cfg(feature = "lazy-account")]
pub mod lazy_account;


================================================
File: lang/src/accounts/system_account.rs
================================================
//! Type validating that the account is owned by the system program

use crate::error::ErrorCode;
use crate::*;
use solana_program::system_program;
use std::ops::Deref;

/// Type validating that the account is owned by the system program
///
/// Checks:
///
/// - `SystemAccount.info.owner == SystemProgram`
#[derive(Debug, Clone)]
pub struct SystemAccount<'info> {
    info: &'info AccountInfo<'info>,
}

impl<'info> SystemAccount<'info> {
    fn new(info: &'info AccountInfo<'info>) -> SystemAccount<'info> {
        Self { info }
    }

    #[inline(never)]
    pub fn try_from(info: &'info AccountInfo<'info>) -> Result<SystemAccount<'info>> {
        if *info.owner != system_program::ID {
            return Err(ErrorCode::AccountNotSystemOwned.into());
        }
        Ok(SystemAccount::new(info))
    }
}

impl<'info, B> Accounts<'info, B> for SystemAccount<'info> {
    #[inline(never)]
    fn try_accounts(
        _program_id: &Pubkey,
        accounts: &mut &'info [AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut B,
        _reallocs: &mut BTreeSet<Pubkey>,
    ) -> Result<Self> {
        if accounts.is_empty() {
            return Err(ErrorCode::AccountNotEnoughKeys.into());
        }
        let account = &accounts[0];
        *accounts = &accounts[1..];
        SystemAccount::try_from(account)
    }
}

impl<'info> AccountsExit<'info> for SystemAccount<'info> {}

impl ToAccountMetas for SystemAccount<'_> {
    fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<AccountMeta> {
        let is_signer = is_signer.unwrap_or(self.info.is_signer);
        let meta = match self.info.is_writable {
            false => AccountMeta::new_readonly(*self.info.key, is_signer),
            true => AccountMeta::new(*self.info.key, is_signer),
        };
        vec![meta]
    }
}

impl<'info> ToAccountInfos<'info> for SystemAccount<'info> {
    fn to_account_infos(&self) -> Vec<AccountInfo<'info>> {
        vec![self.info.clone()]
    }
}

impl<'info> AsRef<AccountInfo<'info>> for SystemAccount<'info> {
    fn as_ref(&self) -> &AccountInfo<'info> {
        self.info
    }
}

impl<'info> Deref for SystemAccount<'info> {
    type Target = AccountInfo<'info>;

    fn deref(&self) -> &Self::Target {
        self.info
    }
}

impl Key for SystemAccount<'_> {
    fn key(&self) -> Pubkey {
        *self.info.key
    }
}


================================================
File: lang/src/accounts/unchecked_account.rs
================================================
//! Explicit wrapper for AccountInfo types to emphasize
//! that no checks are performed

use crate::error::ErrorCode;
use crate::{Accounts, AccountsExit, Key, Result, ToAccountInfos, ToAccountMetas};
use solana_program::account_info::AccountInfo;
use solana_program::instruction::AccountMeta;
use solana_program::pubkey::Pubkey;
use std::collections::BTreeSet;
use std::ops::Deref;

/// Explicit wrapper for AccountInfo types to emphasize
/// that no checks are performed
#[derive(Debug, Clone)]
pub struct UncheckedAccount<'info>(&'info AccountInfo<'info>);

impl<'info> UncheckedAccount<'info> {
    pub fn try_from(acc_info: &'info AccountInfo<'info>) -> Self {
        Self(acc_info)
    }
}

impl<'info, B> Accounts<'info, B> for UncheckedAccount<'info> {
    fn try_accounts(
        _program_id: &Pubkey,
        accounts: &mut &'info [AccountInfo<'info>],
        _ix_data: &[u8],
        _bumps: &mut B,
        _reallocs: &mut BTreeSet<Pubkey>,
    ) -> Result<Self> {
        if accounts.is_empty() {
            return Err(ErrorCode::AccountNotEnoughKeys.into());
        }
        let account = &accounts[0];
        *accounts = &accounts[1..];
        Ok(UncheckedAccount(account))
    }
}

impl ToAccountMetas for UncheckedAccount<'_> {
    fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<AccountMeta> {
        let is_signer = is_signer.unwrap_or(self.is_signer);
        let meta = match self.is_writable {
            false => AccountMeta::new_readonly(*self.key, is_signer),
            true => AccountMeta::new(*self.key, is_signer),
        };
        vec![meta]
    }
}

impl<'info> ToAccountInfos<'info> for UncheckedAccount<'info> {
    fn to_account_infos(&self) -> Vec<AccountInfo<'info>> {
        vec![self.0.clone()]
    }
}

impl<'info> AccountsExit<'info> for UncheckedAccount<'info> {}

impl<'info> AsRef<AccountInfo<'info>> for UncheckedAccount<'info> {
    fn as_ref(&self) -> &AccountInfo<'info> {
        self.0
    }
}

impl<'info> Deref for UncheckedAccount<'info> {
    type Target = AccountInfo<'info>;

    fn deref(&self) -> &Self::Target {
        self.0
    }
}

impl Key for UncheckedAccount<'_> {
    fn key(&self) -> Pubkey {
        *self.0.key
    }
}


================================================
File: lang/syn/Cargo.toml
================================================
[package]
name = "anchor-syn"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
repository = "https://github.com/coral-xyz/anchor"
license = "Apache-2.0"
description = "Anchor syntax parsing and code generation tools"
edition = "2021"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
allow-missing-optionals = []
anchor-debug = []
event-cpi = []
hash = []
idl-build = ["cargo_toml"]
init-if-needed = []
interface-instructions = []

[dependencies]
anyhow = "1"
bs58 = "0.5"
heck = "0.3"
proc-macro2 = { version = "1", features = ["span-locations"] }
quote = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
sha2 = "0.10"
syn = { version = "1", features = ["full", "extra-traits", "parsing"] }
thiserror = "1"

# `idl-build` feature only
cargo_toml = { version = "0.19", optional = true }

# https://blog.rust-lang.org/2024/05/06/check-cfg.html#expecting-custom-cfgs
[lints.rust]
unexpected_cfgs = { level = "allow", check-cfg = ["cfg(procmacro2_semver_exempt)"] }


================================================
File: lang/syn/src/hash.rs
================================================
// Utility hashing module copied from `solana_program::program::hash`, since we
// can't import solana_program for compile time hashing for some reason.

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::{fmt, mem, str::FromStr};
use thiserror::Error;

pub const HASH_BYTES: usize = 32;
#[derive(Serialize, Deserialize, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[repr(transparent)]
pub struct Hash(pub [u8; HASH_BYTES]);

#[derive(Clone, Default)]
pub struct Hasher {
    hasher: Sha256,
}

impl Hasher {
    pub fn hash(&mut self, val: &[u8]) {
        self.hasher.update(val);
    }
    pub fn hashv(&mut self, vals: &[&[u8]]) {
        for val in vals {
            self.hash(val);
        }
    }
    pub fn result(self) -> Hash {
        // At the time of this writing, the sha2 library is stuck on an old version
        // of generic_array (0.9.0). Decouple ourselves with a clone to our version.
        Hash(<[u8; HASH_BYTES]>::try_from(self.hasher.finalize().as_slice()).unwrap())
    }
}

impl AsRef<[u8]> for Hash {
    fn as_ref(&self) -> &[u8] {
        &self.0[..]
    }
}

impl fmt::Debug for Hash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", bs58::encode(self.0).into_string())
    }
}

impl fmt::Display for Hash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", bs58::encode(self.0).into_string())
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Error)]
pub enum ParseHashError {
    #[error("string decoded to wrong size for hash")]
    WrongSize,
    #[error("failed to decoded string to hash")]
    Invalid,
}

impl FromStr for Hash {
    type Err = ParseHashError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = bs58::decode(s)
            .into_vec()
            .map_err(|_| ParseHashError::Invalid)?;
        if bytes.len() != mem::size_of::<Hash>() {
            Err(ParseHashError::WrongSize)
        } else {
            Ok(Hash::new(&bytes))
        }
    }
}

impl Hash {
    pub fn new(hash_slice: &[u8]) -> Self {
        Hash(<[u8; HASH_BYTES]>::try_from(hash_slice).unwrap())
    }

    pub fn to_bytes(self) -> [u8; HASH_BYTES] {
        self.0
    }
}

/// Return a Sha256 hash for the given data.
pub fn hashv(vals: &[&[u8]]) -> Hash {
    // Perform the calculation inline, calling this from within a program is
    // not supported
    let mut hasher = Hasher::default();
    hasher.hashv(vals);
    hasher.result()
}

/// Return a Sha256 hash for the given data.
pub fn hash(val: &[u8]) -> Hash {
    hashv(&[val])
}


================================================
File: lang/syn/src/codegen/mod.rs
================================================
pub mod accounts;
pub mod error;
pub mod program;


================================================
File: lang/syn/src/codegen/accounts/bumps.rs
================================================
use crate::{
    codegen::accounts::{generics, ParsedGenerics},
    *,
};
use std::fmt::Display;

use super::constraints;

pub fn generate_bumps_name<T: Display>(anchor_ident: &T) -> Ident {
    Ident::new(&format!("{}Bumps", anchor_ident), Span::call_site())
}

pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {
    let name = &accs.ident;
    let bumps_name = generate_bumps_name(name);
    let ParsedGenerics {
        combined_generics,
        trait_generics: _,
        struct_generics,
        where_clause,
    } = generics(accs);

    let (bump_fields, bump_default_fields): (
        Vec<proc_macro2::TokenStream>,
        Vec<proc_macro2::TokenStream>,
    ) = accs
        .fields
        .iter()
        .filter_map(|af| {
            let ident = af.ident();

            match af {
                AccountField::Field(f) => {
                    let constraints = constraints::linearize(&f.constraints);
                    let (bump_field, bump_default_field) = if f.is_optional {
                        (quote!(pub #ident: Option<u8>), quote!(#ident: None))
                    } else {
                        (quote!(pub #ident: u8), quote!(#ident: u8::MAX))
                    };

                    for c in constraints.iter() {
                        // Verify this in super::constraints
                        // The bump is only cached if
                        // - PDA is marked as init
                        // - PDA is not init, but marked with bump without a target

                        match c {
                            Constraint::Seeds(c) => {
                                if !c.is_init && c.bump.is_none() {
                                    return Some((bump_field, bump_default_field));
                                }
                            }
                            Constraint::Init(c) => {
                                if c.seeds.is_some() {
                                    return Some((bump_field, bump_default_field));
                                }
                            }
                            _ => (),
                        }
                    }
                    None
                }
                AccountField::CompositeField(s) => {
                    let comp_bumps_struct = generate_bumps_name(&s.symbol);
                    let bumps = quote!(pub #ident: #comp_bumps_struct);
                    let bumps_default = quote!(#ident: #comp_bumps_struct::default());

                    Some((bumps, bumps_default))
                }
            }
        })
        .unzip();

    quote! {
        #[derive(Debug)]
        pub struct #bumps_name {
            #(#bump_fields),*
        }

        impl Default for #bumps_name {
            fn default() -> Self {
                #bumps_name {
                    #(#bump_default_fields),*
                }
            }
        }

        impl<#combined_generics> anchor_lang::Bumps for #name<#struct_generics> #where_clause {
            type Bumps = #bumps_name;
        }
    }
}


================================================
File: lang/syn/src/codegen/accounts/exit.rs
================================================
use crate::accounts_codegen::constraints::OptionalCheckScope;
use crate::codegen::accounts::{generics, ParsedGenerics};
use crate::{AccountField, AccountsStruct, Ty};
use quote::quote;

// Generates the `Exit` trait implementation.
pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {
    let name = &accs.ident;
    let ParsedGenerics {
        combined_generics,
        trait_generics,
        struct_generics,
        where_clause,
    } = generics(accs);

    let on_save: Vec<proc_macro2::TokenStream> = accs
        .fields
        .iter()
        .map(|af: &AccountField| match af {
            AccountField::CompositeField(s) => {
                let name = &s.ident;
                let name_str = name.to_string();
                quote! {
                    anchor_lang::AccountsExit::exit(&self.#name, program_id)
                        .map_err(|e| e.with_account_name(#name_str))?;
                }
            }
            AccountField::Field(f) => {
                let ident = &f.ident;
                let name_str = ident.to_string();
                if f.constraints.is_close() {
                    let close_target = &f.constraints.close.as_ref().unwrap().sol_dest;
                    let close_target_optional_check =
                        OptionalCheckScope::new(accs).generate_check(close_target);

                    quote! {
                        {
                            let #close_target = &self.#close_target;
                            #close_target_optional_check
                            anchor_lang::AccountsClose::close(
                                &self.#ident,
                                #close_target.to_account_info(),
                            ).map_err(|e| e.with_account_name(#name_str))?;
                        }
                    }
                } else {
                    match f.constraints.is_mutable() {
                        false => quote! {},
                        true => match &f.ty {
                            // `LazyAccount` is special because it has a custom `exit` method.
                            Ty::LazyAccount(_) => quote! {
                                self.#ident.exit(program_id)
                                    .map_err(|e| e.with_account_name(#name_str))?;
                            },
                            _ => quote! {
                                anchor_lang::AccountsExit::exit(&self.#ident, program_id)
                                    .map_err(|e| e.with_account_name(#name_str))?;
                            },
                        },
                    }
                }
            }
        })
        .collect();
    quote! {
        #[automatically_derived]
        impl<#combined_generics> anchor_lang::AccountsExit<#trait_generics> for #name<#struct_generics> #where_clause{
            fn exit(&self, program_id: &anchor_lang::solana_program::pubkey::Pubkey) -> anchor_lang::Result<()> {
                #(#on_save)*
                Ok(())
            }
        }
    }
}


================================================
File: lang/syn/src/codegen/accounts/to_account_infos.rs
================================================
use crate::codegen::accounts::{generics, ParsedGenerics};
use crate::{AccountField, AccountsStruct};
use quote::quote;

// Generates the `ToAccountInfos` trait implementation.
pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {
    let name = &accs.ident;
    let ParsedGenerics {
        combined_generics,
        trait_generics,
        struct_generics,
        where_clause,
    } = generics(accs);

    let to_acc_infos: Vec<proc_macro2::TokenStream> = accs
        .fields
        .iter()
        .map(|f: &AccountField| {
            let name = &f.ident();
            quote! { account_infos.extend(self.#name.to_account_infos()); }
        })
        .collect();
    quote! {
        #[automatically_derived]
        impl<#combined_generics> anchor_lang::ToAccountInfos<#trait_generics> for #name <#struct_generics> #where_clause{
            fn to_account_infos(&self) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<#trait_generics>> {
                let mut account_infos = vec![];

                #(#to_acc_infos)*

                account_infos
            }
        }
    }
}


================================================
File: lang/syn/src/codegen/accounts/to_account_metas.rs
================================================
use crate::{AccountField, AccountsStruct};
use quote::quote;

// Generates the `ToAccountMetas` trait implementation.
pub fn generate(accs: &AccountsStruct) -> proc_macro2::TokenStream {
    let name = &accs.ident;

    let to_acc_metas: Vec<proc_macro2::TokenStream> = accs
        .fields
        .iter()
        .map(|f: &AccountField| {
            let (name, is_signer, is_optional) = match f {
                AccountField::CompositeField(s) => (&s.ident, quote! {None}, false),
                AccountField::Field(f) => {
                    let is_signer = match f.constraints.is_signer() {
                        false => quote! {None},
                        true => quote! {Some(true)},
                    };
                    (&f.ident, is_signer, f.is_optional)
                }
            };
            if is_optional {
                quote! {
                    if let Some(#name) = &self.#name {
                        account_metas.extend(#name.to_account_metas(#is_signer));
                    } else {
                        account_metas.push(AccountMeta::new_readonly(crate::ID, false));
                    }
                }
            } else {
                quote! {
                    account_metas.extend(self.#name.to_account_metas(#is_signer));
                }
            }
        })
        .collect();

    let (impl_gen, ty_gen, where_clause) = accs.generics.split_for_impl();

    quote! {
        #[automatically_derived]
        impl #impl_gen anchor_lang::ToAccountMetas for #name #ty_gen #where_clause{
            fn to_account_metas(&self, is_signer: Option<bool>) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = vec![];

                #(#to_acc_metas)*

                account_metas
            }
        }
    }
}


================================================
File: lang/syn/src/codegen/program/accounts.rs
================================================
use crate::Program;
use heck::SnakeCase;
use quote::quote;

pub fn generate(program: &Program) -> proc_macro2::TokenStream {
    let mut accounts = std::collections::HashMap::new();

    // Go through instruction accounts.
    for ix in &program.ixs {
        let anchor_ident = &ix.anchor_ident;
        // TODO: move to fn and share with accounts.rs.
        let macro_name = format!(
            "__client_accounts_{}",
            anchor_ident.to_string().to_snake_case()
        );
        accounts.insert(macro_name, ix.cfgs.as_slice());
    }

    // Build the tokens from all accounts
    let account_structs: Vec<proc_macro2::TokenStream> = accounts
        .iter()
        .map(|(macro_name, cfgs)| {
            let macro_name: proc_macro2::TokenStream = macro_name.parse().unwrap();
            quote! {
                #(#cfgs)*
                pub use crate::#macro_name::*;
            }
        })
        .collect();

    // TODO: calculate the account size and add it as a constant field to
    //       each struct here. This is convenient for Rust clients.

    quote! {
        /// An Anchor generated module, providing a set of structs
        /// mirroring the structs deriving `Accounts`, where each field is
        /// a `Pubkey`. This is useful for specifying accounts for a client.
        pub mod accounts {
            #(#account_structs)*
        }
    }
}


================================================
File: lang/syn/src/codegen/program/common.rs
================================================
use crate::IxArg;
use heck::CamelCase;
use quote::quote;

// Namespace for calculating instruction sighash signatures for any instruction
// not affecting program state.
pub const SIGHASH_GLOBAL_NAMESPACE: &str = "global";

// We don't technically use sighash, because the input arguments aren't given.
// Rust doesn't have method overloading so no need to use the arguments.
// However, we do namespace methods in the preeimage so that we can use
// different traits with the same method name.
pub fn sighash(namespace: &str, name: &str) -> [u8; 8] {
    let preimage = format!("{namespace}:{name}");

    let mut sighash = [0u8; 8];
    sighash.copy_from_slice(&crate::hash::hash(preimage.as_bytes()).to_bytes()[..8]);
    sighash
}

pub fn gen_discriminator(namespace: &str, name: impl ToString) -> proc_macro2::TokenStream {
    let discriminator = sighash(namespace, name.to_string().as_str());
    format!("&{:?}", discriminator).parse().unwrap()
}

pub fn generate_ix_variant(name: &str, args: &[IxArg]) -> proc_macro2::TokenStream {
    let ix_arg_names: Vec<&syn::Ident> = args.iter().map(|arg| &arg.name).collect();
    let ix_name_camel = generate_ix_variant_name(name);

    if args.is_empty() {
        quote! {
            #ix_name_camel
        }
    } else {
        quote! {
            #ix_name_camel {
                #(#ix_arg_names),*
            }
        }
    }
}

pub fn generate_ix_variant_name(name: &str) -> proc_macro2::TokenStream {
    let n = name.to_camel_case();
    n.parse().unwrap()
}


================================================
File: lang/syn/src/codegen/program/mod.rs
================================================
use crate::Program;
use quote::quote;

mod accounts;
pub mod common;
mod cpi;
mod dispatch;
mod entry;
mod handlers;
mod idl;
mod instruction;

pub fn generate(program: &Program) -> proc_macro2::TokenStream {
    let mod_name = &program.name;

    let entry = entry::generate(program);
    let dispatch = dispatch::generate(program);
    let handlers = handlers::generate(program);
    let user_defined_program = &program.program_mod;
    let instruction = instruction::generate(program);
    let cpi = cpi::generate(program);
    let accounts = accounts::generate(program);

    #[allow(clippy::let_and_return)]
    let ret = {
        quote! {
            // TODO: remove once we allow segmented paths in `Accounts` structs.
            use self::#mod_name::*;

            #entry
            #dispatch
            #handlers
            #user_defined_program
            #instruction
            #cpi
            #accounts
        }
    };

    #[cfg(feature = "idl-build")]
    {
        let idl_build_impl = crate::idl::gen_idl_print_fn_program(program);
        return quote! {
            #ret
            #idl_build_impl
        };
    };

    #[allow(unreachable_code)]
    ret
}


================================================
File: lang/syn/src/idl/address.rs
================================================
use proc_macro2::TokenStream;
use quote::quote;

use super::common::gen_print_section;

pub fn gen_idl_print_fn_address(address: String) -> TokenStream {
    let fn_body = gen_print_section("address", quote! { #address });

    quote! {
        #[test]
        pub fn __anchor_private_print_idl_address() {
            #fn_body
        }
    }
}


================================================
File: lang/syn/src/idl/common.rs
================================================
use std::path::{Path, PathBuf};

use anyhow::{anyhow, Result};
use proc_macro2::TokenStream;
use quote::{quote, ToTokens};

pub fn find_path(name: &str, path: impl AsRef<Path>) -> Result<PathBuf> {
    let path = path.as_ref();
    for ancestor in path.ancestors() {
        let file_path = ancestor.join(name);
        if file_path.exists() {
            return file_path.canonicalize().map_err(Into::into);
        }
    }

    Err(anyhow!("Path ({path:?}) not found"))
}

pub fn get_no_docs() -> bool {
    option_env!("ANCHOR_IDL_BUILD_NO_DOCS")
        .map(|val| val == "TRUE")
        .unwrap_or_default()
}

pub fn get_program_path() -> Result<PathBuf> {
    std::env::var("ANCHOR_IDL_BUILD_PROGRAM_PATH")
        .map(PathBuf::from)
        .map_err(|_| anyhow!("Failed to get program path"))
}

pub fn get_idl_module_path() -> TokenStream {
    quote!(anchor_lang::idl::types)
}

pub fn get_serde_json_module_path() -> TokenStream {
    quote!(anchor_lang::idl::serde_json)
}

pub fn gen_print_section(name: &str, value: impl ToTokens) -> TokenStream {
    let serde_json = get_serde_json_module_path();
    quote! {
        println!("--- IDL begin {} ---", #name);
        println!("{}", #serde_json::to_string_pretty(&{ #value }).unwrap());
        println!("--- IDL end {} ---", #name);
    }
}


================================================
File: lang/syn/src/idl/constant.rs
================================================
use heck::SnakeCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use super::{
    common::{gen_print_section, get_idl_module_path, get_no_docs},
    defined::gen_idl_type,
};
use crate::parser::docs;

pub fn gen_idl_print_fn_constant(item: &syn::ItemConst) -> TokenStream {
    let idl = get_idl_module_path();
    let no_docs = get_no_docs();

    let name = item.ident.to_string();
    let expr = &item.expr;
    let fn_name = format_ident!("__anchor_private_print_idl_const_{}", name.to_snake_case());

    let docs = match docs::parse(&item.attrs) {
        Some(docs) if !no_docs => quote! { vec![#(#docs.into()),*] },
        _ => quote! { vec![] },
    };

    let fn_body = match gen_idl_type(&item.ty, &[]) {
        Ok((ty, _)) => gen_print_section(
            "const",
            quote! {
                #idl::IdlConst {
                    name: #name.into(),
                    docs: #docs,
                    ty: #ty,
                    value: format!("{:?}", #expr),
                }
            },
        ),
        _ => quote! {},
    };

    quote! {
        #[test]
        pub fn #fn_name() {
            #fn_body
        }
    }
}


================================================
File: lang/syn/src/idl/error.rs
================================================
use heck::SnakeCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use super::common::{gen_print_section, get_idl_module_path};
use crate::Error;

pub fn gen_idl_print_fn_error(error: &Error) -> TokenStream {
    let idl = get_idl_module_path();

    let fn_name = format_ident!(
        "__anchor_private_print_idl_error_{}",
        error.ident.to_string().to_snake_case()
    );

    let error_codes = error
        .codes
        .iter()
        .map(|code| {
            let id = code.id;
            let name = code.ident.to_string();
            let msg = match &code.msg {
                Some(msg) => quote! { Some(#msg.into()) },
                None => quote! { None },
            };

            quote! {
                #idl::IdlErrorCode {
                    code: anchor_lang::error::ERROR_CODE_OFFSET + #id,
                    name: #name.into(),
                    msg: #msg,
                }
            }
        })
        .collect::<Vec<_>>();
    let fn_body = gen_print_section("errors", quote! { vec![#(#error_codes),*] });

    quote! {
        #[test]
        pub fn #fn_name() {
            #fn_body
        }
    }
}


================================================
File: lang/syn/src/idl/event.rs
================================================
use heck::SnakeCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use super::{
    common::{gen_print_section, get_idl_module_path, get_serde_json_module_path},
    defined::gen_idl_type_def_struct,
};

pub fn gen_idl_print_fn_event(event_struct: &syn::ItemStruct) -> TokenStream {
    let idl = get_idl_module_path();
    let serde_json = get_serde_json_module_path();

    let ident = &event_struct.ident;
    let fn_name = format_ident!(
        "__anchor_private_print_idl_event_{}",
        ident.to_string().to_snake_case()
    );
    let idl_build_impl = impl_idl_build_event(event_struct);

    let print_ts = gen_print_section(
        "event",
        quote! {
            #serde_json::json!({
                "event": event,
                "types": types.into_values().collect::<Vec<_>>()
            })
        },
    );

    quote! {
        #idl_build_impl

        #[test]
        pub fn #fn_name() {
            let mut types: std::collections::BTreeMap<String, #idl::IdlTypeDef> =
                std::collections::BTreeMap::new();
            if let Some(event) = #ident::__anchor_private_gen_idl_event(&mut types) {
                #print_ts
            }
        }
    }
}

/// Generate IDL build impl for an event.
fn impl_idl_build_event(event_struct: &syn::ItemStruct) -> TokenStream {
    let idl = get_idl_module_path();

    let ident = &event_struct.ident;
    let (impl_generics, ty_generics, where_clause) = event_struct.generics.split_for_impl();

    let fn_body = match gen_idl_type_def_struct(event_struct) {
        Ok((ts, defined)) => quote! {
            #(
                if let Some(ty) = <#defined>::create_type() {
                    types.insert(<#defined>::get_full_path(), ty);
                    <#defined>::insert_types(types);
                }
            );*

            let ty = #ts;
            let event = #idl::IdlEvent {
                name: ty.name.clone(),
                discriminator: Self::DISCRIMINATOR.into(),
            };
            types.insert(ty.name.clone(), ty);
            Some(event)
        },
        _ => quote! { None },
    };

    quote! {
        impl #impl_generics #ident #ty_generics #where_clause {
            pub fn __anchor_private_gen_idl_event(
                types: &mut std::collections::BTreeMap<String, #idl::IdlTypeDef>,
            ) -> Option<#idl::IdlEvent> {
                #fn_body
            }
        }
    }
}


================================================
File: lang/syn/src/idl/mod.rs
================================================
#![allow(dead_code)]

mod accounts;
mod address;
mod common;
mod constant;
mod defined;
mod error;
mod event;
mod external;
mod program;

pub use accounts::gen_idl_build_impl_accounts_struct;
pub use address::gen_idl_print_fn_address;
pub use constant::gen_idl_print_fn_constant;
pub use defined::{impl_idl_build_enum, impl_idl_build_struct, impl_idl_build_union};
pub use error::gen_idl_print_fn_error;
pub use event::gen_idl_print_fn_event;
pub use program::gen_idl_print_fn_program;


================================================
File: lang/syn/src/parser/docs.rs
================================================
use syn::{Lit::Str, Meta::NameValue};

// returns vec of doc strings
pub fn parse(attrs: &[syn::Attribute]) -> Option<Vec<String>> {
    let doc_strings: Vec<String> = attrs
        .iter()
        .filter_map(|attr| match attr.parse_meta() {
            Ok(NameValue(meta)) => {
                if meta.path.is_ident("doc") {
                    if let Str(doc) = meta.lit {
                        let val = doc.value().trim().to_string();
                        if val.starts_with("CHECK:") {
                            return None;
                        }
                        return Some(val);
                    }
                }
                None
            }
            _ => None,
        })
        .collect();
    if doc_strings.is_empty() {
        None
    } else {
        Some(doc_strings)
    }
}


================================================
File: lang/syn/src/parser/error.rs
================================================
use crate::{Error, ErrorArgs, ErrorCode};
use syn::parse::{Parse, Result as ParseResult};
use syn::Expr;

// Removes any internal #[msg] attributes, as they are inert.
pub fn parse(error_enum: &mut syn::ItemEnum, args: Option<ErrorArgs>) -> Error {
    let ident = error_enum.ident.clone();
    let mut last_discriminant = 0;
    let codes: Vec<ErrorCode> = error_enum
        .variants
        .iter_mut()
        .map(|variant: &mut syn::Variant| {
            let msg = parse_error_attribute(variant);
            let ident = variant.ident.clone();
            let id = match &variant.discriminant {
                None => last_discriminant,
                Some((_, disc)) => match disc {
                    syn::Expr::Lit(expr_lit) => match &expr_lit.lit {
                        syn::Lit::Int(int) => {
                            int.base10_parse::<u32>().expect("Must be a base 10 number")
                        }
                        _ => panic!("Invalid error discriminant"),
                    },
                    _ => panic!("Invalid error discriminant"),
                },
            };
            last_discriminant = id + 1;

            // Remove any non-doc attributes on the error variant.
            variant
                .attrs
                .retain(|attr| attr.path.segments[0].ident == "doc");

            ErrorCode { id, ident, msg }
        })
        .collect();
    Error {
        name: error_enum.ident.to_string(),
        raw_enum: error_enum.clone(),
        ident,
        codes,
        args,
    }
}

fn parse_error_attribute(variant: &syn::Variant) -> Option<String> {
    let attrs = variant
        .attrs
        .iter()
        .filter(|attr| attr.path.segments[0].ident != "doc")
        .collect::<Vec<_>>();
    match attrs.len() {
        0 => None,
        1 => {
            let attr = &attrs[0];
            let attr_str = attr.path.segments[0].ident.to_string();
            assert!(&attr_str == "msg", "Use msg to specify error strings");

            let mut tts = attr.tokens.clone().into_iter();
            let g_stream = match tts.next().expect("Must have a token group") {
                proc_macro2::TokenTree::Group(g) => g.stream(),
                _ => panic!("Invalid syntax"),
            };

            let msg = match g_stream.into_iter().next() {
                None => panic!("Must specify a message string"),
                Some(msg) => msg.to_string().replace('\"', ""),
            };

            Some(msg)
        }
        _ => {
            panic!("Too many attributes found. Use `msg` to specify error strings");
        }
    }
}

pub struct ErrorInput {
    pub error_code: Expr,
}

impl Parse for ErrorInput {
    fn parse(stream: syn::parse::ParseStream) -> ParseResult<Self> {
        let error_code = stream.call(Expr::parse)?;
        Ok(Self { error_code })
    }
}


================================================
File: lang/syn/src/parser/mod.rs
================================================
pub mod accounts;
pub mod context;
pub mod docs;
pub mod error;
pub mod program;
pub mod spl_interface;

pub fn tts_to_string<T: quote::ToTokens>(item: T) -> String {
    item.to_token_stream().to_string()
}


================================================
File: lang/syn/src/parser/spl_interface.rs
================================================
#[cfg(feature = "interface-instructions")]
use syn::{Meta, NestedMeta, Path};

#[cfg(not(feature = "interface-instructions"))]
pub fn parse(_attrs: &[syn::Attribute]) -> Option<[u8; 8]> {
    None
}

#[cfg(feature = "interface-instructions")]
pub fn parse(attrs: &[syn::Attribute]) -> Option<[u8; 8]> {
    let interfaces: Vec<[u8; 8]> = attrs
        .iter()
        .filter_map(|attr| {
            if attr.path.is_ident("interface") {
                if let Ok(Meta::List(meta_list)) = attr.parse_meta() {
                    if let Some(NestedMeta::Meta(Meta::Path(path))) = meta_list.nested.first() {
                        return Some(parse_interface_instruction(path));
                    }
                }
                panic!(
                    "Failed to parse interface instruction:\n{}",
                    quote::quote!(#attr)
                );
            }
            None
        })
        .collect();
    if interfaces.len() > 1 {
        panic!("An instruction can only implement one interface instruction");
    } else if interfaces.is_empty() {
        None
    } else {
        Some(interfaces[0])
    }
}

#[cfg(feature = "interface-instructions")]
fn parse_interface_instruction(path: &Path) -> [u8; 8] {
    if path.segments.len() != 2 {
        // All interface instruction args are expected to be in the form
        // <interface>::<instruction>
        panic!(
            "Invalid interface instruction: {}",
            path.segments
                .iter()
                .map(|segment| segment.ident.to_string())
                .collect::<Vec<String>>()
                .join("::")
        );
    }
    let interface = path.segments[0].ident.to_string();
    if interface == "spl_transfer_hook_interface" {
        let instruction = path.segments[1].ident.to_string();
        if instruction == "initialize_extra_account_meta_list" {
            return [43, 34, 13, 49, 167, 88, 235, 235]; // `InitializeExtraAccountMetaList`
        } else if instruction == "execute" {
            return [105, 37, 101, 197, 75, 251, 102, 26]; // `Execute`
        } else {
            panic!("Unsupported instruction: {}", instruction);
        }
    }
    panic!("Unsupported interface: {}", interface);
}


================================================
File: lang/syn/src/parser/accounts/event_cpi.rs
================================================
use quote::quote;

/// This struct is used to keep the authority account information in sync.
pub struct EventAuthority {
    /// Account name of the event authority
    pub name: &'static str,
    /// Seeds expression of the event authority
    pub seeds: proc_macro2::TokenStream,
}

impl EventAuthority {
    /// Returns the account name and the seeds expression of the event authority.
    pub fn get() -> Self {
        Self {
            name: "event_authority",
            seeds: quote! {b"__event_authority"},
        }
    }

    /// Returns the name without surrounding quotes.
    pub fn name_token_stream(&self) -> proc_macro2::TokenStream {
        let name_token_stream = syn::parse_str::<syn::Expr>(self.name).unwrap();
        quote! {#name_token_stream}
    }
}

/// Add necessary event CPI accounts to the given accounts struct.
pub fn add_event_cpi_accounts(
    accounts_struct: &syn::ItemStruct,
) -> syn::parse::Result<syn::ItemStruct> {
    let syn::ItemStruct {
        attrs,
        vis,
        struct_token,
        ident,
        generics,
        fields,
        ..
    } = accounts_struct;

    let fields = fields.into_iter().collect::<Vec<_>>();

    let info_lifetime = generics
        .lifetimes()
        .next()
        .map(|lifetime| quote! {#lifetime})
        .unwrap_or(quote! {'info});
    let generics = generics
        .lt_token
        .map(|_| quote! {#generics})
        .unwrap_or(quote! {<'info>});

    let authority = EventAuthority::get();
    let authority_name = authority.name_token_stream();
    let authority_seeds = authority.seeds;

    let accounts_struct = quote! {
        #(#attrs)*
        #vis #struct_token #ident #generics {
            #(#fields,)*

            /// CHECK: Only the event authority can invoke self-CPI
            #[account(seeds = [#authority_seeds], bump)]
            pub #authority_name: AccountInfo<#info_lifetime>,
            /// CHECK: Self-CPI will fail if the program is not the current program
            pub program: AccountInfo<#info_lifetime>,
        }
    };
    syn::parse2(accounts_struct)
}


================================================
File: lang/syn/src/parser/program/mod.rs
================================================
use crate::parser::docs;
use crate::Program;
use syn::parse::{Error as ParseError, Result as ParseResult};
use syn::spanned::Spanned;

mod instructions;

pub fn parse(program_mod: syn::ItemMod) -> ParseResult<Program> {
    let docs = docs::parse(&program_mod.attrs);
    let (ixs, fallback_fn) = instructions::parse(&program_mod)?;
    Ok(Program {
        ixs,
        name: program_mod.ident.clone(),
        docs,
        program_mod,
        fallback_fn,
    })
}

fn ctx_accounts_ident(path_ty: &syn::PatType) -> ParseResult<proc_macro2::Ident> {
    let p = match &*path_ty.ty {
        syn::Type::Path(p) => &p.path,
        _ => return Err(ParseError::new(path_ty.ty.span(), "invalid type")),
    };
    let segment = p
        .segments
        .first()
        .ok_or_else(|| ParseError::new(p.segments.span(), "expected generic arguments here"))?;

    let generic_args = match &segment.arguments {
        syn::PathArguments::AngleBracketed(args) => args,
        _ => return Err(ParseError::new(path_ty.span(), "missing accounts context")),
    };
    let generic_ty = generic_args
        .args
        .iter()
        .filter_map(|arg| match arg {
            syn::GenericArgument::Type(ty) => Some(ty),
            _ => None,
        })
        .next()
        .ok_or_else(|| ParseError::new(generic_args.span(), "expected Accounts type"))?;

    let path = match generic_ty {
        syn::Type::Path(ty_path) => &ty_path.path,
        _ => {
            return Err(ParseError::new(
                generic_ty.span(),
                "expected Accounts struct type",
            ))
        }
    };
    Ok(path.segments[0].ident.clone())
}


================================================
File: lang/tests/generics_test.rs
================================================
#![allow(dead_code)]

use anchor_lang::prelude::borsh::maybestd::io::Write;
use anchor_lang::prelude::*;
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::pubkey::Pubkey;

// Needed to declare accounts.
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[derive(Accounts)]
pub struct CustomLifetime<'a> {
    pub non_generic: UncheckedAccount<'a>,
}

#[derive(Accounts)]
pub struct GenericsTest<'info, T, U, const N: usize>
where
    T: AccountSerialize + AccountDeserialize + Owner + Clone,
    U: BorshSerialize + BorshDeserialize + Default + Clone,
{
    pub non_generic: AccountInfo<'info>,
    pub generic: Account<'info, T>,

    pub const_generic: AccountLoader<'info, FooAccount<N>>,
    pub const_generic_loader: AccountLoader<'info, FooAccount<N>>,
    pub associated: Account<'info, Associated<U>>,
}

#[account(zero_copy(unsafe))]
pub struct FooAccount<const N: usize> {
    pub data: WrappedU8Array<N>,
}

#[account]
#[derive(Default)]
pub struct Associated<T>
where
    T: BorshDeserialize + BorshSerialize + Default,
{
    pub data: T,
}

#[derive(Copy, Clone)]
pub struct WrappedU8Array<const N: usize>(u8);
impl<const N: usize> BorshSerialize for WrappedU8Array<N> {
    fn serialize<W: Write>(&self, _writer: &mut W) -> borsh::maybestd::io::Result<()> {
        todo!()
    }
}
impl<const N: usize> BorshDeserialize for WrappedU8Array<N> {
    fn deserialize(_buf: &mut &[u8]) -> borsh::maybestd::io::Result<Self> {
        todo!()
    }

    fn deserialize_reader<R: std::io::Read>(_reader: &mut R) -> std::io::Result<Self> {
        todo!()
    }
}
impl<const N: usize> Owner for WrappedU8Array<N> {
    fn owner() -> Pubkey {
        crate::ID
    }
}


================================================
File: lang/tests/macros.rs
================================================
use core::str::FromStr;

use anchor_lang::solana_program::pubkey::Pubkey;

mod id {
    anchor_lang::declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
}

#[test]
fn test_declare_id() {
    let good = Pubkey::from_str("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS").unwrap();
    let bad = Pubkey::from_str("A7yUYJNEVYRLE4QWsnc9rE9JRsm7DfqEmLscQVwkffAk").unwrap();
    assert_eq!(good, id::ID);
    assert_eq!(good, id::id());
    assert!(id::check_id(&good));
    assert!(!id::check_id(&bad));
}

mod pk {
    pub(super) const PUBKEY: anchor_lang::solana_program::pubkey::Pubkey =
        anchor_lang::pubkey!("A7yUYJNEVYRLE4QWsnc9rE9JRsm7DfqEmLscQVwkffAk");
}

#[test]
fn test_pubkey() {
    let want = Pubkey::from_str("A7yUYJNEVYRLE4QWsnc9rE9JRsm7DfqEmLscQVwkffAk");
    assert_eq!(want.unwrap(), pk::PUBKEY);
}


================================================
File: lang/tests/serialization.rs
================================================
use anchor_lang::{AnchorDeserialize, AnchorSerialize, Discriminator, InstructionData};

#[test]
fn test_instruction_data() {
    // Define some test type and implement ser/de, discriminator, and ix data
    #[derive(Default, AnchorSerialize, AnchorDeserialize, PartialEq, Eq)]
    struct MyType {
        foo: [u8; 8],
        bar: String,
    }
    impl Discriminator for MyType {
        const DISCRIMINATOR: &'static [u8] = &[1, 2, 3, 4, 5, 6, 7, 8];
    }
    impl InstructionData for MyType {}

    // Initialize some instance of the type
    let instance = MyType {
        foo: [0, 2, 4, 6, 8, 10, 12, 14],
        bar: "sharding sucks".into(),
    };

    // Serialize using both methods
    let data = instance.data();
    let mut write = vec![];
    instance.write_to(&mut write);

    // Check that one is correct and that they are equal (implies other is correct)
    let correct_disc = &data[0..8] == MyType::DISCRIMINATOR;
    let correct_data = MyType::deserialize(&mut &data[8..]).is_ok_and(|result| result == instance);
    let correct_serialization = correct_disc & correct_data;
    assert!(correct_serialization, "serialization was not correct");
    assert_eq!(
        &data, &write,
        "the different methods produced different serialized representations"
    );
}


================================================
File: spl/Cargo.toml
================================================
[package]
name = "anchor-spl"
version = "0.30.1"
authors = ["Anchor Maintainers <accounts@200ms.io>"]
edition = "2021"
license = "Apache-2.0"
description = "CPI clients for SPL programs"

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
default = ["associated_token", "mint", "token", "token_2022", "token_2022_extensions"]
associated_token = ["spl-associated-token-account"]
devnet = []
governance = []
idl-build = ["anchor-lang/idl-build"]
memo = ["spl-memo"]
metadata = ["mpl-token-metadata"]
mint = []
stake = ["borsh"]
token = ["spl-token"]
token_2022 = ["spl-token-2022"]
token_2022_extensions = ["spl-token-2022", "spl-token-group-interface", "spl-token-metadata-interface", "spl-pod"]

[dependencies]
anchor-lang = { path = "../lang", version = "0.30.1", features = ["derive"] }
borsh = { version = "0.10.3", optional = true }
mpl-token-metadata = { version = "5", optional = true }
spl-associated-token-account = { version = "6", features = ["no-entrypoint"], optional = true }
spl-memo = { version = "6", features = ["no-entrypoint"], optional = true }
spl-token = { version = "7", features = ["no-entrypoint"], optional = true }
spl-token-2022 = { version = "6", features = ["no-entrypoint"], optional = true }
spl-token-group-interface = { version = "0.5", optional = true }
spl-token-metadata-interface = { version = "0.6", optional = true }
spl-pod = { version = "0.5", optional = true }


================================================
File: spl/src/associated_token.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub use spl_associated_token_account;
pub use spl_associated_token_account::{
    get_associated_token_address, get_associated_token_address_with_program_id, ID,
};

pub fn create<'info>(ctx: CpiContext<'_, '_, '_, 'info, Create<'info>>) -> Result<()> {
    let ix = spl_associated_token_account::instruction::create_associated_token_account(
        ctx.accounts.payer.key,
        ctx.accounts.authority.key,
        ctx.accounts.mint.key,
        ctx.accounts.token_program.key,
    );
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.payer,
            ctx.accounts.associated_token,
            ctx.accounts.authority,
            ctx.accounts.mint,
            ctx.accounts.system_program,
            ctx.accounts.token_program,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

pub fn create_idempotent<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, CreateIdempotent<'info>>,
) -> Result<()> {
    let ix = spl_associated_token_account::instruction::create_associated_token_account_idempotent(
        ctx.accounts.payer.key,
        ctx.accounts.authority.key,
        ctx.accounts.mint.key,
        ctx.accounts.token_program.key,
    );
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.payer,
            ctx.accounts.associated_token,
            ctx.accounts.authority,
            ctx.accounts.mint,
            ctx.accounts.system_program,
            ctx.accounts.token_program,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct Create<'info> {
    pub payer: AccountInfo<'info>,
    pub associated_token: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub system_program: AccountInfo<'info>,
    pub token_program: AccountInfo<'info>,
}

type CreateIdempotent<'info> = Create<'info>;

#[derive(Clone)]
pub struct AssociatedToken;

impl anchor_lang::Id for AssociatedToken {
    fn id() -> Pubkey {
        ID
    }
}


================================================
File: spl/src/governance.rs
================================================
/// A macro is exposed so that we can embed the program ID.
#[macro_export]
macro_rules! vote_weight_record {
    ($id:expr) => {
        /// Anchor wrapper for the SPL governance program's VoterWeightRecord type.
        #[derive(Clone)]
        pub struct VoterWeightRecord(spl_governance_addin_api::voter_weight::VoterWeightRecord);

        impl anchor_lang::AccountDeserialize for VoterWeightRecord {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data = buf;
                let vwr: spl_governance_addin_api::voter_weight::VoterWeightRecord =
                    anchor_lang::AnchorDeserialize::deserialize(&mut data)
                        .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize)?;
                if !anchor_lang::solana_program::program_pack::IsInitialized::is_initialized(&vwr) {
                    return Err(anchor_lang::error::ErrorCode::AccountDidNotSerialize.into());
                }
                Ok(VoterWeightRecord(vwr))
            }

            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data = buf;
                let vwr: spl_governance_addin_api::voter_weight::VoterWeightRecord =
                    anchor_lang::AnchorDeserialize::deserialize(&mut data)
                        .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotDeserialize)?;
                Ok(VoterWeightRecord(vwr))
            }
        }

        impl anchor_lang::AccountSerialize for VoterWeightRecord {
            fn try_serialize<W: std::io::Write>(&self, writer: &mut W) -> anchor_lang::Result<()> {
                anchor_lang::AnchorSerialize::serialize(&self.0, writer)
                    .map_err(|_| anchor_lang::error::ErrorCode::AccountDidNotSerialize)?;
                Ok(())
            }
        }

        impl anchor_lang::Owner for VoterWeightRecord {
            fn owner() -> Pubkey {
                $id
            }
        }

        impl std::ops::Deref for VoterWeightRecord {
            type Target = spl_governance_addin_api::voter_weight::VoterWeightRecord;

            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl std::ops::DerefMut for VoterWeightRecord {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }

        #[cfg(feature = "idl-build")]
        impl anchor_lang::IdlBuild for VoterWeightRecord {}

        #[cfg(feature = "idl-build")]
        impl anchor_lang::Discriminator for VoterWeightRecord {
            const DISCRIMINATOR: &'static [u8] = &[];
        }
    };
}


================================================
File: spl/src/idl_build.rs
================================================
/// Crate a default [`anchor_lang::IdlBuild`] implementation for the given type.
///
/// This is used in order to make wrapper accounts of `anchor-spl` work with `idl-build` feature.
macro_rules! impl_idl_build {
    ($ty: ty) => {
        impl anchor_lang::IdlBuild for $ty {}

        // This is not used for the IDL generation since default `IdlBuild` impl doesn't include
        // the type in the IDL but it stil needs to be added in order to make compilation work.
        //
        // TODO: Find a better way to handle discriminators of wrapped external accounts.
        impl anchor_lang::Discriminator for $ty {
            const DISCRIMINATOR: &'static [u8] = &[];
        }
    };
}

#[cfg(feature = "metadata")]
impl_idl_build!(crate::metadata::MetadataAccount);
#[cfg(feature = "metadata")]
impl_idl_build!(crate::metadata::MasterEditionAccount);
#[cfg(feature = "metadata")]
impl_idl_build!(crate::metadata::TokenRecordAccount);

#[cfg(feature = "stake")]
impl_idl_build!(crate::stake::StakeAccount);

impl_idl_build!(crate::token::Mint);
impl_idl_build!(crate::token::TokenAccount);

impl_idl_build!(crate::token_interface::Mint);
impl_idl_build!(crate::token_interface::TokenAccount);


================================================
File: spl/src/lib.rs
================================================
#![cfg_attr(docsrs, feature(doc_auto_cfg))]

//! Anchor CPI wrappers for popular programs in the Solana ecosystem.

#[cfg(feature = "associated_token")]
pub mod associated_token;

#[cfg(feature = "mint")]
pub mod mint;

#[cfg(feature = "token")]
pub mod token;

#[cfg(feature = "token_2022")]
pub mod token_2022;

#[cfg(feature = "token_2022_extensions")]
pub mod token_2022_extensions;

#[cfg(feature = "token_2022")]
pub mod token_interface;

#[cfg(feature = "governance")]
pub mod governance;

#[cfg(feature = "stake")]
pub mod stake;

#[cfg(feature = "metadata")]
pub mod metadata;

#[cfg(feature = "memo")]
pub mod memo;

#[cfg(feature = "idl-build")]
mod idl_build;


================================================
File: spl/src/memo.rs
================================================
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub use spl_memo;
pub use spl_memo::ID;

pub fn build_memo<'info>(ctx: CpiContext<'_, '_, '_, 'info, BuildMemo>, memo: &[u8]) -> Result<()> {
    let ix = spl_memo::build_memo(
        memo,
        &ctx.remaining_accounts
            .iter()
            .map(|account| account.key)
            .collect::<Vec<_>>(),
    );
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &ctx.remaining_accounts,
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct BuildMemo {}

#[derive(Clone)]
pub struct Memo;

impl anchor_lang::Id for Memo {
    fn id() -> Pubkey {
        ID
    }
}


================================================
File: spl/src/mint.rs
================================================
use anchor_lang::declare_id;

pub use srm::ID as SRM;
mod srm {
    use super::*;
    declare_id!("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt");
}

pub use usdc::ID as USDC;
mod usdc {
    use super::*;
    declare_id!("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
}


================================================
File: spl/src/token_interface.rs
================================================
use anchor_lang::__private::bytemuck::Pod;
use anchor_lang::solana_program::program_pack::Pack;
use anchor_lang::solana_program::pubkey::Pubkey;
use spl_token_2022::extension::ExtensionType;
use spl_token_2022::extension::{BaseStateWithExtensions, Extension, StateWithExtensions};
use std::ops::Deref;

pub use crate::token_2022::*;
#[cfg(feature = "token_2022_extensions")]
pub use crate::token_2022_extensions::*;

static IDS: [Pubkey; 2] = [spl_token::ID, spl_token_2022::ID];

#[derive(Clone, Debug, Default, PartialEq, Copy)]
pub struct TokenAccount(spl_token_2022::state::Account);

impl anchor_lang::AccountDeserialize for TokenAccount {
    fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        spl_token_2022::extension::StateWithExtensions::<spl_token_2022::state::Account>::unpack(
            buf,
        )
        .map(|t| TokenAccount(t.base))
        .map_err(Into::into)
    }
}

impl anchor_lang::AccountSerialize for TokenAccount {}

impl anchor_lang::Owners for TokenAccount {
    fn owners() -> &'static [Pubkey] {
        &IDS
    }
}

impl Deref for TokenAccount {
    type Target = spl_token_2022::state::Account;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Clone, Debug, Default, PartialEq, Copy)]
pub struct Mint(spl_token_2022::state::Mint);

impl anchor_lang::AccountDeserialize for Mint {
    fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
        spl_token_2022::extension::StateWithExtensions::<spl_token_2022::state::Mint>::unpack(buf)
            .map(|t| Mint(t.base))
            .map_err(Into::into)
    }
}

impl anchor_lang::AccountSerialize for Mint {}

impl anchor_lang::Owners for Mint {
    fn owners() -> &'static [Pubkey] {
        &IDS
    }
}

impl Deref for Mint {
    type Target = spl_token_2022::state::Mint;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[derive(Clone)]
pub struct TokenInterface;

impl anchor_lang::Ids for TokenInterface {
    fn ids() -> &'static [Pubkey] {
        &IDS
    }
}

pub type ExtensionsVec = Vec<ExtensionType>;

pub fn find_mint_account_size(extensions: Option<&ExtensionsVec>) -> anchor_lang::Result<usize> {
    if let Some(extensions) = extensions {
        Ok(ExtensionType::try_calculate_account_len::<
            spl_token_2022::state::Mint,
        >(extensions)?)
    } else {
        Ok(spl_token_2022::state::Mint::LEN)
    }
}

pub fn get_mint_extension_data<T: Extension + Pod>(
    account: &anchor_lang::solana_program::account_info::AccountInfo,
) -> anchor_lang::Result<T> {
    let mint_data = account.data.borrow();
    let mint_with_extension =
        StateWithExtensions::<spl_token_2022::state::Mint>::unpack(&mint_data)?;
    let extension_data = *mint_with_extension.get_extension::<T>()?;
    Ok(extension_data)
}


================================================
File: spl/src/token_2022_extensions/confidential_transfer.rs
================================================
// waiting for labs to merge


================================================
File: spl/src/token_2022_extensions/confidential_transfer_fee.rs
================================================
// waiting for labs to merge


================================================
File: spl/src/token_2022_extensions/cpi_guard.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn cpi_guard_enable<'info>(ctx: CpiContext<'_, '_, '_, 'info, CpiGuard<'info>>) -> Result<()> {
    let ix = spl_token_2022::extension::cpi_guard::instruction::enable_cpi_guard(
        ctx.accounts.token_program_id.key,
        ctx.accounts.account.key,
        ctx.accounts.account.owner,
        &[],
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.account,
            ctx.accounts.owner,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

pub fn cpi_guard_disable<'info>(ctx: CpiContext<'_, '_, '_, 'info, CpiGuard<'info>>) -> Result<()> {
    let ix = spl_token_2022::extension::cpi_guard::instruction::disable_cpi_guard(
        ctx.accounts.token_program_id.key,
        ctx.accounts.account.key,
        ctx.accounts.account.owner,
        &[],
    )?;

    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.account,
            ctx.accounts.owner,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct CpiGuard<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub account: AccountInfo<'info>,
    pub owner: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/default_account_state.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};
use spl_token_2022::state::AccountState;

pub fn default_account_state_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, DefaultAccountStateInitialize<'info>>,
    state: &AccountState,
) -> Result<()> {
    let ix = spl_token_2022::extension::default_account_state::instruction::initialize_default_account_state(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        state
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct DefaultAccountStateInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}

pub fn default_account_state_update<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, DefaultAccountStateUpdate<'info>>,
    state: &AccountState,
) -> Result<()> {
    let ix = spl_token_2022::extension::default_account_state::instruction::update_default_account_state(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        ctx.accounts.freeze_authority.key,
        &[],
        state
    )?;

    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.mint,
            ctx.accounts.freeze_authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct DefaultAccountStateUpdate<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub freeze_authority: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/group_member_pointer.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn group_member_pointer_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, GroupMemberPointerInitialize<'info>>,
    authority: Option<Pubkey>,
    member_address: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::group_member_pointer::instruction::initialize(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        authority,
        member_address,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct GroupMemberPointerInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}

pub fn group_member_pointer_update<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, GroupMemberPointerUpdate<'info>>,
    member_address: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::group_member_pointer::instruction::update(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        ctx.accounts.authority.key,
        &[],
        member_address,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.mint,
            ctx.accounts.authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct GroupMemberPointerUpdate<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/group_pointer.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn group_pointer_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, GroupPointerInitialize<'info>>,
    authority: Option<Pubkey>,
    group_address: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::group_pointer::instruction::initialize(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        authority,
        group_address,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct GroupPointerInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}

pub fn group_pointer_update<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, GroupPointerUpdate<'info>>,
    group_address: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::group_pointer::instruction::update(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        ctx.accounts.authority.key,
        &[ctx.accounts.authority.key],
        group_address,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct GroupPointerUpdate<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/immutable_owner.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn immutable_owner_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, ImmutableOwnerInitialize<'info>>,
) -> Result<()> {
    let ix = spl_token_2022::instruction::initialize_immutable_owner(
        ctx.accounts.token_program_id.key,
        ctx.accounts.token_account.key,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.token_account],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct ImmutableOwnerInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub token_account: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/interest_bearing_mint.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn interest_bearing_mint_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, InterestBearingMintInitialize<'info>>,
    rate_authority: Option<Pubkey>,
    rate: i16,
) -> Result<()> {
    let ix = spl_token_2022::extension::interest_bearing_mint::instruction::initialize(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        rate_authority,
        rate,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct InterestBearingMintInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}

pub fn interest_bearing_mint_update_rate<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, InterestBearingMintUpdateRate<'info>>,
    rate: i16,
) -> Result<()> {
    let ix = spl_token_2022::extension::interest_bearing_mint::instruction::update_rate(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        ctx.accounts.rate_authority.key,
        &[],
        rate,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.mint,
            ctx.accounts.rate_authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct InterestBearingMintUpdateRate<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub rate_authority: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/memo_transfer.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn memo_transfer_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, MemoTransfer<'info>>,
) -> Result<()> {
    let ix = spl_token_2022::extension::memo_transfer::instruction::enable_required_transfer_memos(
        ctx.accounts.token_program_id.key,
        ctx.accounts.account.key,
        ctx.accounts.owner.key,
        &[],
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.account,
            ctx.accounts.owner,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

pub fn memo_transfer_disable<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, MemoTransfer<'info>>,
) -> Result<()> {
    let ix =
        spl_token_2022::extension::memo_transfer::instruction::disable_required_transfer_memos(
            ctx.accounts.token_program_id.key,
            ctx.accounts.account.key,
            ctx.accounts.owner.key,
            &[],
        )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.account,
            ctx.accounts.owner,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct MemoTransfer<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub account: AccountInfo<'info>,
    pub owner: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/metadata_pointer.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn metadata_pointer_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, MetadataPointerInitialize<'info>>,
    authority: Option<Pubkey>,
    metadata_address: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::metadata_pointer::instruction::initialize(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        authority,
        metadata_address,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct MetadataPointerInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/mint_close_authority.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn mint_close_authority_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, MintCloseAuthorityInitialize<'info>>,
    authority: Option<&Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::instruction::initialize_mint_close_authority(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        authority,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct MintCloseAuthorityInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/mod.rs
================================================
pub mod confidential_transfer;
pub mod confidential_transfer_fee;
pub mod cpi_guard;
pub mod default_account_state;
pub mod group_member_pointer;
pub mod group_pointer;
pub mod immutable_owner;
pub mod interest_bearing_mint;
pub mod memo_transfer;
pub mod metadata_pointer;
pub mod mint_close_authority;
pub mod non_transferable;
pub mod permanent_delegate;
pub mod token_group;
pub mod token_metadata;
pub mod transfer_fee;
pub mod transfer_hook;

pub use cpi_guard::*;
pub use default_account_state::*;
pub use group_member_pointer::*;
pub use group_pointer::*;
pub use immutable_owner::*;
pub use interest_bearing_mint::*;
pub use memo_transfer::*;
pub use metadata_pointer::*;
pub use mint_close_authority::*;
pub use non_transferable::*;
pub use permanent_delegate::*;
pub use token_group::*;
pub use token_metadata::*;
pub use transfer_fee::*;
pub use transfer_hook::*;

pub use spl_pod;
pub use spl_token_metadata_interface;


================================================
File: spl/src/token_2022_extensions/non_transferable.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn non_transferable_mint_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, NonTransferableMintInitialize<'info>>,
) -> Result<()> {
    let ix = spl_token_2022::instruction::initialize_non_transferable_mint(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct NonTransferableMintInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/permanent_delegate.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn permanent_delegate_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, PermanentDelegateInitialize<'info>>,
    permanent_delegate: &Pubkey,
) -> Result<()> {
    let ix = spl_token_2022::instruction::initialize_permanent_delegate(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        permanent_delegate,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct PermanentDelegateInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/token_group.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn token_group_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, TokenGroupInitialize<'info>>,
    update_authority: Option<Pubkey>,
    max_size: u64,
) -> Result<()> {
    let ix = spl_token_group_interface::instruction::initialize_group(
        ctx.accounts.program_id.key,
        ctx.accounts.group.key,
        ctx.accounts.mint.key,
        ctx.accounts.mint_authority.key,
        update_authority,
        max_size,
    );
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.program_id,
            ctx.accounts.group,
            ctx.accounts.mint,
            ctx.accounts.mint_authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct TokenGroupInitialize<'info> {
    pub program_id: AccountInfo<'info>,
    pub group: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub mint_authority: AccountInfo<'info>,
}

pub fn token_member_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, TokenMemberInitialize<'info>>,
) -> Result<()> {
    let ix = spl_token_group_interface::instruction::initialize_member(
        ctx.accounts.program_id.key,
        ctx.accounts.member.key,
        ctx.accounts.member_mint.key,
        ctx.accounts.member_mint_authority.key,
        ctx.accounts.group.key,
        ctx.accounts.group_update_authority.key,
    );
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.program_id,
            ctx.accounts.member,
            ctx.accounts.member_mint,
            ctx.accounts.member_mint_authority,
            ctx.accounts.group,
            ctx.accounts.group_update_authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct TokenMemberInitialize<'info> {
    pub program_id: AccountInfo<'info>,
    pub member: AccountInfo<'info>,
    pub member_mint: AccountInfo<'info>,
    pub member_mint_authority: AccountInfo<'info>,
    pub group: AccountInfo<'info>,
    pub group_update_authority: AccountInfo<'info>,
}


================================================
File: spl/src/token_2022_extensions/transfer_hook.rs
================================================
use anchor_lang::solana_program::account_info::AccountInfo;
use anchor_lang::solana_program::pubkey::Pubkey;
use anchor_lang::Result;
use anchor_lang::{context::CpiContext, Accounts};

pub fn transfer_hook_initialize<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, TransferHookInitialize<'info>>,
    authority: Option<Pubkey>,
    transfer_hook_program_id: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::transfer_hook::instruction::initialize(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        authority,
        transfer_hook_program_id,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[ctx.accounts.token_program_id, ctx.accounts.mint],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct TransferHookInitialize<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
}

pub fn transfer_hook_update<'info>(
    ctx: CpiContext<'_, '_, '_, 'info, TransferHookUpdate<'info>>,
    transfer_hook_program_id: Option<Pubkey>,
) -> Result<()> {
    let ix = spl_token_2022::extension::transfer_hook::instruction::update(
        ctx.accounts.token_program_id.key,
        ctx.accounts.mint.key,
        ctx.accounts.authority.key,
        &[],
        transfer_hook_program_id,
    )?;
    anchor_lang::solana_program::program::invoke_signed(
        &ix,
        &[
            ctx.accounts.token_program_id,
            ctx.accounts.mint,
            ctx.accounts.authority,
        ],
        ctx.signer_seeds,
    )
    .map_err(Into::into)
}

#[derive(Accounts)]
pub struct TransferHookUpdate<'info> {
    pub token_program_id: AccountInfo<'info>,
    pub mint: AccountInfo<'info>,
    pub authority: AccountInfo<'info>,
}


================================================
File: tests/README.md
================================================
# Tests

No program here is guaranteed to be safe or secure in any way. In most cases, they are
simply just simple integration tests to illustrate some particular functionality
of the framework. If used, one should audit any programs used and take full
responsibility for the consequences that occur due to any outstanding bugs
or security vulnerabilities that exist.


================================================
File: tests/package.json
================================================
{
  "name": "anchor-tests",
  "private": true,
  "scripts": {
    "lint:fix": "prettier */*.js \"*/**/*{.js,.ts}\" -w",
    "lint": "prettier */*.js \"*/**/*{.js,.ts}\" --check"
  },
  "workspaces": [
    "anchor-cli-account",
    "anchor-cli-idl",
    "auction-house",
    "bench",
    "cashiers-check",
    "cfo",
    "chat",
    "composite",
    "custom-coder",
    "custom-discriminator",
    "declare-id",
    "declare-program",
    "errors",
    "escrow",
    "events",
    "floats",
    "idl",
    "ido-pool",
    "interface",
    "lazy-account",
    "lockup",
    "misc",
    "multisig",
    "optional",
    "permissioned-markets",
    "pda-derivation",
    "relations-derivation",
    "pyth",
    "realloc",
    "spl/metadata",
    "spl/token-extensions",
    "spl/token-proxy",
    "spl/token-wrapper",
    "spl/transfer-hook",
    "swap",
    "system-accounts",
    "sysvars",
    "tictactoe",
    "typescript",
    "validator-clone",
    "zero-copy",
    "cpi-returns",
    "multiple-suites",
    "multiple-suites-run-single",
    "bpf-upgradeable-state",
    "solang"
  ],
  "dependencies": {
    "@project-serum/common": "^0.0.1-beta.3",
    "@project-serum/serum": "^0.13.60",
    "@solana/spl-token": "^0.1.8",
    "@solana/web3.js": "^1.68.0"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.1",
    "@types/chai": "^4.3.0",
    "@types/mocha": "^9.1.0",
    "@types/node": "^14.14.37",
    "chai": "^4.3.4",
    "mocha": "9.2.2",
    "prettier": "^2.5.1",
    "ts-mocha": "^10.0.0",
    "tsc": "^2.0.4",
    "typescript": "^4.4.4"
  }
}


================================================
File: tests/.prettierignore
================================================
**/target/types/*.ts
cfo/deps/
swap/deps/
auction-house/deps/

================================================
File: tests/anchor-cli-account/Anchor.toml
================================================
[programs.localnet]
account_command = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[features]


================================================
File: tests/anchor-cli-account/Cargo.toml
================================================
[profile.release]
overflow-checks = true

[workspace]
members = [
    "programs/*"
]
resolver = "2"


================================================
File: tests/anchor-cli-account/package.json
================================================
{
  "name": "anchor-cli-account",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/anchor-cli-account/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/anchor-cli-account/programs/account-command/Cargo.toml
================================================
[package]
name = "account-command"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "account_command"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/anchor-cli-account/programs/account-command/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/anchor-cli-account/programs/account-command/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod account_command {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        balance: f32,
        amount: u32,
        memo: String,
        values: Vec<u128>,
    ) -> Result<()> {
        let my_account = &mut ctx.accounts.my_account;

        my_account.balance = balance;
        my_account.delegate_pubkey = ctx.accounts.user.key().clone();
        my_account.sub = Sub {
            values,
            state: State::Confirmed { amount, memo },
        };

        Ok(())
    }
}

#[derive(Clone, AnchorDeserialize, AnchorSerialize)]
pub enum State {
    Pending,
    Confirmed { amount: u32, memo: String },
}

#[derive(Clone, AnchorDeserialize, AnchorSerialize)]
pub struct Sub {
    pub values: Vec<u128>,
    pub state: State,
}

#[account]
pub struct MyAccount {
    pub balance: f32,
    pub delegate_pubkey: Pubkey,
    pub sub: Sub,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 1000)]
    pub my_account: Account<'info, MyAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}


================================================
File: tests/anchor-cli-account/tests/account.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { AccountCommand } from "../target/types/account_command";
import { assert } from "chai";
import { execSync } from "child_process";
import { sleep } from "@project-serum/common";

describe("Test CLI account commands", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();

  anchor.setProvider(provider);

  const program = anchor.workspace.AccountCommand as Program<AccountCommand>;

  it("Can fetch and deserialize account using the account command", async () => {
    const myAccount = anchor.web3.Keypair.generate();

    const balance = -2.5;
    const amount = 108;
    const memo = "account test";
    const values = [1, 2, 3, 1000];

    await program.methods
      .initialize(
        balance,
        new anchor.BN(amount),
        memo,
        values.map((x) => new anchor.BN(x))
      )
      .accounts({
        myAccount: myAccount.publicKey,
        user: provider.wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([myAccount])
      .rpc();

    let output: any = {};
    for (let tries = 0; tries < 20; tries++) {
      try {
        output = JSON.parse(
          execSync(
            `anchor account account_command.MyAccount ${myAccount.publicKey}`,
            { stdio: "pipe" }
          ).toString()
        );
        break;
      } catch (e) {
        if (!e.stderr.toString().startsWith("Error: AccountNotFound")) {
          throw e;
        }
      }

      await sleep(5000);
    }

    assert(output.balance === balance, "Balance deserialized incorrectly");
    assert(
      output.delegate_pubkey === provider.wallet.publicKey.toBase58(),
      "delegatePubkey deserialized incorrectly"
    );
    assert(
      output.sub.state.Confirmed.amount === amount,
      "Amount deserialized incorrectly"
    );
    assert(
      output.sub.state.Confirmed.memo === memo,
      "Memo deserialized incorrectly"
    );
    for (let i = 0; i < values.length; i++) {
      assert(
        output.sub.values[i] == values[i],
        "Values deserialized incorrectly"
      );
    }
  });
});


================================================
File: tests/anchor-cli-idl/Anchor.toml
================================================
[features]
seeds = false

[programs.localnet]
idl_commands_one = "2uA3amp95zsEHUpo8qnLMhcFAUsiKVEcKHXS1JetFjU5"
idl_commands_two = "DE4UbHnAcT6Kfh1fVTPRPwpiA3vipmQ4xR3gcLwX3wwS"

[provider]
cluster = "localnet"
wallet = "./keypairs/deployer-keypair.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/anchor-cli-idl/Cargo.toml
================================================
[profile.release]
overflow-checks = true

[workspace]
members = [
    "programs/*"
]
resolver = "2"


================================================
File: tests/anchor-cli-idl/package.json
================================================
{
  "name": "anchor-cli-idl",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "./test.sh"
  },
  "dependencies": {
    "mocha": "9.2.2"
  }
}


================================================
File: tests/anchor-cli-idl/test.sh
================================================
#!/bin/bash

# Write a keypair for program deploy
mkdir -p target/deploy
cp keypairs/idl_commands_one-keypair.json target/deploy
# Generate over 20kb bytes of random data (base64 encoded), surround it with quotes, and store it in a variable
RANDOM_DATA=$(openssl rand -base64 $((10*1680)) | sed 's/.*/"&",/')

# Create the JSON object with the "docs" field containing random data
echo '{
  "address": "2uA3amp95zsEHUpo8qnLMhcFAUsiKVEcKHXS1JetFjU5",
  "metadata": {
    "name": "idl_commands_one",
    "version": "0.1.0",
    "spec": "0.1.0"
  },
  "instructions": [
    {
      "name": "initialize",
      "docs" : [
        '"$RANDOM_DATA"'
        "trailing comma begone"
      ],
      "discriminator": [],
      "accounts": [],
      "args": []
    }
  ]
}' > testLargeIdl.json



echo "Building programs"

anchor build

echo "Starting local validator for test"

solana-test-validator --reset \
  -q \
  --mint tgyXxAhCkpgtKCEi4W6xWJSzqwVGs3uk2RodbZP2J49 \
  --bpf-program 2uA3amp95zsEHUpo8qnLMhcFAUsiKVEcKHXS1JetFjU5 target/deploy/idl_commands_one.so \
  --bpf-program DE4UbHnAcT6Kfh1fVTPRPwpiA3vipmQ4xR3gcLwX3wwS target/deploy/idl_commands_one.so \
  &

sleep 10

echo "Running tests"

anchor test --skip-deploy --skip-local-validator

trap "trap - SIGTERM && kill -- -$$" SIGINT SIGTERM EXIT

================================================
File: tests/anchor-cli-idl/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/anchor-cli-idl/keypairs/deployer-keypair.json
================================================
[164,152,29,200,163,125,1,132,86,139,100,111,64,167,29,222,179,216,47,111,217,86,2,178,218,42,72,47,0,153,173,236,13,61,210,33,74,223,99,110,68,220,145,123,246,228,31,59,49,171,192,81,98,88,48,234,139,75,103,103,37,74,182,34]

================================================
File: tests/anchor-cli-idl/keypairs/idl_commands_one-keypair.json
================================================
[94,216,182,223,16,41,49,136,185,3,66,213,109,246,240,174,89,197,124,116,127,169,30,24,121,73,68,181,56,13,95,164,28,56,29,156,175,177,255,55,3,211,19,248,245,194,166,177,104,58,249,124,97,88,18,11,252,61,240,174,10,218,5,202]

================================================
File: tests/anchor-cli-idl/keypairs/idl_commands_two-keypair.json
================================================
[97,131,36,142,66,37,137,233,196,84,65,128,4,46,96,251,52,1,254,169,72,193,88,186,252,19,204,232,29,55,2,86,181,164,185,63,247,168,27,24,156,83,149,184,17,138,206,99,52,0,13,42,107,119,126,35,251,52,134,231,178,93,7,29]

================================================
File: tests/anchor-cli-idl/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/anchor-cli-idl/programs/idl-commands-one/Cargo.toml
================================================
[package]
name = "idl-commands-one"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "idl_commands_one"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/anchor-cli-idl/programs/idl-commands-one/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/anchor-cli-idl/programs/idl-commands-one/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("2uA3amp95zsEHUpo8qnLMhcFAUsiKVEcKHXS1JetFjU5");

#[program]
pub mod idl_commands_one {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/anchor-cli-idl/programs/idl-commands-two/Cargo.toml
================================================
[package]
name = "idl-commands-two"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "idl_commands_two"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/anchor-cli-idl/programs/idl-commands-two/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/anchor-cli-idl/programs/idl-commands-two/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("DE4UbHnAcT6Kfh1fVTPRPwpiA3vipmQ4xR3gcLwX3wwS");

#[program]
pub mod idl_commands_two {
    use super::*;

    pub fn uninitialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/auction-house/Anchor.toml
================================================
[features]
seeds = true

[programs.localnet]
auction_house = "hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk"

[programs.devnet]
auction_house = "hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk"

[programs.mainnet]
auction_house = "hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[[test.genesis]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
program = "./prebuilt-programs/metaplex_token_metadata.so"


================================================
File: tests/auction-house/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/auction-house/package.json
================================================
{
  "name": "auction-house",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint"
  },
  "dependencies": {
    "@metaplex/js": "^4.4.1"
  }
}


================================================
File: tests/auction-house/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "node"],
    "lib": ["es2020"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  }
}


================================================
File: tests/auction-house/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/auction-house/programs/auction-house/Cargo.toml
================================================
[package]
name = "auction-house"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "lib"]
name = "auction_house"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl", features = ["metadata"] }
thiserror = "1.0"
arrayref = "0.3.6"


================================================
File: tests/auction-house/programs/auction-house/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/bench/README.md
================================================
# Benchmark tests

The bench program and its tests are used to measure the performance of Anchor programs.

## How

We run the same tests that measure some metric for each Anchor version starting from `0.27.0`. If the difference between the results is greater than 1%, the new data will be saved in `bench.json` and Markdown files in [/bench](https://github.com/coral-xyz/anchor/tree/master/bench) will be updated accordingly.

## Scripts

| :memo: TL;DR                                                                                                                   |
| :----------------------------------------------------------------------------------------------------------------------------- |
| If you've made changes to programs or tests in this directory, run `anchor run sync`, otherwise run `anchor test --skip-lint`. |

`anchor test --skip-lint`: Run all tests and update benchmark files when necessary. This is the only command that needs to be run for most use cases.

---

The following scripts are useful when making changes to how benchmarking works.

`anchor run sync`: Sync all benchmark files by running tests for each version. If you've made changes to the bench program or its tests, you should run this command to sync the results.

`anchor run sync-markdown`: Sync Markdown files in [/bench](https://github.com/coral-xyz/anchor/tree/master/bench) based on the data from `bench.json`.

`anchor run generate-ix`: Generate program instructions with repetitive accounts.

---

The following script is only for the maintainer(s) of Anchor.

`anchor run bump-version -- --anchor-version <VERSION>`: Bump the version in all benchmark files.


================================================
File: tests/bench/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
bench = "Bench11111111111111111111111111111111111111"

[workspace]
members = ["programs/bench"]

[scripts]
test = "yarn run ts-mocha -t 1000000 -p ./tsconfig.json tests/**/*.ts"
sync = "yarn run ts-node scripts/sync.ts"
sync-markdown = "yarn run ts-node scripts/sync-markdown.ts"
generate-ix = "yarn run ts-node scripts/generate-ix.ts"
bump-version = "yarn run ts-node scripts/bump-version.ts"


================================================
File: tests/bench/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/bench/package.json
================================================
{
  "name": "bench",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint"
  }
}


================================================
File: tests/bench/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "node"],
    "lib": ["es2020"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  }
}


================================================
File: tests/bench/programs/bench/Cargo.toml
================================================
[package]
name = "bench"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/bench/programs/bench/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/bench/scripts/bump-version.ts
================================================
/**
 * Bump the version of all benchmark related files by changing the `Unreleased`
 * version to a new version and adding a new `Unreleased` version.
 */

import {
  ANCHOR_VERSION_ARG,
  BenchData,
  LockFile,
  getVersionFromArgs,
} from "./utils";

(async () => {
  const newVersion = getVersionFromArgs();

  if (newVersion === "unreleased") {
    console.error(
      `Usage: anchor run bump-version -- ${ANCHOR_VERSION_ARG} <VERSION>`
    );
    process.exitCode = 1;
    return;
  }

  // Cache lock file in ./locks
  await LockFile.cache(newVersion);

  // Bump bench data
  const bench = await BenchData.open();
  bench.bumpVersion(newVersion);
  await bench.save();

  // Bump markdown files
  await BenchData.forEachMarkdown((markdown) => {
    markdown.bumpVersion(newVersion);
  });
})();


================================================
File: tests/bench/scripts/sync-markdown.ts
================================================
/** Sync Markdown files in /bench based on the data from bench.json */

import { BenchData, BenchResult, Markdown, formatNumber } from "./utils";

(async () => {
  const bench = await BenchData.open();

  await BenchData.forEachMarkdown((markdown, fileName) => {
    const resultType = fileName
      .toLowerCase()
      .replace(".md", "")
      .replace(/_\w/g, (match) => match[1].toUpperCase()) as keyof BenchResult;

    const versions = bench.getVersions();

    // On the first version, compare with itself to update it with no changes
    versions.unshift(versions[0]);

    for (const i in versions) {
      const currentVersion = versions[i];
      if (currentVersion === "unreleased") return;

      const nextVersion = versions[+i + 1];
      const newData = bench.get(nextVersion);
      const oldData = bench.get(currentVersion);

      // Create table
      const table = Markdown.createTable();

      bench.compare({
        newResult: newData.result[resultType],
        oldResult: oldData.result[resultType],
        changeCb: ({ name, newValue, oldValue }) => {
          if (newValue === null) {
            // Deleted key
            return;
          }

          let changeText: string;
          if (oldValue === null) {
            // New key
            changeText = "N/A";
          } else {
            const delta = formatNumber(newValue - oldValue);
            const percentChange = ((newValue / oldValue - 1) * 100).toFixed(2);

            if (+percentChange > 0) {
              changeText = `🔴 **+${delta} (${percentChange}%)**`;
            } else {
              changeText = `🟢 **${delta} (${percentChange.slice(1)}%)**`;
            }
          }

          table.insert(name, formatNumber(newValue), changeText);
        },
        noChangeCb: ({ name, value }) => {
          table.insert(name, formatNumber(value), +i === 0 ? "N/A" : "-");
        },
      });

      // Update version data
      markdown.updateVersion({
        version: nextVersion,
        solanaVersion: newData.solanaVersion,
        table,
      });
    }
  });
})();


================================================
File: tests/bench/scripts/sync.ts
================================================
/**
 * Sync all saved data by re-running the tests for each version.
 *
 * This script should be used when the bench program or its tests has changed
 * and all data needs to be updated.
 */

import path from "path";

import {
  ANCHOR_VERSION_ARG,
  BenchData,
  LockFile,
  Toml,
  VersionManager,
  runAnchorTest,
  spawn,
} from "./utils";

(async () => {
  const bench = await BenchData.open();

  const cargoToml = await Toml.open(
    path.join("..", "programs", "bench", "Cargo.toml")
  );
  const anchorToml = await Toml.open(path.join("..", "Anchor.toml"));

  for (const version of bench.getVersions()) {
    console.log(`Updating '${version}'...`);

    const isUnreleased = version === "unreleased";

    // Use the lock file from cache
    await LockFile.replace(version);

    // Set active solana version
    VersionManager.setSolanaVersion(bench.get(version).solanaVersion);

    // Update the anchor dependency versions
    for (const dependency of ["lang", "spl"]) {
      cargoToml.replaceValue(`anchor-${dependency}`, () => {
        return isUnreleased
          ? `{ path = "../../../../${dependency}" }`
          : `"${version}"`;
      });
    }

    // Save Cargo.toml
    await cargoToml.save();

    // Update `anchor test` command to pass version in Anchor.toml
    anchorToml.replaceValue(
      "test",
      (cmd) => {
        return cmd.includes(ANCHOR_VERSION_ARG)
          ? cmd.replace(
              new RegExp(`\\s*${ANCHOR_VERSION_ARG}\\s+(.+)`),
              (arg, ver) => (isUnreleased ? "" : arg.replace(ver, version))
            )
          : `${cmd} ${ANCHOR_VERSION_ARG} ${version}`;
      },
      { insideQuotes: true }
    );

    // Save Anchor.toml
    await anchorToml.save();

    // Run the command to update the current version's results
    const result = runAnchorTest();

    // Check failure
    if (result.status !== 0) {
      console.error("Please fix the error and re-run this command.");
      process.exitCode = 1;
      return;
    }
  }

  // Sync markdown files
  spawn("anchor", ["run", "sync-markdown"]);
})();


================================================
File: tests/bench/tests/binary-size.ts
================================================
import * as fs from "fs/promises";
import path from "path";

import { BenchData, BinarySize } from "../scripts/utils";

const IDL = require("../target/idl/bench.json");

describe("Binary size", () => {
  const binarySize: BinarySize = {};

  it("Measure binary size", async () => {
    const stat = await fs.stat(
      path.join("target", "deploy", `${IDL.metadata.name}.so`)
    );
    binarySize[IDL.metadata.name] = stat.size;
  });

  after(async () => {
    const bench = await BenchData.open();
    await bench.update({ binarySize });
  });
});


================================================
File: tests/bench/tests/stack-memory.ts
================================================
import path from "path";
import fs from "fs/promises";

import { BenchData, StackMemory, spawn } from "../scripts/utils";

const IDL = require("../target/idl/bench.json");

describe("Stack memory", () => {
  const stackMemory: StackMemory = {};

  const STACK_CONTENT = [
    "",
    `let stack_limit: [u16; 2048] = [1; 2048];`,
    `msg!("{}", stack_limit[2047]);`,
    "",
  ].join("\n\t\t");

  it("Measure stack memory usage", async () => {
    const libPath = path.join("programs", IDL.metadata.name, "src", "lib.rs");
    const lib = await fs.readFile(libPath, "utf8");
    const indices = [...lib.matchAll(/fn\s[\w\d]+\(/g)]
      .map((match) => match.index)
      .filter(Boolean) as number[];

    let modifiedLib = lib;
    let cumulativeIndex = 0;

    for (const index of indices) {
      const curlyIndex = index + lib.slice(index).indexOf("{");
      const nextLineIndex =
        curlyIndex + lib.slice(curlyIndex).indexOf("\n") + cumulativeIndex;
      modifiedLib =
        modifiedLib.slice(0, nextLineIndex) +
        STACK_CONTENT +
        modifiedLib.slice(nextLineIndex);

      cumulativeIndex += STACK_CONTENT.length;
    }

    // Write the modified file
    await fs.writeFile(libPath, modifiedLib);

    // Expected error:
    // Error: Function _ZN5bench9__private8__global13account_info117h88e5c10f03de9fddE
    // Stack offset of 4424 exceeded max offset of 4096 by 328 bytes
    const buildResult = spawn("anchor", ["build", "--skip-lint"]);
    const output = buildResult.output.toString();
    const matches = output.matchAll(
      /global[\d]+([\w\d]+?)17.*by\s(\d+)\sbytes/g
    );
    for (const match of matches) {
      const ixName = match[1];
      const stackUsage = match[2];
      stackMemory[ixName] = +stackUsage;
    }

    // Restore to the original file
    await fs.writeFile(libPath, lib);
  });

  after(async () => {
    const bench = await BenchData.open();
    await bench.update({ stackMemory });
  });
});


================================================
File: tests/bpf-upgradeable-state/Anchor.toml
================================================
[programs.localnet]
bpf_upgradeable_state = "Cum9tTyj5HwcEiAmhgaS7Bbj4UczCwsucrCkxRECzM4e"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/bpf-upgradeable-state/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/bpf-upgradeable-state/bpf_upgradeable_state-keypair.json
================================================
[114,99,192,17,48,208,90,184,231,46,220,91,47,115,132,253,218,163,228,101,8,121,220,138,41,140,176,127,254,91,51,28,176,244,174,182,223,57,57,125,117,201,31,213,9,39,207,212,100,173,88,252,61,235,89,156,53,86,4,90,16,251,191,219]

================================================
File: tests/bpf-upgradeable-state/package.json
================================================
{
  "name": "bpf-upgradeable-state",
  "version": "0.24.0",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/bpf-upgradeable-state/program_with_different_programdata.json
================================================
[86,234,116,86,82,140,116,250,254,32,75,217,35,39,9,238,39,98,242,254,25,216,201,66,1,239,93,12,81,19,34,108,219,67,158,98,245,234,81,126,228,157,205,206,130,5,14,54,1,21,88,246,128,124,240,93,157,49,102,19,253,19,205,178]

================================================
File: tests/bpf-upgradeable-state/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/bpf-upgradeable-state/.gitignore
================================================
yarn.lock


================================================
File: tests/bpf-upgradeable-state/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/Cargo.toml
================================================
[package]
name = "bpf-upgradeable-state"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "bpf_upgradeable_state"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/bpf-upgradeable-state/programs/bpf-upgradeable-state/src/lib.rs
================================================
use anchor_lang::prelude::*;

use crate::program::BpfUpgradeableState;

declare_id!("Cum9tTyj5HwcEiAmhgaS7Bbj4UczCwsucrCkxRECzM4e");

#[program]
pub mod bpf_upgradeable_state {
    use super::*;
    pub fn set_admin_settings(ctx: Context<SetAdminSettings>, admin_data: u64) -> Result<()> {
        match *ctx.accounts.program {
            UpgradeableLoaderState::Program {
                programdata_address,
            } => {
                if programdata_address != ctx.accounts.program_data.key() {
                    return err!(CustomError::InvalidProgramDataAddress);
                }
            }
            _ => {
                return err!(CustomError::AccountNotProgram);
            }
        };
        ctx.accounts.settings.admin_data = admin_data;
        Ok(())
    }

    pub fn set_admin_settings_use_program_state(
        ctx: Context<SetAdminSettingsUseProgramState>,
        admin_data: u64,
    ) -> Result<()> {
        ctx.accounts.settings.admin_data = admin_data;
        Ok(())
    }
}

#[account]
pub struct Settings {
    admin_data: u64,
}

impl Settings {
    pub const LEN: usize = 8;
}

#[error_code]
pub enum CustomError {
    InvalidProgramDataAddress,
    AccountNotProgram,
    AccountNotBpfUpgradableProgram,
}

#[derive(Accounts)]
pub struct SetAdminSettings<'info> {
    // In a real program, this should be a PDA,
    // so the authority cannot create multiple settings accounts.
    // Not done here for easier testing
    #[account(init, payer = authority, space = Settings::LEN + 8)]
    pub settings: Account<'info, Settings>,
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(address = crate::ID)]
    pub program: Account<'info, UpgradeableLoaderState>,
    #[account(constraint = program_data.upgrade_authority_address == Some(authority.key()))]
    pub program_data: Account<'info, ProgramData>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SetAdminSettingsUseProgramState<'info> {
    // In a real program, this should be a PDA,
    // so the authority cannot create multiple settings accounts.
    // Not done here for easier testing
    #[account(init, payer = authority, space = Settings::LEN + 8)]
    pub settings: Account<'info, Settings>,
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(constraint = program.programdata_address()? == Some(program_data.key()))]
    pub program: Program<'info, BpfUpgradeableState>,
    #[account(constraint = program_data.upgrade_authority_address == Some(authority.key()))]
    pub program_data: Account<'info, ProgramData>,
    pub system_program: Program<'info, System>,
}


================================================
File: tests/cashiers-check/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
cashiers_check = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/cashiers-check/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/cashiers-check/package.json
================================================
{
  "name": "cashiers-check",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/cashiers-check/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/cashiers-check/programs/cashiers-check/Cargo.toml
================================================
[package]
name = "cashiers-check"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "cashiers_check"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/cashiers-check/programs/cashiers-check/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/cfo/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
cfo = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
registry = { address = "GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv", idl = "./deps/stake/target/idl/registry.json" }
lockup = { address = "6ebQNeTPZ1j7k3TtkCCtEPRvG7GQsucQrZ7sSEDQi9Ks", idl = "./deps/stake/target/idl/lockup.json" }

[scripts]
#
# Testing.
#
test = "yarn run mocha -t 1000000 tests/"
test-with-build = "anchor run build && anchor test --skip-build --skip-lint"
#
# Build the program and all CPI dependencies.
#
build = "anchor run build-deps && anchor build --skip-lint"
build-deps = "anchor run build-dex && anchor run build-swap && anchor run build-stake"
build-dex = "pushd deps/openbook-dex/dex/ && cargo build-bpf && popd"
build-swap = "cd deps/swap && pwd && anchor build --skip-lint && cd ../../"
build-stake = "pushd deps/stake && anchor build --skip-lint && popd"
#
# Runs a localnet with all the programs deployed.
#
localnet = "./scripts/localnet.sh"

[[test.genesis]]
address = "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"
program = "./deps/openbook-dex/dex/target/deploy/serum_dex.so"

[[test.genesis]]
address = "22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD"
program = "./deps/swap/target/deploy/swap.so"

[[test.genesis]]
address = "GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv"
program = "./deps/stake/target/deploy/registry.so"

[[test.genesis]]
address = "6ebQNeTPZ1j7k3TtkCCtEPRvG7GQsucQrZ7sSEDQi9Ks"
program = "./deps/stake/target/deploy/lockup.so"

[features]


================================================
File: tests/cfo/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
exclude = [
    "deps/openbook-dex",
    "deps/stake",
    "deps/swap"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/cfo/package.json
================================================
{
  "name": "cfo",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor run test-with-build"
  }
}


================================================
File: tests/cfo/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/cfo/programs/cfo/Cargo.toml
================================================
[package]
name = "cfo"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "cfo"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = ["test"]
test = []

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }
spl-token = { version = "3.5.0", features = ["no-entrypoint"] }
swap = { path = "../../deps/swap/programs/swap", features = ["cpi"] }
serum_dex = { path = "../../deps/openbook-dex/dex", features = ["no-entrypoint"] }
registry = { path = "../../deps/stake/programs/registry", features = ["cpi"] }
lockup = { path = "../../deps/stake/programs/lockup", features = ["cpi"] }


================================================
File: tests/cfo/programs/cfo/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/cfo/scripts/common.sh
================================================
cleanup() {
    pkill -P $$ || true
    wait || true
}

trap_add() {
    trap_add_cmd=$1; shift || fatal "${FUNCNAME} usage error"
    for trap_add_name in "$@"; do
        trap -- "$(
            extract_trap_cmd() { printf '%s\n' "${3:-}"; }
            eval "extract_trap_cmd $(trap -p "${trap_add_name}")"
            printf '%s\n' "${trap_add_cmd}"
        )" "${trap_add_name}" \
            || fatal "unable to add to trap ${trap_add_name}"
    done
}

declare -f -t trap_add
trap_add 'cleanup' EXIT


================================================
File: tests/cfo/scripts/fees.js
================================================
#!/usr/bin/env node

const process = require("process");
const fs = require("fs");
const anchor = require("@coral-xyz/anchor");
const { Market, OpenOrders } = require("@project-serum/serum");
const Account = anchor.web3.Account;
const Program = anchor.Program;
const provider = anchor.AnchorProvider.local();
const secret = JSON.parse(fs.readFileSync("./scripts/market-maker.json"));
const MARKET_MAKER = new Account(secret);
const PublicKey = anchor.web3.PublicKey;

const DEX_PID = new PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX");

async function main() {
  const market = new PublicKey(process.argv[2]);
  while (true) {
    let marketClient = await Market.load(
      provider.connection,
      market,
      { commitment: "processed" },
      DEX_PID
    );
    console.log("Fees: ", marketClient._decoded.quoteFeesAccrued.toString());
    await sleep(3000);
  }
}

main();

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}


================================================
File: tests/cfo/scripts/list-market.js
================================================
#!/usr/bin/env node

// Script to list a market, logging the address to stdout.

const utils = require("../tests/utils");
const fs = require("fs");
const anchor = require("@coral-xyz/anchor");
const provider = anchor.AnchorProvider.local();
// hack so we don't have to update serum-common library
// to the new AnchorProvider class and Provider interface
provider.send = provider.sendAndConfirm;

async function main() {
  ORDERBOOK_ENV = await utils.initMarket({
    provider,
  });
  const out = {
    market: ORDERBOOK_ENV.marketA._decoded.ownAddress.toString(),
  };
  console.log(JSON.stringify(out));
}

main();


================================================
File: tests/cfo/scripts/localnet.sh
================================================
#!/usr/bin/env bash

set -euo pipefail

source scripts/common.sh

DEX_PID="srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"
PAYER_FILEPATH="$HOME/.config/solana/id.json"
CRANK="/home/armaniferrante/Documents/code/src/github.com/project-serum/serum-dex/target/debug/crank"
VALIDATOR_OUT="./validator-stdout.txt"
CRANK_LOGS="crank-logs.txt"
CRANK_STDOUT="crank-stdout.txt"
TRADE_BOT_STDOUT="trade-bot-stdout.txt"
FEES_STDOUT="fees.txt"

main () {
		echo "Cleaning old output files..."
		rm -rf test-ledger
		rm -f $TRADE_BOT_STDOUT
		rm -f $FEES_STDOUT
		rm -f $VALIDATOR_OUT
		rm -f $CRANK_LOGS && touch $CRANK_LOGS

		echo "Starting local network..."
		solana-test-validator \
				--bpf-program srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX ./deps/openbook-dex/dex/target/deploy/serum_dex.so \
				--bpf-program 22Y43yTVxuUkoRKdm9thyRhQ3SdgQS7c7kB6UNCiaczD ./deps/swap/target/deploy/swap.so \
				--bpf-program GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv ./deps/stake/target/deploy/registry.so \
				--bpf-program 6ebQNeTPZ1j7k3TtkCCtEPRvG7GQsucQrZ7sSEDQi9Ks ./deps/stake/target/deploy/lockup.so \
				--bpf-program 5CHQcwNhkFiFXXM8HakHi8cB7AKP3M3GPdEBDeRJBWQq ./target/deploy/cfo.so > $VALIDATOR_OUT &
		sleep 2

		echo "Listing market..."
		market=$(./scripts/list-market.js | jq -r .market)
		sleep 2
		echo "Market listed $market"

		echo "Running crank..."
		$CRANK localnet consume-events \
					-c $market \
					-d $DEX_PID -e 5 \
					--log-directory $CRANK_LOGS \
					--market $market \
					--num-workers 1 \
					--payer $PAYER_FILEPATH \
					--pc-wallet $market > $CRANK_STDOUT &
		echo "Running trade bot..."
		./scripts/trade-bot.js $market > $TRADE_BOT_STDOUT &

		echo "Running fees listener..."
		./scripts/fees.js $market > $FEES_STDOUT &

		echo "Localnet running..."
		echo "Ctl-c to exit."
		wait
}

main


================================================
File: tests/cfo/scripts/market-maker.json
================================================
[13,174,53,150,78,228,12,98,170,254,212,211,125,193,2,241,97,137,49,209,189,199,27,215,220,65,57,203,215,93,105,203,217,32,5,194,157,118,162,47,102,126,235,65,99,80,56,231,217,114,25,225,239,140,169,92,150,146,211,218,183,139,9,104]


================================================
File: tests/cfo/scripts/trade-bot.js
================================================
#!/usr/bin/env node

// Script to infinitely post orders that are immediately filled.

const process = require("process");
const anchor = require("@coral-xyz/anchor");
const PublicKey = anchor.web3.PublicKey;
const { runTradeBot } = require("../tests/utils");

async function main() {
  const market = new PublicKey(process.argv[2]);
  const provider = anchor.AnchorProvider.local();
  runTradeBot(market, provider);
}

main();


================================================
File: tests/chat/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
chat = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/chat/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/chat/package.json
================================================
{
  "name": "chat",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/chat/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/chat/programs/chat/Cargo.toml
================================================
[package]
name = "chat"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "chat"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
bytemuck = {version = "1.4.0", features = ["derive", "min_const_generics"]}


================================================
File: tests/chat/programs/chat/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/chat/programs/chat/src/lib.rs
================================================
//! A simple chat program using a ring buffer to store messages.

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod chat {
    use super::*;

    pub fn create_user(ctx: Context<CreateUser>, name: String) -> Result<()> {
        ctx.accounts.user.name = name;
        ctx.accounts.user.authority = *ctx.accounts.authority.key;
        ctx.accounts.user.bump = ctx.bumps.user;
        Ok(())
    }
    pub fn create_chat_room(ctx: Context<CreateChatRoom>, name: String) -> Result<()> {
        let given_name = name.as_bytes();
        let mut name = [0u8; 280];
        name[..given_name.len()].copy_from_slice(given_name);
        let mut chat = ctx.accounts.chat_room.load_init()?;
        chat.name = name;
        Ok(())
    }
    pub fn send_message(ctx: Context<SendMessage>, msg: String) -> Result<()> {
        let mut chat = ctx.accounts.chat_room.load_mut()?;
        chat.append({
            let src = msg.as_bytes();
            let mut data = [0u8; 280];
            data[..src.len()].copy_from_slice(src);
            Message {
                from: *ctx.accounts.user.to_account_info().key,
                data,
            }
        });
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(name: String)]
pub struct CreateUser<'info> {
    #[account(
        init,
        seeds = [authority.key().as_ref()],
        bump,
        payer = authority,
        space = 8 + User::INIT_SPACE,
    )]
    user: Account<'info, User>,
    #[account(mut)]
    authority: Signer<'info>,
    system_program: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CreateChatRoom<'info> {
    #[account(zero)]
    chat_room: AccountLoader<'info, ChatRoom>,
}

#[derive(Accounts)]
pub struct SendMessage<'info> {
    #[account(
        seeds = [authority.key().as_ref()],
        bump = user.bump,
        has_one = authority,
    )]
    user: Account<'info, User>,
    authority: Signer<'info>,
    #[account(mut)]
    chat_room: AccountLoader<'info, ChatRoom>,
}

#[account]
#[derive(InitSpace)]
pub struct User {
    #[max_len(200)]
    name: String,
    authority: Pubkey,
    bump: u8,
}

#[account(zero_copy)]
pub struct ChatRoom {
    head: u64,
    tail: u64,
    name: [u8; 280],            // Human readable name (char bytes).
    messages: [Message; 33607], // Leaves the account at 10,485,680 bytes.
}

impl ChatRoom {
    fn append(&mut self, msg: Message) {
        self.messages[ChatRoom::index_of(self.head)] = msg;
        if ChatRoom::index_of(self.head + 1) == ChatRoom::index_of(self.tail) {
            self.tail += 1;
        }
        self.head += 1;
    }
    fn index_of(counter: u64) -> usize {
        std::convert::TryInto::try_into(counter % 33607).unwrap()
    }
}

#[zero_copy]
pub struct Message {
    pub from: Pubkey,
    pub data: [u8; 280],
}

#[error_code]
pub enum ErrorCode {
    Unknown,
}


================================================
File: tests/composite/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
composite = "EHthziFziNoac9LBGxEaVN47Y3uUiRoXvqAiR6oes4iU"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: tests/composite/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/composite/package.json
================================================
{
  "name": "composite",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/composite/programs/composite/Cargo.toml
================================================
[package]
name = "composite"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "composite"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/composite/programs/composite/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/composite/programs/composite/src/lib.rs
================================================
//! This example demonstrates the ability to compose together multiple
//! structs deriving `Accounts`. See `CompositeUpdate`, below.

use anchor_lang::prelude::*;

declare_id!("EHthziFziNoac9LBGxEaVN47Y3uUiRoXvqAiR6oes4iU");

#[program]
mod composite {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn composite_update(
        ctx: Context<CompositeUpdate>,
        dummy_a: u64,
        dummy_b: u64,
    ) -> Result<()> {
        let a = &mut ctx.accounts.foo.dummy_a;
        let b = &mut ctx.accounts.bar.dummy_b;

        a.data = dummy_a;
        b.data = dummy_b;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(zero)]
    pub dummy_a: Account<'info, DummyA>,
    #[account(zero)]
    pub dummy_b: Account<'info, DummyB>,
}

#[derive(Accounts)]
pub struct CompositeUpdate<'info> {
    foo: Foo<'info>,
    bar: Bar<'info>,
}

#[derive(Accounts)]
pub struct Foo<'info> {
    #[account(mut)]
    pub dummy_a: Account<'info, DummyA>,
}

#[derive(Accounts)]
pub struct Bar<'info> {
    #[account(mut)]
    pub dummy_b: Account<'info, DummyB>,
}

#[account]
pub struct DummyA {
    pub data: u64,
}

#[account]
pub struct DummyB {
    pub data: u64,
}


================================================
File: tests/composite/tests/composite.js
================================================
const { assert } = require("chai");
const anchor = require("@coral-xyz/anchor");

describe("composite", () => {
  const provider = anchor.AnchorProvider.local();

  // Configure the client to use the local cluster.
  anchor.setProvider(provider);

  it("Is initialized!", async () => {
    const program = anchor.workspace.Composite;

    const dummyA = anchor.web3.Keypair.generate();
    const dummyB = anchor.web3.Keypair.generate();

    const tx = await program.rpc.initialize({
      accounts: {
        dummyA: dummyA.publicKey,
        dummyB: dummyB.publicKey,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      },
      signers: [dummyA, dummyB],
      instructions: [
        await program.account.dummyA.createInstruction(dummyA),
        await program.account.dummyB.createInstruction(dummyB),
      ],
    });

    await program.rpc.compositeUpdate(
      new anchor.BN(1234),
      new anchor.BN(4321),
      {
        accounts: {
          foo: {
            dummyA: dummyA.publicKey,
          },
          bar: {
            dummyB: dummyB.publicKey,
          },
        },
      }
    );

    const dummyAAccount = await program.account.dummyA.fetch(dummyA.publicKey);
    const dummyBAccount = await program.account.dummyB.fetch(dummyB.publicKey);

    assert.isTrue(dummyAAccount.data.eq(new anchor.BN(1234)));
    assert.isTrue(dummyBAccount.data.eq(new anchor.BN(4321)));
  });
});


================================================
File: tests/cpi-returns/Anchor.toml
================================================
[features]
seeds = false

[programs.localnet]
callee = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
caller = "HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/cpi-returns/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/cpi-returns/package.json
================================================
{
  "name": "cpi-returns",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor run test-with-build"
  }
}


================================================
File: tests/cpi-returns/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/cpi-returns/.gitignore
================================================

.anchor
.DS_Store
target
**/*.rs.bk
node_modules


================================================
File: tests/cpi-returns/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/cpi-returns/programs/callee/Cargo.toml
================================================
[package]
name = "callee"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "callee"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }


================================================
File: tests/cpi-returns/programs/callee/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/cpi-returns/programs/callee/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod callee {
    use super::*;

    #[derive(AnchorSerialize, AnchorDeserialize)]
    pub struct StructReturn {
        pub value: u64,
    }

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let account = &mut ctx.accounts.account;
        account.value = 10;
        Ok(())
    }

    pub fn return_u64(_ctx: Context<CpiReturn>) -> Result<u64> {
        Ok(10)
    }

    pub fn return_struct(_ctx: Context<CpiReturn>) -> Result<StructReturn> {
        let s = StructReturn { value: 11 };
        Ok(s)
    }

    pub fn return_vec(_ctx: Context<CpiReturn>) -> Result<Vec<u8>> {
        Ok(vec![12, 13, 14, 100])
    }

    // Used for testing views
    pub fn return_u64_from_account(ctx: Context<CpiReturn>) -> Result<u64> {
        let account = &ctx.accounts.account;
        Ok(account.value)
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = user, space = 8 + 8)]
    pub account: Account<'info, CpiReturnAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CpiReturn<'info> {
    pub account: Account<'info, CpiReturnAccount>,
}

#[account]
pub struct CpiReturnAccount {
    pub value: u64,
}


================================================
File: tests/cpi-returns/programs/caller/Cargo.toml
================================================
[package]
name = "caller"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "caller"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }
callee = { path = "../callee", features = ["cpi"] }


================================================
File: tests/cpi-returns/programs/caller/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/cpi-returns/programs/caller/src/lib.rs
================================================
use anchor_lang::prelude::*;
use callee::cpi::accounts::CpiReturn;
use callee::program::Callee;
use callee::{self, CpiReturnAccount};

declare_id!("HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L");

#[program]
pub mod caller {
    use super::*;

    #[derive(AnchorSerialize, AnchorDeserialize)]
    pub struct Struct {
        pub a: u64,
        pub b: u64,
    }

    pub fn cpi_call_return_u64(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_u64(cpi_ctx)?;
        let solana_return = result.get();
        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
        Ok(())
    }

    pub fn cpi_call_return_struct(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_struct(cpi_ctx)?;
        let solana_return = result.get();
        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
        Ok(())
    }

    pub fn cpi_call_return_vec(ctx: Context<CpiReturnContext>) -> Result<()> {
        let cpi_program = ctx.accounts.cpi_return_program.to_account_info();
        let cpi_accounts = CpiReturn {
            account: ctx.accounts.cpi_return.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        let result = callee::cpi::return_vec(cpi_ctx)?;
        let solana_return = result.get();
        anchor_lang::solana_program::log::sol_log_data(&[&solana_return.try_to_vec().unwrap()]);
        Ok(())
    }

    pub fn return_u64(ctx: Context<ReturnContext>) -> Result<u64> {
        Ok(99)
    }

    pub fn return_struct(ctx: Context<ReturnContext>) -> Result<Struct> {
        Ok(Struct { a: 1, b: 2 })
    }

    pub fn return_vec(ctx: Context<ReturnContext>) -> Result<Vec<u64>> {
        Ok(vec![1, 2, 3])
    }
}

#[derive(Accounts)]
pub struct CpiReturnContext<'info> {
    #[account(mut)]
    pub cpi_return: Account<'info, CpiReturnAccount>,
    pub cpi_return_program: Program<'info, Callee>,
}

#[derive(Accounts)]
pub struct ReturnContext {}


================================================
File: tests/custom-coder/Anchor.toml
================================================
[programs.localnet]
native_system = "9NxAd91hhJ3ZBTHytYP894y4ESRKG7n8VbLgdyYGJFLB"
spl_associated_token = "4dUGnkre6uBhX1abB4ofkoecGN4aDXdiWSaWLUjVw6bh"
spl_token = "FmpfPa1LHEYRbueNMnwNVd2JvyQ89GXGWdyZEXNNKV8w"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/custom-coder/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/custom-coder/package.json
================================================
{
  "name": "custom-coder",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test --skip-lint"
  },
  "dependencies": {
    "mocha": "^10.0.0",
    "ts-mocha": "^10.0.0"
  }
}


================================================
File: tests/custom-coder/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/custom-coder/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/custom-coder/programs/native-system/Cargo.toml
================================================
[package]
name = "native-system"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "native_system"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/custom-coder/programs/native-system/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/custom-coder/programs/spl-associated-token/Cargo.toml
================================================
[package]
name = "spl-associated-token"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "spl_associated_token"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[profile.release]
overflow-checks = true

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/custom-coder/programs/spl-associated-token/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/custom-coder/programs/spl-associated-token/src/lib.rs
================================================
// See https://github.com/coral-xyz/anchor/blob/master/ts/packages/spl-associated-token-account/program/lib.rs

use anchor_lang::prelude::*;

declare_id!("4dUGnkre6uBhX1abB4ofkoecGN4aDXdiWSaWLUjVw6bh");

// See https://solana.stackexchange.com/a/1858/471
#[program]
pub mod spl_associated_token {}


================================================
File: tests/custom-coder/programs/spl-token/Cargo.toml
================================================
[package]
name = "spl-token"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "spl_token"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/custom-coder/programs/spl-token/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/custom-coder/programs/spl-token/src/lib.rs
================================================
// See https://github.com/coral-xyz/anchor/blob/master/ts/packages/spl-token/program/lib.rs

use anchor_lang::prelude::*;

declare_id!("FmpfPa1LHEYRbueNMnwNVd2JvyQ89GXGWdyZEXNNKV8w");

// See https://solana.stackexchange.com/a/1858/471
#[program]
pub mod spl_token {}


================================================
File: tests/custom-coder/tests/spl-associated-token-coder.ts
================================================
import { Native, AnchorProvider, setProvider } from "@coral-xyz/anchor";
import { splAssociatedTokenAccountProgram } from "@coral-xyz/spl-associated-token-account";
import { splTokenProgram } from "@coral-xyz/spl-token";
import { Keypair, PublicKey, SYSVAR_RENT_PUBKEY } from "@solana/web3.js";
import * as assert from "assert";

describe("spl-associated-token-coder", () => {
  // Configure the client to use the local cluster.
  const provider = AnchorProvider.env();
  setProvider(provider);

  // Client.
  const program = splAssociatedTokenAccountProgram({
    provider,
  });
  const systemProgram = Native.system();
  const tokenProgram = splTokenProgram({
    provider,
  });

  it("Creates an account", async () => {
    // arrange
    const mintKeypair = Keypair.generate();
    const mintDecimals = 6;
    const [associatedToken] = await PublicKey.findProgramAddress(
      [
        provider.publicKey.toBuffer(),
        tokenProgram.programId.toBuffer(),
        mintKeypair.publicKey.toBuffer(),
      ],
      program.programId
    );

    // act
    await program.methods
      .create()
      .accounts({
        associatedAccountAddress: associatedToken,
        fundingAddress: provider.wallet.publicKey,
        systemProgram: systemProgram.programId,
        tokenMintAddress: mintKeypair.publicKey,
        tokenProgram: tokenProgram.programId,
        walletAddress: provider.wallet.publicKey,
      })
      .preInstructions(
        await Promise.all([
          tokenProgram.account.mint.createInstruction(mintKeypair),
          tokenProgram.methods
            .initializeMint(mintDecimals, provider.wallet.publicKey, null)
            .accounts({
              mint: mintKeypair.publicKey,
              rent: SYSVAR_RENT_PUBKEY,
            })
            .instruction(),
        ])
      )
      .signers([mintKeypair])
      .rpc();
    // assert
    const tokenAccount = await tokenProgram.account.account.fetch(
      associatedToken
    );
    assert.ok(tokenAccount.mint.equals(mintKeypair.publicKey));
  });
});


================================================
File: tests/custom-discriminator/Anchor.toml
================================================
[workspace]
exclude = ["programs/ambiguous-discriminator"]

[features]
resolution = true
skip-lint = false

[programs.localnet]
ambiguous-discriminator = "AmbiguousDiscriminator111111111111111111111"
custom_discriminator = "CustomDiscriminator111111111111111111111111"

[registry]
url = "https://api.apr.dev"

[provider]
cluster = "Localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/custom-discriminator/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


================================================
File: tests/custom-discriminator/package.json
================================================
{
  "name": "custom-discriminator",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/custom-discriminator/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/custom-discriminator/programs/ambiguous-discriminator/Cargo.toml
================================================
[package]
name = "ambiguous-discriminator"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "ambiguous_discriminator"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/custom-discriminator/programs/ambiguous-discriminator/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/custom-discriminator/programs/ambiguous-discriminator/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("AmbiguousDiscriminator111111111111111111111");

#[program]
pub mod ambiguous_discriminator {
    use super::*;

    /// Compilation should error due to ambiguous discriminators.
    pub fn check_accounts(_ctx: Context<CheckAccounts>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CheckAccounts<'info> {
    pub some_account: Account<'info, SomeAccount>,
    pub another_account: Account<'info, AnotherAccount>,
}

#[account(discriminator = 1)]
pub struct SomeAccount {
    pub a: u8,
    pub b: u16,
    pub c: u32,
}

#[account(discriminator = [1, 2, 3, 4])]
pub struct AnotherAccount {
    pub a: u32,
}


================================================
File: tests/custom-discriminator/programs/custom-discriminator/Cargo.toml
================================================
[package]
name = "custom-discriminator"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "custom_discriminator"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/custom-discriminator/programs/custom-discriminator/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/custom-discriminator/programs/custom-discriminator/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("CustomDiscriminator111111111111111111111111");

const CONST_DISC: &'static [u8] = &[55, 66, 77, 88];

const fn get_disc(input: &str) -> &'static [u8] {
    match input.as_bytes() {
        b"wow" => &[4 + 5, 55 / 5],
        _ => unimplemented!(),
    }
}

#[program]
pub mod custom_discriminator {
    use super::*;

    #[instruction(discriminator = 0)]
    pub fn int(_ctx: Context<DefaultIx>) -> Result<()> {
        Ok(())
    }

    #[instruction(discriminator = [1, 2, 3, 4])]
    pub fn array(_ctx: Context<DefaultIx>) -> Result<()> {
        Ok(())
    }

    #[instruction(discriminator = b"hi")]
    pub fn byte_str(_ctx: Context<DefaultIx>) -> Result<()> {
        Ok(())
    }

    #[instruction(discriminator = CONST_DISC)]
    pub fn constant(_ctx: Context<DefaultIx>) -> Result<()> {
        Ok(())
    }

    #[instruction(discriminator = get_disc("wow"))]
    pub fn const_fn(_ctx: Context<DefaultIx>) -> Result<()> {
        Ok(())
    }

    pub fn account(ctx: Context<CustomAccountIx>, field: u8) -> Result<()> {
        ctx.accounts.my_account.field = field;
        Ok(())
    }

    pub fn event(_ctx: Context<DefaultIx>, field: u8) -> Result<()> {
        emit!(MyEvent { field });
        Ok(())
    }
}

#[derive(Accounts)]
pub struct DefaultIx<'info> {
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct CustomAccountIx<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        space = MyAccount::DISCRIMINATOR.len() + core::mem::size_of::<MyAccount>(),
        seeds = [b"my_account"],
        bump
    )]
    pub my_account: Account<'info, MyAccount>,
    pub system_program: Program<'info, System>,
}

#[account(discriminator = 1)]
pub struct MyAccount {
    pub field: u8,
}

#[event(discriminator = 1)]
pub struct MyEvent {
    field: u8,
}


================================================
File: tests/custom-discriminator/tests/ambiguous-discriminator.ts
================================================
import { spawnSync } from "child_process";

describe("ambiguous-discriminator", () => {
  it("Returns ambiguous discriminator error on builds", () => {
    const result = spawnSync("anchor", [
      "idl",
      "build",
      "-p",
      "ambiguous-discriminator",
    ]);
    if (result.status === 0) {
      throw new Error("Ambiguous errors did not make building the IDL fail");
    }

    const output = result.output.toString();
    if (!output.includes("Error: Program ambiguous-discriminator not found")) {
      throw new Error(
        `Ambiguous discriminators did not return the expected error: "${output}"`
      );
    }
  });
});


================================================
File: tests/custom-discriminator/tests/custom-discriminator.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import assert from "assert";

import type { CustomDiscriminator } from "../target/types/custom_discriminator";

describe("custom-discriminator", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program: anchor.Program<CustomDiscriminator> =
    anchor.workspace.customDiscriminator;

  describe("Instructions", () => {
    const testCommon = async (ixName: keyof typeof program["methods"]) => {
      const tx = await program.methods[ixName]().transaction();

      // Verify discriminator
      const ix = program.idl.instructions.find((ix) => ix.name === ixName)!;
      assert(ix.discriminator.length < 8);
      const data = tx.instructions[0].data;
      assert(data.equals(Buffer.from(ix.discriminator)));

      // Verify tx runs
      await program.provider.sendAndConfirm!(tx);
    };

    it("Integer", () => testCommon("int"));
    it("Array", () => testCommon("array"));
    it("Byte string", () => testCommon("byteStr"));
    it("Constant", () => testCommon("constant"));
    it("Const Fn", () => testCommon("constFn"));
  });

  describe("Accounts", () => {
    it("Works", async () => {
      // Verify discriminator
      const acc = program.idl.accounts.find((acc) => acc.name === "myAccount")!;
      assert(acc.discriminator.length < 8);

      // Verify regular `init` ix works
      const field = 5;
      const { pubkeys, signature } = await program.methods
        .account(field)
        .rpcAndKeys();
      await program.provider.connection.confirmTransaction(
        signature,
        "confirmed"
      );
      const myAccount = await program.account.myAccount.fetch(
        pubkeys.myAccount
      );
      assert.strictEqual(myAccount.field, field);
    });
  });

  describe("Events", () => {
    it("Works", async () => {
      // Verify discriminator
      const event = program.idl.events.find((acc) => acc.name === "myEvent")!;
      assert(event.discriminator.length < 8);

      // Verify regular event works
      await new Promise<void>((res) => {
        const field = 5;
        const id = program.addEventListener("myEvent", (ev) => {
          assert.strictEqual(ev.field, field);
          program.removeEventListener(id);
          res();
        });
        program.methods.event(field).rpc();
      });
    });
  });
});


================================================
File: tests/declare-id/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
declare_id = "FJcF5c8HncdfAgjPjTH49GAEypkJCG2ZADh2xhduNi5B"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"


================================================
File: tests/declare-id/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/declare-id/package.json
================================================
{
  "name": "declare-id",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/declare-id/tsconfig.json
================================================
{
    "compilerOptions": {
        "types": ["mocha", "chai", "node"],
        "typeRoots": ["./node_modules/@types"],
        "lib": ["es2015"],
        "module": "commonjs",
        "target": "es6",
        "esModuleInterop": true,
        "skipLibCheck": true
    }
}


================================================
File: tests/declare-id/programs/declare-id/Cargo.toml
================================================
[package]
name = "declare-id"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "declare_id"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/declare-id/programs/declare-id/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/declare-id/programs/declare-id/src/lib.rs
================================================
use anchor_lang::prelude::*;

// Intentionally different program id than the one defined in Anchor.toml.
declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod declare_id {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {
}


================================================
File: tests/declare-id/tests/declare-id.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { AnchorError, Program } from "@coral-xyz/anchor";
import splToken from "@solana/spl-token";
import { DeclareId } from "../target/types/declare_id";
import { assert } from "chai";

describe("declare_id", () => {
  anchor.setProvider(anchor.AnchorProvider.local());
  const program = anchor.workspace.DeclareId as Program<DeclareId>;

  it("throws error!", async () => {
    try {
      await program.methods.initialize().rpc();
      assert.ok(false);
    } catch (_err) {
      assert.isTrue(_err instanceof AnchorError);
      const err: AnchorError = _err;
      assert.strictEqual(err.error.errorCode.number, 4100);
    }
  });
});


================================================
File: tests/declare-program/Anchor.toml
================================================
[programs.localnet]
declare_program = "Dec1areProgram11111111111111111111111111111"
external = "Externa111111111111111111111111111111111111"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/declare-program/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


================================================
File: tests/declare-program/package.json
================================================
{
  "name": "declare-program",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/declare-program/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "strict": true
  }
}


================================================
File: tests/declare-program/idls/external_legacy.json
================================================
{
  "version": "0.1.0",
  "name": "external",
  "constants": [
    {
      "name": "MASTER_SEED",
      "type": "bytes",
      "value": "[109, 97, 115, 116, 101, 114]"
    }
  ],
  "instructions": [
    {
      "name": "init",
      "accounts": [
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "myAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "update",
      "accounts": [
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "myAccount",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "value",
          "type": "u32"
        }
      ]
    },
    {
      "name": "updateComposite",
      "accounts": [
        {
          "name": "update",
          "accounts": [
            {
              "name": "authority",
              "isMut": false,
              "isSigner": true
            },
            {
              "name": "myAccount",
              "isMut": true,
              "isSigner": false
            }
          ]
        }
      ],
      "args": [
        {
          "name": "value",
          "type": "u32"
        }
      ]
    },
    {
      "name": "testCompilationDefinedTypeParam",
      "accounts": [
        {
          "name": "signer",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "myAccount",
          "type": {
            "defined": "MyAccount"
          }
        }
      ]
    },
    {
      "name": "testCompilationReturnType",
      "accounts": [
        {
          "name": "signer",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [],
      "returns": "bool"
    }
  ],
  "accounts": [
    {
      "name": "MyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "field",
            "type": "u32"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "MyEvent",
      "fields": [
        {
          "name": "value",
          "type": "u32",
          "index": false
        }
      ]
    }
  ],
  "metadata": {
    "address": "Externa111111111111111111111111111111111111"
  }
}


================================================
File: tests/declare-program/programs/declare-program/Cargo.toml
================================================
[package]
name = "declare-program"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "declare_program"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/declare-program/programs/declare-program/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/declare-program/programs/external/Cargo.toml
================================================
[package]
name = "external"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/declare-program/programs/external/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/declare-program/programs/external/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Externa111111111111111111111111111111111111");

/// Master seed slice
#[constant]
pub const MASTER_SEED: &[u8] = b"master";

#[program]
pub mod external {
    use super::*;

    pub fn init(_ctx: Context<Init>) -> Result<()> {
        Ok(())
    }

    pub fn update(ctx: Context<Update>, value: u32) -> Result<()> {
        ctx.accounts.my_account.field = value;
        Ok(())
    }

    pub fn update_composite(ctx: Context<UpdateComposite>, value: u32) -> Result<()> {
        ctx.accounts.update.my_account.field = value;
        Ok(())
    }

    // Test the issue described in https://github.com/coral-xyz/anchor/issues/3274
    pub fn update_non_instruction_composite(
        ctx: Context<UpdateNonInstructionComposite>,
        value: u32,
    ) -> Result<()> {
        ctx.accounts.non_instruction_update.my_account.field = value;
        Ok(())
    }

    // Compilation test for whether a defined type (an account in this case) can be used in `cpi` client.
    pub fn test_compilation_defined_type_param(
        _ctx: Context<TestCompilation>,
        _my_account: MyAccount,
    ) -> Result<()> {
        Ok(())
    }

    // Compilation test for whether a custom return type can be specified in `cpi` client
    pub fn test_compilation_return_type(_ctx: Context<TestCompilation>) -> Result<bool> {
        Ok(true)
    }
}

#[derive(Accounts)]
pub struct TestCompilation<'info> {
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Init<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    #[account(
        init,
        payer = authority,
        space = 8 + 4,
        seeds = [authority.key.as_ref()],
        bump
    )]
    pub my_account: Account<'info, MyAccount>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    pub authority: Signer<'info>,
    #[account(mut, seeds = [authority.key.as_ref()], bump)]
    pub my_account: Account<'info, MyAccount>,
}

#[derive(Accounts)]
pub struct NonInstructionUpdate<'info> {
    pub authority: Signer<'info>,
    #[account(mut, seeds = [authority.key.as_ref()], bump)]
    pub my_account: Account<'info, MyAccount>,
    pub program: Program<'info, program::External>,
}

#[derive(Accounts)]
pub struct UpdateComposite<'info> {
    pub update: Update<'info>,
}

#[derive(Accounts)]
pub struct UpdateNonInstructionComposite<'info> {
    pub non_instruction_update: NonInstructionUpdate<'info>,
}

#[account]
pub struct MyAccount {
    pub field: u32,
}

#[event]
pub struct MyEvent {
    pub value: u32,
}


================================================
File: tests/declare-program/tests/declare-program.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import assert from "assert";

import type { DeclareProgram } from "../target/types/declare_program";
import type { External } from "../target/types/external";

describe("declare-program", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program: anchor.Program<DeclareProgram> =
    anchor.workspace.declareProgram;
  const externalProgram: anchor.Program<External> = anchor.workspace.external;

  // TODO: Add a utility type that does this?
  let pubkeys: Awaited<
    ReturnType<
      ReturnType<typeof externalProgram["methods"]["init"]>["rpcAndKeys"]
    >
  >["pubkeys"];

  before(async () => {
    pubkeys = (await externalProgram.methods.init().rpcAndKeys()).pubkeys;
  });

  it("Can CPI", async () => {
    const value = 5;
    await program.methods
      .cpi(value)
      .accounts({ cpiMyAccount: pubkeys.myAccount })
      .rpc();

    const myAccount = await externalProgram.account.myAccount.fetch(
      pubkeys.myAccount
    );
    assert.strictEqual(myAccount.field, value);
  });

  it("Can CPI composite", async () => {
    const value = 3;
    await program.methods
      .cpiComposite(value)
      .accounts({ cpiMyAccount: pubkeys.myAccount })
      .rpc();

    const myAccount = await externalProgram.account.myAccount.fetch(
      pubkeys.myAccount
    );
    assert.strictEqual(myAccount.field, value);
  });

  it("Can use account utils", async () => {
    await program.methods.accountUtils().rpc();
  });

  it("Can use event utils", async () => {
    await program.methods.eventUtils().rpc();
  });
});


================================================
File: tests/errors/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
errors = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"

[features]
seeds = false


================================================
File: tests/errors/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/errors/package.json
================================================
{
  "name": "errors",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/errors/tsconfig.json
================================================
{
    "compilerOptions": {
        "types": ["mocha", "chai", "node"],
        "typeRoots": ["./node_modules/@types"],
        "lib": ["es2015"],
        "module": "commonjs",
        "target": "es6",
        "esModuleInterop": true,
        "skipLibCheck": true
    }
}


================================================
File: tests/errors/programs/errors/Cargo.toml
================================================
[package]
name = "errors"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "errors"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/errors/programs/errors/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/escrow/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
escrow = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"


================================================
File: tests/escrow/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/escrow/package.json
================================================
{
  "name": "escrow",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/escrow/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai", "node"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/escrow/programs/escrow/Cargo.toml
================================================
[package]
name = "escrow"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "escrow"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/escrow/programs/escrow/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/events/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
events = "2dhGsWUzy5YKUsjZdLHLmkNpUDAXkNa9MYWsPc4Ziqzy"

[scripts]
test = "yarn run ts-mocha -t 1000000 -p ./tsconfig.json tests/**/*.ts"


================================================
File: tests/events/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/events/package.json
================================================
{
  "name": "events",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/events/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/events/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/events/programs/events/Cargo.toml
================================================
[package]
name = "events"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "events"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["event-cpi"] }


================================================
File: tests/events/programs/events/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/events/programs/events/src/lib.rs
================================================
//! This example demonstrates how to emit an event, which can be
//! subscribed to by a client.

use anchor_lang::prelude::*;

declare_id!("2dhGsWUzy5YKUsjZdLHLmkNpUDAXkNa9MYWsPc4Ziqzy");

#[program]
pub mod events {
    use super::*;
    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        emit!(MyEvent {
            data: 5,
            label: "hello".to_string(),
        });
        Ok(())
    }

    pub fn test_event(_ctx: Context<TestEvent>) -> Result<()> {
        emit!(MyOtherEvent {
            data: 6,
            label: "bye".to_string(),
        });
        Ok(())
    }

    pub fn test_event_cpi(ctx: Context<TestEventCpi>) -> Result<()> {
        emit_cpi!(MyOtherEvent {
            data: 7,
            label: "cpi".to_string(),
        });
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}

#[derive(Accounts)]
pub struct TestEvent {}

#[event_cpi]
#[derive(Accounts)]
pub struct TestEventCpi {}

#[event]
pub struct MyEvent {
    pub data: u64,
    pub label: String,
}

#[event]
pub struct MyOtherEvent {
    pub data: u64,
    pub label: String,
}


================================================
File: tests/floats/Anchor.toml
================================================
[programs.localnet]
floats = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/floats/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/floats/package.json
================================================
{
  "name": "floats",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/floats/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/floats/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/floats/programs/floats/Cargo.toml
================================================
[package]
name = "floats"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "floats"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/floats/programs/floats/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/floats/programs/floats/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod floats {
    use super::*;

    pub fn create(ctx: Context<Create>, data_f32: f32, data_f64: f64) -> Result<()> {
        let account = &mut ctx.accounts.account;
        let authority = &mut ctx.accounts.authority;

        account.data_f32 = data_f32;
        account.data_f64 = data_f64;
        account.authority = authority.key();

        Ok(())
    }

    pub fn update(ctx: Context<Update>, data_f32: f32, data_f64: f64) -> Result<()> {
        let account = &mut ctx.accounts.account;

        account.data_f32 = data_f32;
        account.data_f64 = data_f64;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(init, payer = authority, space = 8 + 8 + 4 + 32)]
    pub account: Account<'info, FloatDataAccount>,
    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut, has_one = authority)]
    pub account: Account<'info, FloatDataAccount>,
    pub authority: Signer<'info>,
}

#[account]
pub struct FloatDataAccount {
    pub data_f64: f64,
    pub data_f32: f32,
    pub authority: Pubkey,
}


================================================
File: tests/floats/tests/floats.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program, getProvider } from "@coral-xyz/anchor";
import { Keypair, SystemProgram } from "@solana/web3.js";
import { Floats } from "../target/types/floats";
import { assert } from "chai";

describe("floats", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Floats as Program<Floats>;

  it("Creates an account with float data", async () => {
    const accountKeypair = Keypair.generate();

    await program.methods
      .create(1.0, 2.0)
      .accounts({
        account: accountKeypair.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([accountKeypair])
      .rpc();

    const account = await program.account.floatDataAccount.fetch(
      accountKeypair.publicKey
    );

    assert.strictEqual(account.dataF32, 1.0);
    assert.strictEqual(account.dataF64, 2.0);
  });

  it("Updates an account with float data", async () => {
    const accountKeypair = Keypair.generate();
    const authorityPublicKey = provider.wallet.publicKey;

    await program.methods
      .create(1.0, 2.0)
      .accounts({
        account: accountKeypair.publicKey,
        authority: authorityPublicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([accountKeypair])
      .rpc();

    let account = await program.account.floatDataAccount.fetch(
      accountKeypair.publicKey
    );

    await program.methods
      .update(3.0, 4.0)
      .accounts({
        account: accountKeypair.publicKey,
        authority: authorityPublicKey,
      })
      .rpc();

    account = await program.account.floatDataAccount.fetch(
      accountKeypair.publicKey
    );

    assert.strictEqual(account.dataF32, 3.0);
    assert.strictEqual(account.dataF64, 4.0);
  });
});


================================================
File: tests/idl/Anchor.toml
================================================
[features]
skip-lint = true

[programs.localnet]
docs = "Docs111111111111111111111111111111111111111"
external = "Externa1111111111111111111111111111111111111"
generics = "Generics111111111111111111111111111111111111"
idl = "id11111111111111111111111111111111111111111"
relations_derivation = "Re1ationsDerivation111111111111111111111111"
non_existent = { address = "NonExistent11111111111111111111111111111111", idl = "non-existent.json" }
numbers_123 = { address = "Numbers111111111111111111111111111111111111", idl = "idls/relations.json" }
new_idl = "Newid11111111111111111111111111111111111111"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/idl/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


================================================
File: tests/idl/generate.sh
================================================
#!/usr/bin/env bash

# `$1` is the directory to generate the IDLs in, defaults to `./idls`
if [ $# = 1 ]; then
    dir=$1
else
    dir=$PWD/idls
fi

cd programs/idl
anchor idl build -o $dir/new.json

cd ../generics
anchor idl build -o $dir/generics.json

cd ../relations-derivation
anchor idl build -o $dir/relations.json


================================================
File: tests/idl/package.json
================================================
{
  "name": "idl",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/idl/test.sh
================================================
#!/usr/bin/env bash
set -e

# Generate temp directory
tmp_dir=$(mktemp -d)

# Fix external type resolution not working in CI due to missing `anchor-lang`
# crates.io entry in runner machine.
pushd $tmp_dir
cargo new external-ci
pushd external-ci
cargo add anchor-lang
cargo b
popd
popd

# Run anchor test
anchor test --skip-lint

# Generate IDLs
./generate.sh $tmp_dir

# Exit status
ret=0

# Compare IDLs. `$ret` will be non-zero in the case of a mismatch.
compare() {
    echo "----------------------------------------------------"
    echo "IDL $1 before > after changes"
    echo "----------------------------------------------------"
    diff -y --color=always --suppress-common-lines idls/$1.json $tmp_dir/$1.json
    ret=$(($ret+$?))

    if [ "$ret" = "0" ]; then
        echo "No changes"
    fi

    echo ""
}

compare "new"
compare "generics"
compare "relations"

exit $ret


================================================
File: tests/idl/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "strict": true
  }
}


================================================
File: tests/idl/idls/relations.json
================================================
{
  "address": "Re1ationsDerivation111111111111111111111111",
  "metadata": {
    "name": "relations_derivation",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "init_base",
      "discriminator": [
        85,
        87,
        185,
        141,
        241,
        191,
        213,
        88
      ],
      "accounts": [
        {
          "name": "my_account",
          "writable": true,
          "signer": true
        },
        {
          "name": "account",
          "writable": true,
          "pda": {
            "seeds": [
              {
                "kind": "const",
                "value": [
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": []
    },
    {
      "name": "test_relation",
      "discriminator": [
        247,
        199,
        255,
        202,
        7,
        0,
        197,
        158
      ],
      "accounts": [
        {
          "name": "my_account",
          "relations": [
            "account"
          ]
        },
        {
          "name": "account",
          "pda": {
            "seeds": [
              {
                "kind": "const",
                "value": [
                  115,
                  101,
                  101,
                  100
                ]
              }
            ]
          }
        },
        {
          "name": "nested",
          "accounts": [
            {
              "name": "my_account",
              "relations": [
                "account"
              ]
            },
            {
              "name": "account",
              "pda": {
                "seeds": [
                  {
                    "kind": "const",
                    "value": [
                      115,
                      101,
                      101,
                      100
                    ]
                  }
                ]
              }
            }
          ]
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "MyAccount",
      "discriminator": [
        246,
        28,
        6,
        87,
        251,
        45,
        50,
        42
      ]
    }
  ],
  "types": [
    {
      "name": "MyAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "my_account",
            "type": "pubkey"
          },
          {
            "name": "bump",
            "type": "u8"
          }
        ]
      }
    }
  ]
}

================================================
File: tests/idl/programs/docs/Cargo.toml
================================================
[package]
name = "docs"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "docs"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/idl/programs/docs/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/idl/programs/docs/src/lib.rs
================================================
//! Testing the extraction of doc comments from the IDL.

use anchor_lang::prelude::*;

declare_id!("Docs111111111111111111111111111111111111111");

/// Documentation comment for constant
#[constant]
pub const MY_CONST: u8 = 42;

/// This is a doc comment for the program
#[program]
pub mod docs {
    use super::*;

    /// This instruction doc should appear in the IDL
    pub fn test_idl_doc_parse(_ctx: Context<TestIdlDocParse>) -> Result<()> {
        Ok(())
    }
}

/// Custom account doc comment should appear in the IDL
#[account]
pub struct DataWithDoc {
    /// Account attribute doc comment should appear in the IDL
    pub data: u16,
}

#[derive(Accounts)]
pub struct TestIdlDocParse<'info> {
    /// This account doc comment should appear in the IDL
    /// This is a multi-line comment
    pub act: Account<'info, DataWithDoc>,
}


================================================
File: tests/idl/programs/external/Cargo.toml
================================================
[package]
name = "external"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "external"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
idl-build = ["anchor-lang/idl-build"]
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/idl/programs/external/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/idl/programs/external/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Externa1111111111111111111111111111111111111");

#[program]
pub mod external {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct MyStruct {
    some_field: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum MyEnum {
    Unit,
    Named { name: String },
    Tuple(String),
}

pub struct NonBorshStruct {
    pub data: i32,
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/idl/programs/generics/Cargo.toml
================================================
[package]
name = "generics"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "generics"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build", "external/idl-build"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }
external = { path = "../external", features = ["no-entrypoint"] }


================================================
File: tests/idl/programs/generics/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/idl/programs/generics/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Generics111111111111111111111111111111111111");

#[program]
pub mod generics {
    use super::*;

    pub fn generic(
        ctx: Context<GenericCtx>,
        generic_field: GenericType<u32, u64, 10>,
    ) -> Result<()> {
        ctx.accounts.generic_acc.data = generic_field;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct GenericCtx<'info> {
    generic_acc: Account<'info, GenericAccount>,

    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
}

#[account]
pub struct GenericAccount {
    pub data: GenericType<u32, u64, 10>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct GenericType<T, U, const N: usize>
where
    T: AnchorSerialize + AnchorDeserialize,
    U: AnchorSerialize + AnchorDeserialize,
{
    pub gen1: T,
    pub gen2: U,
    pub gen3: GenericNested<u32, U>,
    pub gen4: GenericNested<T, external::MyStruct>,
    pub gen5: GenericNested<T, U>,
    pub gen6: GenericNested<u32, u64>,
    pub gen7: GenericNested<T, GenericNested<T, U>>,
    pub arr: [u8; N],
    pub warr: WrappedU8Array<N>,
    pub warrval: WrappedU8Array<10>,
    pub enm1: GenericEnum<T, U, N>,
    pub enm2: GenericEnum<GenericNested<T, u64>, u32, 30>,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Default)]
pub struct GenericNested<V, Z>
where
    V: AnchorSerialize + AnchorDeserialize,
    Z: AnchorSerialize + AnchorDeserialize,
{
    pub gen1: V,
    pub gen2: Z,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct WrappedU8Array<const N: usize>(u8);

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub enum GenericEnum<T, U, const N: usize>
where
    T: AnchorSerialize + AnchorDeserialize,
    U: AnchorSerialize + AnchorDeserialize,
{
    Unnamed(T, U),
    Named { gen1: T, gen2: U },
    Struct(GenericNested<T, U>),
    Arr([T; N]),
}


================================================
File: tests/idl/programs/idl/Cargo.toml
================================================
[package]
name = "idl"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "idl"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build", "external/idl-build"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }
bytemuck = {version = "1.4.0", features = ["derive", "min_const_generics"] }
external = { path = "../external", features = ["no-entrypoint"] }


================================================
File: tests/idl/programs/idl/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/idl/programs/new-idl/Cargo.toml
================================================
[package]
name = "new-idl"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "new_idl"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
external = { path = "../external", features = ["no-entrypoint"] }


================================================
File: tests/idl/programs/new-idl/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/idl/programs/relations-derivation/Cargo.toml
================================================
[package]
name = "relations-derivation"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "relations_derivation"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/idl/programs/relations-derivation/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/idl/programs/relations-derivation/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Re1ationsDerivation111111111111111111111111");

#[program]
pub mod relations_derivation {
    use super::*;

    pub fn init_base(ctx: Context<InitBase>) -> Result<()> {
        ctx.accounts.account.my_account = ctx.accounts.my_account.key();
        ctx.accounts.account.bump = ctx.bumps.account;
        Ok(())
    }

    pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitBase<'info> {
    /// CHECK: yeah I know
    #[account(mut)]
    my_account: Signer<'info>,
    #[account(
      init,
      payer = my_account,
      seeds = [b"seed"],
      space = 100,
      bump,
    )]
    account: Account<'info, MyAccount>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Nested<'info> {
    /// CHECK: yeah I know
    my_account: UncheckedAccount<'info>,
    #[account(
      has_one = my_account,
      seeds = [b"seed"],
      bump = account.bump
    )]
    account: Account<'info, MyAccount>,
}

#[derive(Accounts)]
pub struct TestRelation<'info> {
    /// CHECK: yeah I know
    my_account: UncheckedAccount<'info>,
    #[account(
      has_one = my_account,
      seeds = [b"seed"],
      bump = account.bump
    )]
    account: Account<'info, MyAccount>,
    nested: Nested<'info>,
}

#[account]
pub struct MyAccount {
    pub my_account: Pubkey,
    pub bump: u8,
}


================================================
File: tests/idl/tests/docs.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { assert } from "chai";

import { Docs } from "../target/types/docs";

describe("Docs", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.docs as Program<Docs>;

  const instruction = program.idl.instructions.find(
    (i) => i.name === "testIdlDocParse"
  )!;

  it("includes instruction doc comment", () => {
    assert.deepEqual(instruction.docs, [
      "This instruction doc should appear in the IDL",
    ]);
  });

  it("includes account doc comment", () => {
    const act = instruction.accounts.find((i) => i.name === "act")!;
    assert.deepEqual(act.docs, [
      "This account doc comment should appear in the IDL",
      "This is a multi-line comment",
    ]);
  });

  const dataWithDoc = program.idl.types.find(
    (ty) => ty.name === "dataWithDoc"
  )!;

  it("includes type doc comment", () => {
    assert.deepEqual(dataWithDoc.docs, [
      "Custom account doc comment should appear in the IDL",
    ]);
  });

  it("includes account attribute doc comment", () => {
    const dataField = dataWithDoc.type.fields.find((i) => i.name === "data")!;
    assert.deepEqual(dataField.docs, [
      "Account attribute doc comment should appear in the IDL",
    ]);
  });

  it("includes constant doc comment", () => {
    const myConst = program.idl.constants.find((c) => c.name === "myConst")!;
    assert.deepEqual(myConst.docs, ["Documentation comment for constant"]);
  });
});


================================================
File: tests/idl/tests/idl.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { assert } from "chai";

import { Idl } from "../target/types/idl";

describe("IDL", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.idl as Program<Idl>;

  it("Includes constants that use `#[constant]` macro", () => {
    const checkDefined = (
      cb: (constant: typeof program["idl"]["constants"][number]) => boolean
    ) => {
      const constant = program.idl.constants.find(cb);
      if (!constant) throw new Error("Constant not found");
    };

    checkDefined((c) => c.name === "u8" && c.type === "u8" && c.value === "6");
    checkDefined(
      (c) => c.name === "i128" && c.type === "i128" && c.value === "1000000"
    );
    checkDefined(
      (c) => c.name === "byteStr" && c.type === "u8" && c.value === "116"
    );
    checkDefined(
      (c) =>
        c.name === "bytesStr" &&
        c.type === "bytes" &&
        c.value === "[116, 101, 115, 116]"
    );
  });

  it("Does not include constants that does not use `#[constant]` macro ", () => {
    // @ts-expect-error
    assert.isUndefined(program.idl.constants.find((c) => c.name === "noIdl"));
  });
});


================================================
File: tests/idl/tests/workspace.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { assert } from "chai";

describe("Workspace", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  it("Can lazy load workspace programs", () => {
    assert.doesNotThrow(() => {
      // Program exists, should not throw
      anchor.workspace.relationsDerivation;
    });

    assert.throws(() => {
      // IDL path in Anchor.toml doesn't exist but other tests still run
      // successfully because workspace programs are getting loaded on-demand
      anchor.workspace.nonExistent;
    }, /non-existent\.json/);
  });

  it("Can get workspace programs by their name independent of casing", () => {
    const camel = anchor.workspace.relationsDerivation;
    const pascal = anchor.workspace.RelationsDerivation;
    const kebab = anchor.workspace["relations-derivation"];
    const snake = anchor.workspace["relations_derivation"];

    const compareProgramNames = (...programs: anchor.Program[]) => {
      return programs.every(
        (program) => program.rawIdl.metadata.name === "relations_derivation"
      );
    };

    assert(compareProgramNames(camel, pascal, kebab, snake));
  });

  it("Can use numbers in program names", () => {
    assert.doesNotThrow(() => {
      anchor.workspace.numbers123;
      anchor.workspace.Numbers123;
      anchor.workspace["numbers-123"];
      anchor.workspace["numbers_123"];
    });
  });
});


================================================
File: tests/ido-pool/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
ido_pool = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/ido-pool/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/ido-pool/package.json
================================================
{
  "name": "ido-pool",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/ido-pool/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/ido-pool/programs/ido-pool/Cargo.toml
================================================
[package]
name = "ido-pool"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "ido_pool"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/ido-pool/programs/ido-pool/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/ido-pool/tests/utils/index.js
================================================
const spl = require("@solana/spl-token");
const anchor = require("@coral-xyz/anchor");
const serumCmn = require("@project-serum/common");
const TokenInstructions = require("@project-serum/serum").TokenInstructions;

// TODO: remove this constant once @project-serum/serum uses the same version
//       of @solana/web3.js as anchor (or switch packages).
const TOKEN_PROGRAM_ID = new anchor.web3.PublicKey(
  TokenInstructions.TOKEN_PROGRAM_ID.toString()
);

// Our own sleep function.
function sleep(ms) {
  console.log("Sleeping for", ms / 1000, "seconds");
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function getTokenAccount(provider, addr) {
  return await serumCmn.getTokenAccount(provider, addr);
}

async function createMint(provider, authority) {
  if (authority === undefined) {
    authority = provider.wallet.publicKey;
  }
  const mint = await spl.Token.createMint(
    provider.connection,
    provider.wallet.payer,
    authority,
    null,
    6,
    TOKEN_PROGRAM_ID
  );
  return mint;
}

async function createTokenAccount(provider, mint, owner) {
  const token = new spl.Token(
    provider.connection,
    mint,
    TOKEN_PROGRAM_ID,
    provider.wallet.payer
  );
  let vault = await token.createAccount(owner);
  return vault;
}

module.exports = {
  TOKEN_PROGRAM_ID,
  sleep,
  getTokenAccount,
  createTokenAccount,
  createMint,
};


================================================
File: tests/lazy-account/Anchor.toml
================================================
[programs.localnet]
lazy_account = "LazyAccount11111111111111111111111111111111"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/lazy-account/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


================================================
File: tests/lazy-account/package.json
================================================
{
  "name": "lazy-account",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/lazy-account/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/lazy-account/programs/lazy-account/Cargo.toml
================================================
[package]
name = "lazy-account"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "lazy_account"

[features]
default = []
cpi = ["no-entrypoint"]
no-entrypoint = []
no-idl = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["lazy-account"] }


================================================
File: tests/lazy-account/programs/lazy-account/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/lazy-account/tests/lazy-account.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import assert from "assert";

import type { LazyAccount } from "../target/types/lazy_account";

describe("lazy-account", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program: anchor.Program<LazyAccount> = anchor.workspace.lazyAccount;

  it("Can init", async () => {
    const { pubkeys, signature } = await program.methods.init().rpcAndKeys();
    await program.provider.connection.confirmTransaction(
      signature,
      "confirmed"
    );
    const myAccount = await program.account.myAccount.fetch(pubkeys.myAccount);
    assert(myAccount.authority.equals(program.provider.publicKey!));
  });

  it("Can read", async () => {
    await program.methods.read().rpc();
  });

  it("Can write", async () => {
    const newAuthority = anchor.web3.PublicKey.default;
    const { pubkeys, signature } = await program.methods
      .write(newAuthority)
      .rpcAndKeys();
    await program.provider.connection.confirmTransaction(
      signature,
      "confirmed"
    );
    const myAccount = await program.account.myAccount.fetch(pubkeys.myAccount);
    assert(myAccount.authority.equals(newAuthority));
  });
});


================================================
File: tests/lockup/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
lockup = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
registry = "HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/lockup/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/lockup/package.json
================================================
{
  "name": "lockup",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/lockup/programs/lockup/Cargo.toml
================================================
[package]
name = "lockup"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "lockup"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/lockup/programs/lockup/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/lockup/programs/lockup/src/calculator.rs
================================================
//! Utility functions for calculating unlock schedules for a vesting account.

use crate::Vesting;

pub fn available_for_withdrawal(vesting: &Vesting, current_ts: i64) -> u64 {
    std::cmp::min(outstanding_vested(vesting, current_ts), balance(vesting))
}

// The amount of funds currently in the vault.
fn balance(vesting: &Vesting) -> u64 {
    vesting
        .outstanding
        .checked_sub(vesting.whitelist_owned)
        .unwrap()
}

// The amount of outstanding locked tokens vested. Note that these
// tokens might have been transferred to whitelisted programs.
fn outstanding_vested(vesting: &Vesting, current_ts: i64) -> u64 {
    total_vested(vesting, current_ts)
        .checked_sub(withdrawn_amount(vesting))
        .unwrap()
}

// Returns the amount withdrawn from this vesting account.
fn withdrawn_amount(vesting: &Vesting) -> u64 {
    vesting
        .start_balance
        .checked_sub(vesting.outstanding)
        .unwrap()
}

// Returns the total vested amount up to the given ts, assuming zero
// withdrawals and zero funds sent to other programs.
fn total_vested(vesting: &Vesting, current_ts: i64) -> u64 {
    if current_ts < vesting.start_ts {
        0
    } else if current_ts >= vesting.end_ts {
        vesting.start_balance
    } else {
        linear_unlock(vesting, current_ts).unwrap()
    }
}

fn linear_unlock(vesting: &Vesting, current_ts: i64) -> Option<u64> {
    // Signed division not supported.
    let current_ts = current_ts as u64;
    let start_ts = vesting.start_ts as u64;
    let end_ts = vesting.end_ts as u64;

    // If we can't perfectly partition the vesting window,
    // push the start of the window back so that we can.
    //
    // This has the effect of making the first vesting period shorter
    // than the rest.
    let shifted_start_ts =
        start_ts.checked_sub(end_ts.checked_sub(start_ts)? % vesting.period_count)?;

    // Similarly, if we can't perfectly divide up the vesting rewards
    // then make the first period act as a cliff, earning slightly more than
    // subsequent periods.
    let reward_overflow = vesting.start_balance % vesting.period_count;

    // Reward per period ignoring the overflow.
    let reward_per_period =
        (vesting.start_balance.checked_sub(reward_overflow)?).checked_div(vesting.period_count)?;

    // Number of vesting periods that have passed.
    let current_period = {
        let period_secs =
            (end_ts.checked_sub(shifted_start_ts)?).checked_div(vesting.period_count)?;
        let current_period_count =
            (current_ts.checked_sub(shifted_start_ts)?).checked_div(period_secs)?;
        std::cmp::min(current_period_count, vesting.period_count)
    };

    if current_period == 0 {
        return Some(0);
    }

    current_period
        .checked_mul(reward_per_period)?
        .checked_add(reward_overflow)
}


================================================
File: tests/lockup/programs/registry/Cargo.toml
================================================
[package]
name = "registry"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "registry"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
default = []

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }
lockup = { path = "../lockup", features = ["cpi"] }


================================================
File: tests/lockup/programs/registry/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/lockup/tests/utils.js
================================================
const anchor = require("@coral-xyz/anchor");
const serumCmn = require("@project-serum/common");

async function createBalanceSandbox(provider, r, registrySigner) {
  const spt = anchor.web3.Keypair.generate();
  const vault = anchor.web3.Keypair.generate();
  const vaultStake = anchor.web3.Keypair.generate();
  const vaultPw = anchor.web3.Keypair.generate();

  const lamports = await provider.connection.getMinimumBalanceForRentExemption(
    165
  );

  const createSptIx = await serumCmn.createTokenAccountInstrs(
    provider,
    spt.publicKey,
    r.poolMint,
    registrySigner,
    lamports
  );
  const createVaultIx = await serumCmn.createTokenAccountInstrs(
    provider,
    vault.publicKey,
    r.mint,
    registrySigner,
    lamports
  );
  const createVaultStakeIx = await serumCmn.createTokenAccountInstrs(
    provider,
    vaultStake.publicKey,
    r.mint,
    registrySigner,
    lamports
  );
  const createVaultPwIx = await serumCmn.createTokenAccountInstrs(
    provider,
    vaultPw.publicKey,
    r.mint,
    registrySigner,
    lamports
  );
  let tx0 = new anchor.web3.Transaction();
  tx0.add(
    ...createSptIx,
    ...createVaultIx,
    ...createVaultStakeIx,
    ...createVaultPwIx
  );
  let signers0 = [spt, vault, vaultStake, vaultPw];

  const tx = { tx: tx0, signers: signers0 };

  return [
    tx,
    {
      spt: spt.publicKey,
      vault: vault.publicKey,
      vaultStake: vaultStake.publicKey,
      vaultPw: vaultPw.publicKey,
    },
  ];
}

module.exports = {
  createBalanceSandbox,
};


================================================
File: tests/misc/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
init_if_needed = "BZoppwWi6jMnydnUBEJzotgEXHwLr3b3NramJgZtWeF2"
lamports = "Lamports11111111111111111111111111111111111"
misc = "3TEqcc8xhrhdspwbvoamUJe2borm4Nr72JxL66k6rgrh"
misc_optional = "FNqz6pqLAwvMSds2FYjR4nKV3moVpPNtvkfGFrqLKrgG"
overflow_checks = "overf1owChecks11111111111111111111111111111"
remaining_accounts = "RemainingAccounts11111111111111111111111111"

[workspace]
exclude = ["programs/shared"]


================================================
File: tests/misc/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/misc/ci.sh
================================================
#!/bin/sh

# this script ensures that the Misc test does not
# test the miscNonRentExempt.ts during its test in the ci
# because the misc test uses a newer solana version
# than the miscNonRentExempt one. The latter needs to be on
# a validator with a version < 1.9, so it can test
# whether anchor's rent-exemption checks work for
# legacy accounts which dont have to be rent-exempt
rm ./tests/misc/misc.ts
mv miscNonRentExempt.ts ./tests/misc/miscNonRentExempt.ts


================================================
File: tests/misc/package.json
================================================
{
  "name": "misc",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  },
  "dependencies": {
    "mocha": "9.2.2"
  }
}


================================================
File: tests/misc/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "node"],
    "lib": ["ES6"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/misc/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/misc/programs/init-if-needed/Cargo.toml
================================================
[package]
name = "init-if-needed"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "init_if_needed"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }


================================================
File: tests/misc/programs/init-if-needed/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/misc/programs/init-if-needed/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("BZoppwWi6jMnydnUBEJzotgEXHwLr3b3NramJgZtWeF2");

#[program]
pub mod init_if_needed {
    use super::*;

    // _val only used to make tx different so that it doesn't result
    // in dup tx error
    pub fn initialize(ctx: Context<Initialize>, _val: u8) -> Result<()> {
        ctx.accounts.acc.val = 1000;
        Ok(())
    }

    pub fn second_initialize(ctx: Context<SecondInitialize>, _val: u8) -> Result<()> {
        ctx.accounts.acc.other_val = 2000;
        Ok(())
    }

    pub fn close(ctx: Context<Close>) -> Result<()> {
        ctx.accounts.acc.val = 5000;
        Ok(())
    }
}

#[account]
pub struct MyData {
    pub val: u64,
}

#[account]
pub struct OtherData {
    pub other_val: u64,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init_if_needed, payer = payer, space = 8 + 8)]
    pub acc: Account<'info, MyData>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct SecondInitialize<'info> {
    #[account(init, payer = payer, space = 8 + 8)]
    pub acc: Account<'info, OtherData>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Close<'info> {
    #[account(mut, close = receiver)]
    pub acc: Account<'info, MyData>,
    /// CHECK: ignore
    #[account(mut)]
    pub receiver: UncheckedAccount<'info>,
}


================================================
File: tests/misc/programs/lamports/Cargo.toml
================================================
[package]
name = "lamports"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/misc/programs/lamports/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/misc/programs/lamports/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Lamports11111111111111111111111111111111111");

#[program]
pub mod lamports {
    use super::*;

    pub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {
        let pda = &ctx.accounts.pda;
        let signer = &ctx.accounts.signer;

        // Transfer **to** PDA
        {
            // Get the balance of the PDA **before** the transfer to PDA
            let pda_balance_before = pda.get_lamports();

            // Transfer to the PDA
            anchor_lang::system_program::transfer(
                CpiContext::new(
                    ctx.accounts.system_program.to_account_info(),
                    anchor_lang::system_program::Transfer {
                        from: signer.to_account_info(),
                        to: pda.to_account_info(),
                    },
                ),
                amount,
            )?;

            // Get the balance of the PDA **after** the transfer to PDA
            let pda_balance_after = pda.get_lamports();

            // Validate balance
            require_eq!(pda_balance_after, pda_balance_before + amount);
        }

        // Transfer **from** PDA
        {
            // Get the balance of the PDA **before** the transfer from PDA
            let pda_balance_before = pda.get_lamports();

            // Transfer from the PDA
            pda.sub_lamports(amount)?;
            signer.add_lamports(amount)?;

            // Get the balance of the PDA **after** the transfer from PDA
            let pda_balance_after = pda.get_lamports();

            // Validate balance
            require_eq!(pda_balance_after, pda_balance_before - amount);
        }

        Ok(())
    }

    // Return overflow error in the case of overflow (instead of panicking)
    pub fn overflow(ctx: Context<Overflow>) -> Result<()> {
        let pda = &ctx.accounts.pda;

        match pda.add_lamports(u64::MAX) {
            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),
            _ => unreachable!(),
        }

        match pda.sub_lamports(u64::MAX) {
            Err(e) => assert_eq!(e, ProgramError::ArithmeticOverflow.into()),
            _ => unreachable!(),
        }

        Ok(())
    }
}

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    pub signer: Signer<'info>,
    #[account(
        init,
        payer = signer,
        space = 8,
        seeds = [b"lamports"],
        bump
    )]
    pub pda: Account<'info, LamportsPda>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Overflow<'info> {
    #[account(seeds = [b"lamports"], bump)]
    pub pda: Account<'info, LamportsPda>,
}

#[account]
pub struct LamportsPda {}


================================================
File: tests/misc/programs/misc/Cargo.toml
================================================
[package]
name = "misc"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "misc"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]
my-feature = []

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }
anchor-spl = { path = "../../../../spl" }
bytemuck = { version = "1.4.0", features = ["derive", "min_const_generics"] }


================================================
File: tests/misc/programs/misc/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/misc/programs/misc/src/account.rs
================================================
use anchor_lang::prelude::*;

macro_rules! size {
    ($name: ident, $size:expr) => {
        impl $name {
            pub const LEN: usize = $size;
        }
    };
}

pub const MAX_SIZE: usize = 10;
pub const MAX_SIZE_U8: u8 = 11;

#[account]
pub struct Data {
    pub udata: u128, // 16
    pub idata: i128, // 16
}
size!(Data, 32);

#[account]
pub struct DataU16 {
    pub data: u16, // 2
}
size!(DataU16, 32);

#[account]
pub struct DataI8 {
    pub data: i8, // 1
}
size!(DataI8, 1);

#[account(zero_copy)]
pub struct DataZeroCopy {
    pub data: u16,    // 2
    pub _padding: u8, // 1
    pub bump: u8,     // 1
}
size!(DataZeroCopy, 4);

#[account]
pub struct DataWithFilter {
    pub authority: Pubkey,  // 32
    pub filterable: Pubkey, // 32
}
size!(DataWithFilter, 64);

#[account]
pub struct DataMultidimensionalArray {
    pub data: [[u8; 10]; 10], // 100
}
size!(DataMultidimensionalArray, 100);

#[account]
pub struct DataConstArraySize {
    pub data: [u8; MAX_SIZE], // 10
}
size!(DataConstArraySize, MAX_SIZE);

#[account]
pub struct DataConstCastArraySize {
    pub data_one: [u8; MAX_SIZE as usize],
    pub data_two: [u8; MAX_SIZE_U8 as usize],
}

#[account]
pub struct DataMultidimensionalArrayConstSizes {
    pub data: [[u8; MAX_SIZE_U8 as usize]; MAX_SIZE],
}

#[account]
pub struct CoolEnumWrapperAccount {
    pub my_enum: CoolEnum,
}

#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub enum CoolEnum {
    Variant1,
    Variant2 {
        config: u8,
        user_1: Pubkey,
        some_slot: u64,
    },
    Variant3 {
        config: u8,
        user_1: Pubkey,
        user_2: Pubkey,
        some_slot: u64,
    },
}

#[derive(Debug, Clone, Copy, AnchorSerialize, AnchorDeserialize, PartialEq, Eq)]
pub struct TestStruct {
    pub data1: u8,
    pub data2: u16,
    pub data3: u32,
    pub data4: u64,
}


================================================
File: tests/misc/programs/misc/src/event.rs
================================================
use anchor_lang::prelude::*;

pub const MAX_EVENT_SIZE: usize = 10;
pub const MAX_EVENT_SIZE_U8: u8 = 11;

#[event]
pub struct E1 {
    pub data: u32,
}

#[event]
pub struct E2 {
    pub data: u32,
}

#[event]
pub struct E3 {
    pub data: u32,
}

#[event]
pub struct E4 {
    pub data: Pubkey,
}

#[event]
pub struct E5 {
    pub data: [u8; MAX_EVENT_SIZE],
}

#[event]
pub struct E6 {
    pub data: [u8; MAX_EVENT_SIZE_U8 as usize],
}


================================================
File: tests/misc/programs/misc-optional/Cargo.toml
================================================
[package]
name = "misc-optional"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "misc_optional"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }
anchor-spl = { path = "../../../../spl" }
bytemuck = { version = "1.4.0", features = ["derive", "min_const_generics"] }


================================================
File: tests/misc/programs/misc-optional/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/misc/programs/misc-optional/src/account.rs
================================================
use anchor_lang::prelude::*;

macro_rules! size {
    ($name: ident, $size:expr) => {
        impl $name {
            pub const LEN: usize = $size;
        }
    };
}

pub const MAX_SIZE: usize = 10;
pub const MAX_SIZE_U8: u8 = 11;

#[account]
pub struct Data {
    pub udata: u128, // 16
    pub idata: i128, // 16
}
size!(Data, 32);

#[account]
pub struct DataU16 {
    pub data: u16, // 2
}
size!(DataU16, 32);

#[account]
pub struct DataI8 {
    pub data: i8, // 1
}
size!(DataI8, 1);

#[account(zero_copy)]
pub struct DataZeroCopy {
    pub data: u16,    // 2
    pub _padding: u8, // 1
    pub bump: u8,     // 1
}
size!(DataZeroCopy, 4);

#[account]
pub struct DataWithFilter {
    pub authority: Pubkey,  // 32
    pub filterable: Pubkey, // 32
}
size!(DataWithFilter, 64);

#[account]
pub struct DataMultidimensionalArray {
    pub data: [[u8; 10]; 10], // 100
}
size!(DataMultidimensionalArray, 100);

#[account]
pub struct DataConstArraySize {
    pub data: [u8; MAX_SIZE], // 10
}
size!(DataConstArraySize, MAX_SIZE);

#[account]
pub struct DataConstCastArraySize {
    pub data_one: [u8; MAX_SIZE as usize],
    pub data_two: [u8; MAX_SIZE_U8 as usize],
}

#[account]
pub struct DataMultidimensionalArrayConstSizes {
    pub data: [[u8; MAX_SIZE_U8 as usize]; MAX_SIZE],
}


================================================
File: tests/misc/programs/misc-optional/src/event.rs
================================================
use anchor_lang::prelude::*;

pub const MAX_EVENT_SIZE: usize = 10;
pub const MAX_EVENT_SIZE_U8: u8 = 11;

#[event]
pub struct E1 {
    pub data: u32,
}

#[event]
pub struct E2 {
    pub data: u32,
}

#[event]
pub struct E3 {
    pub data: u32,
}

#[event]
pub struct E4 {
    pub data: Pubkey,
}

#[event]
pub struct E5 {
    pub data: [u8; MAX_EVENT_SIZE],
}

#[event]
pub struct E6 {
    pub data: [u8; MAX_EVENT_SIZE_U8 as usize],
}


================================================
File: tests/misc/programs/overflow-checks/Cargo.toml
================================================
[package]
name = "overflow-checks"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "overflow_checks"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/misc/programs/overflow-checks/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/misc/programs/remaining-accounts/Cargo.toml
================================================
[package]
name = "remaining-accounts"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "remaining_accounts"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["init-if-needed"] }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/misc/programs/remaining-accounts/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/misc/programs/remaining-accounts/src/account.rs
================================================
use anchor_lang::prelude::*;

#[account]
#[derive(InitSpace)]
pub struct Data {
    pub someone: Pubkey,
}

#[account]
#[derive(InitSpace)]
pub struct Another {}


================================================
File: tests/misc/programs/remaining-accounts/src/context.rs
================================================
use crate::account::*;
use anchor_lang::prelude::*;
use anchor_spl::token::Token;

#[derive(Accounts)]
pub struct TestInit<'info> {
    #[account(init, payer = payer, space = Data::INIT_SPACE + 8)]
    pub data: Account<'info, Data>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TestInitAnother<'info> {
    #[account(init, payer = payer, space = Data::INIT_SPACE + 8)]
    pub another: Account<'info, Another>,
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TestRemainingAccounts<'info> {
    pub token_program: Program<'info, Token>,
}


================================================
File: tests/misc/programs/remaining-accounts/src/lib.rs
================================================
//! Testing of handling of remaining accounts with anchor Account structs

use account::*;
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;
use context::*;

mod account;
mod context;

declare_id!("RemainingAccounts11111111111111111111111111");

#[program]
pub mod remaining_accounts {
    use super::*;

    pub fn test_init(_ctx: Context<TestInit>) -> Result<()> {
        Ok(())
    }

    pub fn test_init_another(_ctx: Context<TestInitAnother>) -> Result<()> {
        Ok(())
    }

    pub fn test_remaining_accounts<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, TestRemainingAccounts>,
    ) -> Result<()> {
        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        let token_account =
            Account::<TokenAccount>::try_from(next_account_info(remaining_accounts_iter)?)?;

        let data_account_info = next_account_info(remaining_accounts_iter)?;
        require_eq!(data_account_info.is_writable, true);
        let mut data = Account::<Data>::try_from(data_account_info)?;

        data.someone = token_account.owner;
        data.exit(ctx.program_id)?;

        Ok(())
    }
}


================================================
File: tests/misc/programs/shared/Cargo.toml
================================================
[package]
name = "shared"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]


================================================
File: tests/misc/programs/shared/src/lib.rs
================================================
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}


================================================
File: tests/misc/tests/init-if-needed/Test.toml
================================================
[scripts]
test = "yarn run ts-mocha -t 1000000 ./tests/init-if-needed/*.ts"


================================================
File: tests/misc/tests/lamports/Test.toml
================================================
[scripts]
test = "yarn run ts-mocha -t 1000000 ./tests/lamports/*.ts"


================================================
File: tests/misc/tests/lamports/lamports.ts
================================================
import * as anchor from "@coral-xyz/anchor";

import { Lamports } from "../../target/types/lamports";

describe("lamports", () => {
  // Configure the client to use the local cluster
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.Lamports as anchor.Program<Lamports>;

  it("Can transfer from/to PDA", async () => {
    await program.methods
      .transfer(new anchor.BN(anchor.web3.LAMPORTS_PER_SOL))
      .rpc();
  });

  it("Returns an error on overflow", async () => {
    await program.methods.overflow().rpc();
  });
});


================================================
File: tests/misc/tests/misc/Test.toml
================================================
[[test.genesis]]
address = "FtMNMKp9DZHKWUyVAsj3Q5QV8ow4P3fUPP7ZrWEQJzKr"
program = "../../target/deploy/misc.so"

[scripts]
test = "yarn run ts-mocha -t 1000000 ./tests/misc/*.ts"


================================================
File: tests/misc/tests/overflow-checks/Test.toml
================================================
[scripts]
test = "yarn run ts-mocha -t 1000000 ./tests/overflow-checks/*.ts"


================================================
File: tests/misc/tests/overflow-checks/overflow-checks.ts
================================================
import * as anchor from "@coral-xyz/anchor";

import { OverflowChecks } from "../../target/types/overflow_checks";

describe("overflow-checks", () => {
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace
    .OverflowChecks as anchor.Program<OverflowChecks>;

  const accountKp = anchor.web3.Keypair.generate();
  const testOverflow = async (method: keyof typeof program["methods"]) => {
    try {
      await program.methods[method]()
        .accounts({
          account: accountKp.publicKey,
        })
        .rpc();
    } catch (e) {
      if (e.logs.some((log) => log.includes("with overflow"))) return;
      throw e;
    }

    throw new Error("Did not panic on overflow");
  };

  before(async () => {
    await program.methods
      .initialize()
      .accounts({
        account: accountKp.publicKey,
        payer: program.provider.publicKey,
      })
      .signers([accountKp])
      .rpc();
  });

  it("Panics on overflow add", async () => {
    await testOverflow("testOverflowAdd");
  });

  it("Panics on overflow sub", async () => {
    await testOverflow("testOverflowSub");
  });

  it("Panics on overflow mul", async () => {
    await testOverflow("testOverflowMul");
  });

  it("Fails to build when `overflow-checks` is not explicitly specified", async () => {
    const fs = await import("fs/promises");
    const cargoToml = await fs.readFile("Cargo.toml", { encoding: "utf8" });
    const CHECK = "overflow-checks = true";
    const COMMENTED_CHECK = "#" + CHECK;
    await fs.writeFile("Cargo.toml", cargoToml.replace(CHECK, COMMENTED_CHECK));

    const { spawnSync } = await import("child_process");
    const { stderr, status } = spawnSync("anchor", ["build"]);

    try {
      if (status === 0) {
        throw new Error(
          "Did not fail even though `overflow-checks` is not specified"
        );
      }

      if (!stderr.includes("Error: `overflow-checks` is not enabled")) {
        throw new Error(`Did not throw the correct overflow error:\n${stderr}`);
      }
    } catch (e) {
      throw e;
    } finally {
      await fs.writeFile(
        "Cargo.toml",
        cargoToml.replace(COMMENTED_CHECK, CHECK)
      );
    }
  });
});


================================================
File: tests/misc/tests/remaining-accounts/Test.toml
================================================
[scripts]
test = "yarn run ts-mocha -t 1000000 ./tests/remaining-accounts/*.ts"


================================================
File: tests/multiple-suites/Anchor.toml
================================================
[features]
seeds = false
[programs.localnet]
multiple_suites = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[test]
startup_wait = 20000

[[test.validator.account]]
address = "3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj"
filename = "./tests/accounts/SOME_ACCOUNT.json"


================================================
File: tests/multiple-suites/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/multiple-suites/package.json
================================================
{
  "name": "multiple-suites",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/multiple-suites/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/multiple-suites/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/multiple-suites/programs/multiple-suites/Cargo.toml
================================================
[package]
name = "multiple-suites"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "multiple_suites"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/multiple-suites/programs/multiple-suites/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/multiple-suites/programs/multiple-suites/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod multiple_suites {
    use super::*;

    // _val to ensure tx are different so they don't get rejected.
    pub fn initialize(_ctx: Context<Initialize>, _val: u64) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/multiple-suites/tests/Test.base.toml
================================================
extends = ["./Test.root.base.toml"]

[[test.validator.account]]
address = "C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw"
filename = "./accounts/SOME_TOKEN.json"


================================================
File: tests/multiple-suites/tests/Test.root.base.toml
================================================
[test]
startup_wait = 20000

[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"

[[test.validator.account]]
address = "JC7Vcye5upE6tMLAjAem76MCGuPNidTtg2cuYm71UukH"
filename = "./accounts/ANOTHER_ACC.json"


================================================
File: tests/multiple-suites/tests/accounts/ANOTHER_ACC.json
================================================
{
  "pubkey": "JC7Vcye5upE6tMLAjAem76MCGuPNidTtg2cuYm71UukH",
  "account": {
    "lamports": 1141440,
    "data": [
      "AgAAALd5VermN3GAImByma8xRkcfPsbJkljqjdkZwDg8igZy",
      "base64"
    ],
    "owner": "BPFLoaderUpgradeab1e11111111111111111111111",
    "executable": true,
    "rentEpoch": 211
  }
}

================================================
File: tests/multiple-suites/tests/accounts/SOME_ACCOUNT.json
================================================
{
  "pubkey": "3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj",
  "account": {
    "lamports": 7906560,
    "data": [
      "oZzT/fpANfoAAAacjYHHz87iGrP2++EgvfsQjuGvj1dqAHoCKU9FPDLg9bWjnUCkIZgQQSmJpClN5jbVq6JbdM4Ec4ZpEb2ViTzO//sSNXmZhK5OA5kiKWvPWoUsXExQpNgiaEeW8MWANStiNrxKs/p6yWv9cqbJBd6AygqKx0Y7WysO04FMaSFa/6o5Lt/NyPH8jkM12IYJcvGzIQIbaXRo9eDbJOcPskyugDoJAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQMAAAAAAAB4AQAAAAAAAHIDAAAAAAAAcgMAAAAAAAABAAAAAAAAAAjqplnVZa4ZML82vxalcFuNRlmUiSpI+ZGRVoMP+eF1hDOHYqnPMZXS8rUwGGcq0p98MYBGv4V+9NsD84s31F0BRTMAAAAAAAAAAACAOgkAAAAAAPySPwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8Cd4FAAAAAL4E7wIAAAAA6pstAQAAAAAAAR0AAAAAALHFQ2IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAabiFf+q4GE+2h/Y0YYwDXaxDncGus7VZig8AAAAAABb8MVpWsIyg7EhPN8Vhh8GnNx3+zvD0Kz0wqIECi79vwBAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
      "base64"
    ],
    "owner": "7NryUmAmy8hMbawRNUs9UdkgAGEiHFxghSfve31dC7xh",
    "executable": false,
    "rentEpoch": 292
  }
}

================================================
File: tests/multiple-suites/tests/accounts/SOME_TOKEN.json
================================================
{
  "pubkey": "C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw",
  "account": {
    "lamports": 839123197950,
    "data": [
      "AAAAAFnkpzMo+KIHXFu0C7POimfWZAwz81Y+ImohwO+lC39o2tFLxYmAIwAGAQAAAABZ5KczKPiiB1xbtAuzzopn1mQMM/NWPiJqIcDvpQt/aA==",
      "base64"
    ],
    "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "executable": false,
    "rentEpoch": 292
  }
}


================================================
File: tests/multiple-suites/tests/another-suite/Test.toml
================================================
extends = ["../Test.base.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/another-suite/**/*.ts"


================================================
File: tests/multiple-suites/tests/another-suite/another-suite.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { assert } from "chai";
import { MultipleSuites } from "../../target/types/multiple_suites";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(100000), {});

    // SOME_TOKEN.json should exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should NOT exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    // ANOTHER_ACC.json should exist.
    const ANOTHER_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("JC7Vcye5upE6tMLAjAem76MCGuPNidTtg2cuYm71UukH")
    );

    // CLONED ACC should exist.
    const CLONED_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
    );

    assert.isNotNull(SOME_TOKEN);
    assert.isNull(SOME_ACCOUNT);
    assert.isNotNull(ANOTHER_ACC);
    assert.isNotNull(CLONED_ACC);

    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites/tests/fourth-and-fifth-suite/fifth-suite/Test.toml
================================================
extends = ["../../Test.base.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/fourth-and-fifth-suite/fifth-suite/**/*.ts"


================================================
File: tests/multiple-suites/tests/fourth-and-fifth-suite/fifth-suite/fifthSuite.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { assert } from "chai";
import { MultipleSuites } from "../../../target/types/multiple_suites";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(4389242), {});

    // SOME_TOKEN.json should exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should NOT exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    // ANOTHER_ACC.json should exist.
    const ANOTHER_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("JC7Vcye5upE6tMLAjAem76MCGuPNidTtg2cuYm71UukH")
    );

    // CLONED ACC should exist.
    const CLONED_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
    );

    assert.isNotNull(SOME_TOKEN);
    assert.isNull(SOME_ACCOUNT);
    assert.isNotNull(ANOTHER_ACC);
    assert.isNotNull(CLONED_ACC);
    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites/tests/fourth-and-fifth-suite/forth-suite/Test.toml
================================================
extends = ["../../Test.base.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/fourth-and-fifth-suite/forth-suite/**/*.ts"


================================================
File: tests/multiple-suites/tests/fourth-and-fifth-suite/forth-suite/forth-suite.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { assert } from "chai";
import { MultipleSuites } from "../../../target/types/multiple_suites";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(34823), {});

    // SOME_TOKEN.json should exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should NOT exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    // ANOTHER_ACC.json should exist.
    const ANOTHER_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("JC7Vcye5upE6tMLAjAem76MCGuPNidTtg2cuYm71UukH")
    );

    // CLONED ACC should exist.
    const CLONED_ACC = await program.provider.connection.getAccountInfo(
      new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
    );

    assert.isNotNull(SOME_TOKEN);
    assert.isNull(SOME_ACCOUNT);
    assert.isNotNull(ANOTHER_ACC);
    assert.isNotNull(CLONED_ACC);
    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites/tests/multiple-suites/Test.toml
================================================
extends = ["../../Anchor.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/multiple-suites/**/*.ts"


================================================
File: tests/multiple-suites/tests/multiple-suites/multiple-suites.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { assert } from "chai";
import { MultipleSuites } from "../../target/types/multiple_suites";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(2394832), {});

    // SOME_TOKEN.json should NOT exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    assert.isNull(SOME_TOKEN);
    assert.isNotNull(SOME_ACCOUNT);

    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites/tests/third-suite/Test.toml
================================================
extends = ["../Test.base.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/third-suite/**/*.ts"


================================================
File: tests/multiple-suites/tests/third-suite/sub-dir-one/subDirOne.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { MultipleSuites } from "../../../target/types/multiple_suites";
import { assert } from "chai";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(347234), {});

    // SOME_TOKEN.json should exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should NOT exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    assert.isNotNull(SOME_TOKEN);
    assert.isNull(SOME_ACCOUNT);

    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites/tests/third-suite/sub-dir-two/subDirTwo.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { assert } from "chai";
import { MultipleSuites } from "../../../target/types/multiple_suites";

describe("multiple-suites", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.MultipleSuites as Program<MultipleSuites>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.rpc.initialize(new anchor.BN(9348239), {});

    // SOME_TOKEN.json should exist.
    const SOME_TOKEN = await program.provider.connection.getAccountInfo(
      new PublicKey("C4XeBpzX4tDjGV1gkLsj7jJh6XHunVqAykANWCfTLszw")
    );

    // SOME_ACCOUNT.json should NOT exist.
    const SOME_ACCOUNT = await program.provider.connection.getAccountInfo(
      new PublicKey("3vMPj13emX9JmifYcWc77ekEzV1F37ga36E1YeSr6Mdj")
    );

    assert.isNotNull(SOME_TOKEN);
    assert.isNull(SOME_ACCOUNT);

    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multiple-suites-run-single/Anchor.toml
================================================
[features]
seeds = false
[programs.localnet]
multiple_suites_run_single = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[test]
startup_wait = 20000


================================================
File: tests/multiple-suites-run-single/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/multiple-suites-run-single/package.json
================================================
{
  "name": "multiple-suites-run-single",
  "version": "0.24.2",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/multiple-suites-run-single/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/multiple-suites-run-single/programs/multiple-suites-run-single/Cargo.toml
================================================
[package]
name = "multiple-suites-run-single"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "multiple_suites_run_single"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/multiple-suites-run-single/programs/multiple-suites-run-single/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/multiple-suites-run-single/programs/multiple-suites-run-single/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod multiple_suites_run_single {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/multiple-suites-run-single/tests/should-not-run/Test.toml
================================================
extends = ["../../Anchor.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/should-not-run/**/*.ts"


================================================
File: tests/multiple-suites-run-single/tests/should-not-run/shouldNotRun.ts
================================================
describe("multiple-suites-run-single", () => {
  it("Should not be executed", async () => {
    throw new Error("This test has to be skipped");
  });
});


================================================
File: tests/multiple-suites-run-single/tests/should-run/Test.toml
================================================
extends = ["../../Anchor.toml"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/should-run/**/*.ts"


================================================
File: tests/multiple-suites-run-single/tests/should-run/shouldRun.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { assert } from "chai";
import { MultipleSuitesRunSingle } from "../../target/types/multiple_suites_run_single";

describe("multiple-suites-run-single", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace
    .MultipleSuitesRunSingle as Program<MultipleSuitesRunSingle>;

  it("Is initialized!", async () => {
    const tx = await program.methods.initialize().rpc();
    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/multisig/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
multisig = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/multisig/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/multisig/package.json
================================================
{
  "name": "multisig",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/multisig/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/multisig/programs/multisig/Cargo.toml
================================================
[package]
name = "multisig"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "multisig"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/multisig/programs/multisig/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/optional/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
optional = "FNqz6pqLAwvMSds2FYjR4nKV3moVpPNtvkfGFrqLKrgG"
allow_missing_optionals = "ErjUjtqKE5AGWUsjseSJCVLtddM6rhaMbDqmhzraF9h6"

[workspace]
members = ["programs/optional", "programs/allow-missing-optionals"]

[scripts]
test = "yarn run ts-mocha -t 1000000 -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/optional/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/optional/package.json
================================================
{
  "name": "optional",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/optional/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  }
}


================================================
File: tests/optional/programs/allow-missing-optionals/Cargo.toml
================================================
[package]
name = "allow-missing-optionals"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "allow_missing_optionals"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang", features = ["allow-missing-optionals"] }


================================================
File: tests/optional/programs/allow-missing-optionals/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/optional/programs/allow-missing-optionals/src/lib.rs
================================================
//! This tests that the `allow-missing-optionals` feature works

use anchor_lang::prelude::*;

declare_id!("ErjUjtqKE5AGWUsjseSJCVLtddM6rhaMbDqmhzraF9h6");

#[program]
mod allow_missing_optionals {
    use super::*;

    pub fn do_stuff(ctx: Context<DoStuff>) -> Result<()> {
        msg!("Doing stuff...");
        let optional_2 = &mut ctx.accounts.optional_2;
        if let Some(data_account) = optional_2 {
            data_account.data = 42;
        }

        Ok(())
    }
}

#[account]
pub struct DataAccount {
    pub data: u64,
}

impl DataAccount {
    pub const LEN: usize = 8 + 8;
}

#[derive(Accounts)]
pub struct DoStuff<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Option<Program<'info, System>>,
    #[account(init, payer = payer, space = DataAccount::LEN)]
    pub optional_2: Option<Account<'info, DataAccount>>,
}


================================================
File: tests/optional/programs/optional/Cargo.toml
================================================
[package]
name = "optional"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "optional"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/optional/programs/optional/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/optional/programs/optional/src/account.rs
================================================
use anchor_lang::prelude::*;

#[account]
pub struct DataPda {
    pub data_account: Pubkey,
}

impl DataPda {
    pub const LEN: usize = 8 + 32;
    pub const PREFIX: &'static str = "data_pda";
}

#[account]
pub struct DataAccount {
    pub data: u64,
}

impl DataAccount {
    pub const LEN: usize = 8 + 8;
}


================================================
File: tests/optional/programs/optional/src/context.rs
================================================
use crate::account::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Option<Signer<'info>>,
    #[account(init, payer = payer, space = DataAccount::LEN, constraint = payer.is_some())]
    pub optional_account: Option<Box<Account<'info, DataAccount>>>,
    pub system_program: Option<Program<'info, System>>,
    #[account(zero)]
    pub required: Account<'info, DataAccount>,
    #[account(init, seeds=[DataPda::PREFIX.as_bytes(), optional_account.as_ref().unwrap().key().as_ref()], bump, payer=payer, space=DataPda::LEN)]
    pub optional_pda: Option<Account<'info, DataPda>>,
}

#[derive(Accounts)]
#[instruction(value: u64, key: Pubkey, pda_bump: u8)]
pub struct Update<'info> {
    #[account(mut)]
    pub payer: Option<Signer<'info>>,
    #[account(mut, seeds=[DataPda::PREFIX.as_bytes(), optional_account.as_ref().unwrap().key().as_ref()], bump = pda_bump)]
    pub optional_pda: Option<Account<'info, DataPda>>,
    #[account(mut, signer, constraint = payer.is_some())]
    pub optional_account: Option<Box<Account<'info, DataAccount>>>,
}

#[derive(Accounts)]
#[instruction(new_size: u64)]
pub struct Realloc<'info> {
    #[account(mut)]
    pub payer: Option<Signer<'info>>,
    #[account(mut, realloc = new_size as usize, realloc::payer = payer, realloc::zero = false)]
    pub optional_pda: Option<Account<'info, DataPda>>,
    pub required: Account<'info, DataAccount>,
    pub system_program: Option<Program<'info, System>>,
    #[account(mut, signer, realloc = new_size as usize, realloc::payer = payer, realloc::zero = true)]
    pub optional_account: Option<Account<'info, DataAccount>>,
}

#[derive(Accounts)]
pub struct Close<'info> {
    #[account(mut)]
    pub payer: Option<Signer<'info>>,
    #[account(mut, close = payer, has_one = data_account)]
    pub optional_pda: Option<Box<Account<'info, DataPda>>>,
    #[account(mut, signer, close = payer)]
    pub data_account: Option<Account<'info, DataAccount>>,
    pub system_program: Option<Program<'info, System>>,
}


================================================
File: tests/optional/programs/optional/src/lib.rs
================================================
//! This example demonstrates the ability to use optional accounts in
//! structs deriving `Accounts`.

use anchor_lang::prelude::*;
pub use context::*;

pub mod account;
pub mod context;
declare_id!("FNqz6pqLAwvMSds2FYjR4nKV3moVpPNtvkfGFrqLKrgG");

#[program]
mod optional {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, value: u64, key: Pubkey) -> Result<()> {
        let optional_pda = &mut ctx.accounts.optional_pda;
        let optional_account = &mut ctx.accounts.optional_account;
        let required = &mut ctx.accounts.required;

        required.data = 0;

        if let Some(data_account) = optional_account {
            if let Some(data_pda) = optional_pda {
                data_pda.data_account = key;
                data_account.data = value;
            } else {
                data_account.data = value * 2;
            }
        }

        Ok(())
    }

    pub fn update(ctx: Context<Update>, value: u64, key: Pubkey, _pda_bump: u8) -> Result<()> {
        if let Some(data_account) = &mut ctx.accounts.optional_account {
            data_account.data = value;
        }
        if let Some(data_account) = &mut ctx.accounts.optional_pda {
            data_account.data_account = key;
        }
        Ok(())
    }

    pub fn realloc(ctx: Context<Realloc>, new_size: u64) -> Result<()> {
        let optional_pda = &ctx.accounts.optional_pda;
        let optional_account = &ctx.accounts.optional_account;
        if let Some(data_pda) = optional_pda {
            let len = data_pda.to_account_info().data_len();
            if len != new_size as usize {
                return err!(OptionalErrors::ReallocFailed);
            }
        }
        if let Some(data_account) = optional_account {
            let len = data_account.to_account_info().data_len();
            if len != new_size as usize {
                return err!(OptionalErrors::ReallocFailed);
            }
        }
        Ok(())
    }

    pub fn close(_ctx: Context<Close>) -> Result<()> {
        Ok(())
    }
}

#[error_code]
pub enum OptionalErrors {
    #[msg("Failed realloc")]
    ReallocFailed,
}


================================================
File: tests/pda-derivation/Anchor.toml
================================================
[features]
seeds = true

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
pda_derivation = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[workspace]
members = ["programs/pda-derivation"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/pda-derivation/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/pda-derivation/package.json
================================================
{
  "name": "pda-derivation",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/pda-derivation/tsconfig.json
================================================
{
  "include": ["./target/types/pda_derivation.ts"],
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/pda-derivation/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
  async function deployAsync(exampleString: string): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log(exampleString);
        resolve();
      }, 2000);
    });
  }

  await deployAsync("Typescript migration example complete.");
};


================================================
File: tests/pda-derivation/programs/pda-derivation/Cargo.toml
================================================
[package]
name = "pda-derivation"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "pda_derivation"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/pda-derivation/programs/pda-derivation/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/pda-derivation/programs/pda-derivation/src/other.rs
================================================
use anchor_lang::prelude::*;

#[account]
pub struct AnotherBaseAccount {
    pub data: u64,
}


================================================
File: tests/pyth/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
pyth = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[features]


================================================
File: tests/pyth/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/pyth/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/pyth/package.json
================================================
{
  "name": "pyth",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/pyth/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/pyth/programs/pyth/Cargo.toml
================================================
[package]
name = "pyth"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "pyth"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
arrayref = "0.3.6"
bytemuck = { version = "1.4.0" }


================================================
File: tests/pyth/programs/pyth/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/pyth/programs/pyth/src/lib.rs
================================================
use anchor_lang::prelude::*;
mod pc;
use pc::Price;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod pyth {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, price: i64, expo: i32, conf: u64) -> Result<()> {
        let oracle = &ctx.accounts.price;

        let mut price_oracle = Price::load(&oracle).unwrap();

        price_oracle.agg.price = price;
        price_oracle.agg.conf = conf;
        price_oracle.expo = expo;
        price_oracle.ptype = pc::PriceType::Price;
        Ok(())
    }

    pub fn set_price(ctx: Context<SetPrice>, price: i64) -> Result<()> {
        let oracle = &ctx.accounts.price;
        let mut price_oracle = Price::load(&oracle).unwrap();
        price_oracle.agg.price = price as i64;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct SetPrice<'info> {
    #[account(mut)]
    pub price: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub price: AccountInfo<'info>,
}


================================================
File: tests/pyth/tests/pyth.spec.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { BN, Program, web3 } from "@coral-xyz/anchor";
import { assert } from "chai";
import { createPriceFeed, setFeedPrice, getFeedData } from "./oracleUtils";

describe("pyth-oracle", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.Pyth as Program;

  it("initialize", async () => {
    const price = 50000;
    const priceFeedAddress = await createPriceFeed({
      oracleProgram: program,
      initPrice: price,
      expo: -6,
      provider,
    });
    const feedData = await getFeedData(program, priceFeedAddress);
    assert.strictEqual(feedData.price, price);
  });

  it("change feed price", async () => {
    const price = 50000;
    const expo = -7;
    const priceFeedAddress = await createPriceFeed({
      oracleProgram: program,
      initPrice: price,
      expo: expo,
      provider,
    });
    const feedDataBefore = await getFeedData(program, priceFeedAddress);
    assert.strictEqual(feedDataBefore.price, price);
    assert.strictEqual(feedDataBefore.exponent, expo);

    const newPrice = 55000;
    await setFeedPrice(program, newPrice, priceFeedAddress);
    const feedDataAfter = await getFeedData(program, priceFeedAddress);
    assert.strictEqual(feedDataAfter.price, newPrice);
    assert.strictEqual(feedDataAfter.exponent, expo);
  });
});


================================================
File: tests/realloc/Anchor.toml
================================================
[features]
seeds = false

[programs.localnet]
realloc = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

================================================
File: tests/realloc/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/realloc/package.json
================================================
{
  "name": "realloc",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/realloc/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/realloc/programs/realloc/Cargo.toml
================================================
[package]
name = "realloc"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "realloc"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[profile.release]
overflow-checks = true

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/realloc/programs/realloc/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/realloc/programs/realloc/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod realloc {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        ctx.accounts.sample.data = vec![0];
        ctx.accounts.sample.bump = ctx.bumps.sample;
        Ok(())
    }

    pub fn realloc(ctx: Context<Realloc>, len: u16) -> Result<()> {
        ctx.accounts
            .sample
            .data
            .resize_with(len as usize, Default::default);
        Ok(())
    }

    pub fn realloc2(ctx: Context<Realloc2>, len: u16) -> Result<()> {
        ctx.accounts
            .sample1
            .data
            .resize_with(len as usize, Default::default);

        ctx.accounts
            .sample2
            .data
            .resize_with(len as usize, Default::default);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        seeds = [b"sample"],
        bump,
        space = Sample::space(1),
    )]
    pub sample: Account<'info, Sample>,

    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(len: u16)]
pub struct Realloc<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"sample"],
        bump = sample.bump,
        realloc = Sample::space(len as usize),
        realloc::payer = authority,
        realloc::zero = false,
    )]
    pub sample: Account<'info, Sample>,

    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
#[instruction(len: u16)]
pub struct Realloc2<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        mut,
        seeds = [b"sample"],
        bump = sample1.bump,
        realloc = Sample::space(len as usize),
        realloc::payer = authority,
        realloc::zero = false,
    )]
    pub sample1: Account<'info, Sample>,

    #[account(
        mut,
        seeds = [b"sample"],
        bump = sample2.bump,
        realloc = Sample::space((len + 10) as usize),
        realloc::payer = authority,
        realloc::zero = false,
    )]
    pub sample2: Account<'info, Sample>,

    pub system_program: Program<'info, System>,
}

#[account]
pub struct Sample {
    pub data: Vec<u8>,
    pub bump: u8,
}

impl Sample {
    pub fn space(len: usize) -> usize {
        8 + (4 + len) + 1
    }
}


================================================
File: tests/realloc/tests/realloc.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { AnchorError, Program } from "@coral-xyz/anchor";
import { assert } from "chai";
import { Realloc } from "../target/types/realloc";

describe("realloc", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.Realloc as Program<Realloc>;
  const authority = (program.provider as any).wallet
    .payer as anchor.web3.Keypair;

  let sample: anchor.web3.PublicKey;

  before(async () => {
    [sample] = await anchor.web3.PublicKey.findProgramAddress(
      [Buffer.from("sample")],
      program.programId
    );
  });

  it("initialized", async () => {
    await program.methods
      .initialize()
      .accounts({ authority: authority.publicKey, sample })
      .rpc();

    const samples = await program.account.sample.all();
    assert.lengthOf(samples, 1);
    assert.lengthOf(samples[0].account.data, 1);
  });

  it("fails if delta bytes exceeds permitted limit", async () => {
    try {
      await program.methods
        .realloc(10250)
        .accounts({ authority: authority.publicKey, sample })
        .rpc();
      assert.ok(false);
    } catch (e) {
      assert.isTrue(e instanceof AnchorError);
      const err: AnchorError = e;
      const errMsg =
        "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit";
      assert.strictEqual(err.error.errorMessage, errMsg);
      assert.strictEqual(err.error.errorCode.number, 3016);
    }
  });

  it("realloc additive", async () => {
    await program.methods
      .realloc(5)
      .accounts({ authority: authority.publicKey, sample })
      .rpc();

    const s = await program.account.sample.fetch(sample);
    assert.lengthOf(s.data, 5);
  });

  it("realloc substractive", async () => {
    await program.methods
      .realloc(1)
      .accounts({ authority: authority.publicKey, sample })
      .rpc();

    const s = await program.account.sample.fetch(sample);
    assert.lengthOf(s.data, 1);
  });

  it("fails with duplicate account reallocations", async () => {
    try {
      await program.methods
        .realloc2(1000)
        .accounts({
          authority: authority.publicKey,
          sample1: sample,
          sample2: sample,
        })
        .rpc();
    } catch (e) {
      assert.isTrue(e instanceof AnchorError);
      const err: AnchorError = e;
      const errMsg =
        "The account was duplicated for more than one reallocation";
      assert.strictEqual(err.error.errorMessage, errMsg);
      assert.strictEqual(err.error.errorCode.number, 3017);
    }
  });
});


================================================
File: tests/relations-derivation/Anchor.toml
================================================
[features]
seeds = true

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
relations_derivation = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[workspace]
members = ["programs/relations-derivation"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/relations-derivation/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/relations-derivation/package.json
================================================
{
  "name": "relations-derivation",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/relations-derivation/tsconfig.json
================================================
{
  "include": ["./target/types/relations_derivation.ts"],
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/relations-derivation/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
  async function deployAsync(exampleString: string): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log(exampleString);
        resolve();
      }, 2000);
    });
  }

  await deployAsync("Typescript migration example complete.");
};


================================================
File: tests/relations-derivation/programs/relations-derivation/Cargo.toml
================================================
[package]
name = "relations-derivation"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "relations_derivation"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/relations-derivation/programs/relations-derivation/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/relations-derivation/programs/relations-derivation/src/lib.rs
================================================
//! The typescript example serves to show how one would setup an Anchor
//! workspace with TypeScript tests and migrations.

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod relations_derivation {
    use super::*;

    pub fn init_base(ctx: Context<InitBase>) -> Result<()> {
        ctx.accounts.account.my_account = ctx.accounts.my_account.key();
        ctx.accounts.account.bump = ctx.bumps.account;
        Ok(())
    }

    pub fn test_relation(_ctx: Context<TestRelation>) -> Result<()> {
        Ok(())
    }

    pub fn test_address(_ctx: Context<TestAddress>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitBase<'info> {
    /// CHECK: yeah I know
    #[account(mut)]
    my_account: Signer<'info>,
    #[account(
      init,
      payer = my_account,
      seeds = [b"seed"],
      space = 100,
      bump,
    )]
    account: Account<'info, MyAccount>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Nested<'info> {
    /// CHECK: yeah I know
    my_account: UncheckedAccount<'info>,
    #[account(
      has_one = my_account,
      seeds = [b"seed"],
      bump = account.bump
    )]
    account: Account<'info, MyAccount>,
}

#[derive(Accounts)]
pub struct TestRelation<'info> {
    /// CHECK: yeah I know
    my_account: UncheckedAccount<'info>,
    #[account(
      has_one = my_account,
      seeds = [b"seed"],
      bump = account.bump
    )]
    account: Account<'info, MyAccount>,
    nested: Nested<'info>,
}

#[derive(Accounts)]
pub struct TestAddress<'info> {
    // Included wit the `address` field in IDL
    // It's actually `static` but it doesn't matter for our purposes
    #[account(address = crate::ID)]
    constant: UncheckedAccount<'info>,
    #[account(address = crate::id())]
    const_fn: UncheckedAccount<'info>,

    // Not included with the `address` field in IDL
    #[account(address = my_account.my_account)]
    field: UncheckedAccount<'info>,
    #[account(address = my_account.my_account())]
    method: UncheckedAccount<'info>,

    #[account(seeds = [b"seed"], bump = my_account.bump)]
    my_account: Account<'info, MyAccount>,
}

#[account]
pub struct MyAccount {
    pub my_account: Pubkey,
    pub bump: u8,
}

impl MyAccount {
    pub fn my_account(&self) -> Pubkey {
        self.my_account
    }
}


================================================
File: tests/relations-derivation/tests/typescript.spec.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { AnchorProvider, Program } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";
import { expect } from "chai";
import { RelationsDerivation } from "../target/types/relations_derivation";

describe("typescript", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace
    .RelationsDerivation as Program<RelationsDerivation>;
  const provider = anchor.getProvider() as AnchorProvider;

  it("Inits the base account", async () => {
    await program.methods
      .initBase()
      .accounts({
        myAccount: provider.wallet.publicKey,
      })
      .rpc();
  });

  it("Derives relationss", async () => {
    const tx = await program.methods.testRelation().accounts({
      nested: {
        account: (
          await PublicKey.findProgramAddress(
            [Buffer.from("seed", "utf-8")],
            program.programId
          )
        )[0],
      },
    });

    await tx.instruction();
    const keys = await tx.pubkeys();

    expect(keys.myAccount!.equals(provider.wallet.publicKey)).is.true;

    await tx.rpc();
  });

  it("Can use `address` constraint", () => {
    const ix = program.idl.instructions.find(
      (ix) => ix.name === "testAddress"
    )!;
    expect(ix.accounts.find((acc) => acc.name === "constant")!.address).to.not
      .be.undefined;
    expect(ix.accounts.find((acc) => acc.name === "constFn")!.address).to.not.be
      .undefined;
  });
});


================================================
File: tests/safety-checks/Anchor.toml
================================================
[programs.localnet]
unchecked_account = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"
account_info = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "./test.sh"


================================================
File: tests/safety-checks/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/safety-checks/test.sh
================================================
#!/bin/bash

echo "Building programs"

#
# Build the UncheckedAccount variant.
#
pushd programs/unchecked-account/
output=$(anchor build 2>&1 > /dev/null)
if ! [[ $output =~ "Struct field \"unchecked\" is unsafe" ]]; then
   echo "Error: expected /// CHECK error"
   exit 1
fi
popd

#
# Build the AccountInfo variant.
#
pushd programs/account-info/
output=$(anchor build 2>&1 > /dev/null)
if ! [[ $output =~ "Struct field \"unchecked\" is unsafe" ]]; then
   echo "Error: expected /// CHECK error"
   exit 1
fi
popd

#
# Build the control variant.
#
pushd programs/ignore-non-accounts/
if ! anchor build ; then
   echo "Error: anchor build failed when it shouldn't have"
   exit 1
fi
popd

echo "Success. As expected, all builds failed that were supposed to fail."


================================================
File: tests/safety-checks/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/safety-checks/.gitignore
================================================

.anchor
.DS_Store
target
**/*.rs.bk
node_modules


================================================
File: tests/safety-checks/programs/account-info/Cargo.toml
================================================
[package]
name = "account-info"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "account_info"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/safety-checks/programs/account-info/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/safety-checks/programs/account-info/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod account_info {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    unchecked: AccountInfo<'info>,
}


================================================
File: tests/safety-checks/programs/ignore-non-accounts/Cargo.toml
================================================
[package]
name = "ignore-non-accounts"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "ignore_non_accounts"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/safety-checks/programs/ignore-non-accounts/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/safety-checks/programs/ignore-non-accounts/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod ignore_non_accounts {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    /// CHECK:
    checked1: UncheckedAccount<'info>,
    /// CHECK:
    checked2: AccountInfo<'info>,
}

#[derive(Debug)]
pub struct ShouldIgnore1<'info> {
    unchecked1: UncheckedAccount<'info>,
    unchecked2: AccountInfo<'info>,
}

pub struct ShouldIgnore2<'info> {
    unchecked1: UncheckedAccount<'info>,
    unchecked2: AccountInfo<'info>,
}


================================================
File: tests/safety-checks/programs/unchecked-account/Cargo.toml
================================================
[package]
name = "unchecked-account"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "safety_checks"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/safety-checks/programs/unchecked-account/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/safety-checks/programs/unchecked-account/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod unchecked_account {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    unchecked: UncheckedAccount<'info>,
}


================================================
File: tests/solang/Anchor.toml
================================================
[features]
seeds = false
skip-lint = false

[programs.localnet]
flipper = "F1ipperKF9EfD821ZbbYjS319LXYiBmjhzkkf5a26rC"

[provider]
cluster = "Localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/solang/package.json
================================================
{
  "name": "solang",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor run test-with-build"
  }
}


================================================
File: tests/solang/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/solang/.gitignore
================================================

.anchor
.DS_Store
target
**/*.rs.bk
node_modules
test-ledger
.yarn


================================================
File: tests/solang/.prettierignore
================================================

.anchor
.DS_Store
target
node_modules
dist
build
test-ledger


================================================
File: tests/solang/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/solang/solidity/flipper.sol
================================================

contract flipper {
    bool private value = true;

    @payer(payer)
    constructor() {
        print("Hello, World!");
    }

    /// A message that can be called on instantiated contracts.
    /// This one flips the value of the stored `bool` from `true`
    /// to `false` and vice versa.
    function flip() public {
            value = !value;
    }

    /// Simply returns the current value of our `bool`.
    function get() public view returns (bool) {
            return value;
    }
}


================================================
File: tests/solang/tests/solang.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Flipper } from "../target/types/flipper";

describe("flipper", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const dataAccount = anchor.web3.Keypair.generate();
  const wallet = provider.wallet;

  const program = anchor.workspace.Flipper as Program<Flipper>;

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods
      .new()
      .accounts({ dataAccount: dataAccount.publicKey })
      .signers([dataAccount])
      .rpc();
    console.log("Your transaction signature", tx);

    const val1 = await program.methods
      .get()
      .accounts({ dataAccount: dataAccount.publicKey })
      .view();

    console.log("state", val1);

    await program.methods
      .flip()
      .accounts({ dataAccount: dataAccount.publicKey })
      .rpc();

    const val2 = await program.methods
      .get()
      .accounts({ dataAccount: dataAccount.publicKey })
      .view();

    console.log("state", val2);
  });
});


================================================
File: tests/spl/metadata/Anchor.toml
================================================
[programs.localnet]
metadata = "Metadata11111111111111111111111111111111111"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/spl/metadata/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true
lto = "fat"
codegen-units = 1
[profile.release.build-override]
opt-level = 3
incremental = false
codegen-units = 1


================================================
File: tests/spl/metadata/package.json
================================================
{
  "name": "metadata",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  }
}


================================================
File: tests/spl/metadata/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/spl/metadata/programs/metadata/Cargo.toml
================================================
[package]
name = "metadata"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "metadata"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }
anchor-spl = { path = "../../../../../spl", features = ["metadata"] }


================================================
File: tests/spl/metadata/programs/metadata/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/spl/metadata/programs/metadata/src/lib.rs
================================================
//! Only tests whether `anchor-spl` builds with `metadata` feature enabled.

use anchor_lang::prelude::*;

declare_id!("Metadata11111111111111111111111111111111111");

#[program]
pub mod metadata {}


================================================
File: tests/spl/metadata/tests/metadata.ts
================================================
import * as anchor from "@coral-xyz/anchor";

import { Metadata } from "../target/types/metadata";

describe("Client interactions", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.metadata as anchor.Program<Metadata>;

  it("Builds and deploys", () => {
    console.log("Program ID:", program.programId.toBase58());
  });
});


================================================
File: tests/spl/token-extensions/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
token_extensions = "tKEkkQtgMXhdaz5NMTR3XbdUu215sZyHSj6Menvous1"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"

[features]

[test.validator]
url = "https://api.mainnet-beta.solana.com"

================================================
File: tests/spl/token-extensions/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/spl/token-extensions/package.json
================================================
{
  "name": "token-extensions",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  },
  "dependencies": {
    "@solana/spl-token": "^0.3.9"
  }
}


================================================
File: tests/spl/token-extensions/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai", "node"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/spl/token-extensions/programs/token-extensions/Cargo.toml
================================================
[package]
name = "token-extensions"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "token_extensions"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang", features = ["init-if-needed"] }
anchor-spl = { path = "../../../../../spl" }
spl-tlv-account-resolution = "0.9"
spl-transfer-hook-interface = "0.9"
spl-type-length-value = "0.7"
spl-pod = "0.5"


================================================
File: tests/spl/token-extensions/programs/token-extensions/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/spl/token-extensions/programs/token-extensions/src/lib.rs
================================================
//! An example of a program with token extensions enabled
//!
//! This program is intended to implement various token2022 extensions
//!
//! <https://spl.solana.com/token-2022/extensions>

use anchor_lang::prelude::*;

pub mod instructions;
pub mod utils;
pub use instructions::*;
pub use utils::*;

declare_id!("tKEkkQtgMXhdaz5NMTR3XbdUu215sZyHSj6Menvous1");

#[program]
pub mod token_extensions {
    use super::*;

    pub fn create_mint_account(
        ctx: Context<CreateMintAccount>,
        args: CreateMintAccountArgs,
    ) -> Result<()> {
        instructions::handler(ctx, args)
    }

    pub fn check_mint_extensions_constraints(
        _ctx: Context<CheckMintExtensionConstraints>,
    ) -> Result<()> {
        Ok(())
    }
}


================================================
File: tests/spl/token-extensions/programs/token-extensions/src/utils.rs
================================================
use anchor_lang::{
    prelude::Result,
    solana_program::{
        account_info::AccountInfo,
        instruction::{get_stack_height, TRANSACTION_LEVEL_STACK_HEIGHT},
        program::invoke,
        pubkey::Pubkey,
        rent::Rent,
        system_instruction::transfer,
        sysvar::Sysvar,
    },
    Lamports,
};
use anchor_spl::token_interface::spl_token_2022::{
    extension::{BaseStateWithExtensions, Extension, StateWithExtensions},
    state::Mint,
};
use spl_tlv_account_resolution::{account::ExtraAccountMeta, state::ExtraAccountMetaList};
use spl_type_length_value::variable_len_pack::VariableLenPack;

pub const APPROVE_ACCOUNT_SEED: &[u8] = b"approve-account";
pub const META_LIST_ACCOUNT_SEED: &[u8] = b"extra-account-metas";

pub fn update_account_lamports_to_minimum_balance<'info>(
    account: AccountInfo<'info>,
    payer: AccountInfo<'info>,
    system_program: AccountInfo<'info>,
) -> Result<()> {
    let extra_lamports = Rent::get()?.minimum_balance(account.data_len()) - account.get_lamports();
    if extra_lamports > 0 {
        invoke(
            &transfer(payer.key, account.key, extra_lamports),
            &[payer, account, system_program],
        )?;
    }
    Ok(())
}

pub fn get_mint_extensible_extension_data<T: Extension + VariableLenPack>(
    account: &mut AccountInfo,
) -> Result<T> {
    let mint_data = account.data.borrow();
    let mint_with_extension = StateWithExtensions::<Mint>::unpack(&mint_data)?;
    let extension_data = mint_with_extension.get_variable_len_extension::<T>()?;
    Ok(extension_data)
}

pub fn get_extra_meta_list_account_pda(mint: Pubkey) -> Pubkey {
    Pubkey::find_program_address(&[META_LIST_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0
}

pub fn get_approve_account_pda(mint: Pubkey) -> Pubkey {
    Pubkey::find_program_address(&[APPROVE_ACCOUNT_SEED, mint.as_ref()], &crate::id()).0
}

/// Determine if we are in CPI
pub fn hook_in_cpi() -> bool {
    let stack_height = get_stack_height();
    let tx_height = TRANSACTION_LEVEL_STACK_HEIGHT;
    let hook_height: usize = tx_height + 1;

    stack_height > hook_height
}

pub fn get_meta_list(approve_account: Option<Pubkey>) -> Vec<ExtraAccountMeta> {
    if let Some(approve_account) = approve_account {
        return vec![ExtraAccountMeta {
            discriminator: 0,
            address_config: approve_account.to_bytes(),
            is_signer: false.into(),
            is_writable: true.into(),
        }];
    }
    vec![]
}

pub fn get_meta_list_size(approve_account: Option<Pubkey>) -> usize {
    // safe because it's either 0 or 1
    ExtraAccountMetaList::size_of(get_meta_list(approve_account).len()).unwrap()
}


================================================
File: tests/spl/token-extensions/tests/token-extensions.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair } from "@solana/web3.js";
import { TokenExtensions } from "../target/types/token_extensions";
import { ASSOCIATED_PROGRAM_ID } from "@coral-xyz/anchor/dist/cjs/utils/token";
import { it } from "node:test";

const TOKEN_2022_PROGRAM_ID = new anchor.web3.PublicKey(
  "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
);

export function associatedAddress({
  mint,
  owner,
}: {
  mint: PublicKey;
  owner: PublicKey;
}): PublicKey {
  return PublicKey.findProgramAddressSync(
    [owner.toBuffer(), TOKEN_2022_PROGRAM_ID.toBuffer(), mint.toBuffer()],
    ASSOCIATED_PROGRAM_ID
  )[0];
}

describe("token extensions", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.TokenExtensions as Program<TokenExtensions>;

  const payer = Keypair.generate();

  it("airdrop payer", async () => {
    await provider.connection.confirmTransaction(
      await provider.connection.requestAirdrop(payer.publicKey, 10000000000),
      "confirmed"
    );
  });

  let mint = new Keypair();

  it("Create mint account test passes", async () => {
    const [extraMetasAccount] = PublicKey.findProgramAddressSync(
      [
        anchor.utils.bytes.utf8.encode("extra-account-metas"),
        mint.publicKey.toBuffer(),
      ],
      program.programId
    );
    await program.methods
      .createMintAccount({
        name: "hello",
        symbol: "hi",
        uri: "https://hi.com",
      })
      .accountsStrict({
        payer: payer.publicKey,
        authority: payer.publicKey,
        receiver: payer.publicKey,
        mint: mint.publicKey,
        mintTokenAccount: associatedAddress({
          mint: mint.publicKey,
          owner: payer.publicKey,
        }),
        extraMetasAccount: extraMetasAccount,
        systemProgram: anchor.web3.SystemProgram.programId,
        associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
        tokenProgram: TOKEN_2022_PROGRAM_ID,
      })
      .signers([mint, payer])
      .rpc();
  });

  it("mint extension constraints test passes", async () => {
    await program.methods
      .checkMintExtensionsConstraints()
      .accountsStrict({
        authority: payer.publicKey,
        mint: mint.publicKey,
      })
      .signers([payer])
      .rpc();
  });
});


================================================
File: tests/spl/token-proxy/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
token_proxy = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: tests/spl/token-proxy/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/spl/token-proxy/package.json
================================================
{
  "name": "token-proxy",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/spl/token-proxy/programs/token-proxy/Cargo.toml
================================================
[package]
name = "token-proxy"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "token_proxy"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }
anchor-spl = { path = "../../../../../spl" }


================================================
File: tests/spl/token-proxy/programs/token-proxy/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/spl/token-wrapper/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
token_wrapper = "4ZPcGU8MX8oL2u1EtErHzixAbgNBNeE9yoYq3kKMqnAy"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"


================================================
File: tests/spl/token-wrapper/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/spl/token-wrapper/package.json
================================================
{
  "name": "token-wrapper",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/spl/token-wrapper/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai", "node"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/spl/token-wrapper/programs/token-wrapper/Cargo.toml
================================================
[package]
name = "token-wrapper"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "token_wrapper"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang" }
anchor-spl = { path = "../../../../../spl" }


================================================
File: tests/spl/token-wrapper/programs/token-wrapper/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/spl/transfer-hook/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
transfer_hook = "9vaEfNU4HquQJuNQ6HYrpJW518a3n4wNUt5mAMY2UUHW"

[scripts]
test = "yarn run ts-mocha -t 1000000 tests/*.ts"


================================================
File: tests/spl/transfer-hook/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/spl/transfer-hook/package.json
================================================
{
  "name": "transfer-hook",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  },
  "dependencies": {
    "@solana/spl-token": "^0.3.9"
  }
}


================================================
File: tests/spl/transfer-hook/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai", "node"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/spl/transfer-hook/programs/transfer-hook/Cargo.toml
================================================
[package]
name = "transfer-hook"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "transfer_hook"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../../lang", features = ["interface-instructions"] }
anchor-spl = { path = "../../../../../spl" }
spl-discriminator = "0.4"
spl-tlv-account-resolution = "0.9"
spl-transfer-hook-interface = "0.9"


================================================
File: tests/spl/transfer-hook/programs/transfer-hook/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/swap/README.md
================================================
# Swap

An example swap program that provides a convenient API to the Serum orderbook
for performing instantly settled token swaps.

## Usage

This example requires building the Serum DEX from source, which is done using
git submodules.

### Install Submodules

Pull the source

```
git submodule init
git submodule update
```

### Build the DEX

Build it

```
cd deps/serum-dex/dex/ && cargo build-bpf && cd ../../../
```

### Run the Test

Run the test

```
anchor test
```


================================================
File: tests/swap/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
swap = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[[test.genesis]]
address = "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"
program = "prebuilt-programs/openbook_dex.so"

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[features]


================================================
File: tests/swap/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
exclude = [
    "deps/openbook-dex"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/swap/package.json
================================================
{
  "name": "swap",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/swap/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/swap/programs/swap/Cargo.toml
================================================
[package]
name = "swap"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "swap"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }
serum_dex = { git = "https://github.com/openbook-dex/program", rev = "1be91f2", version = "0.4.0", features = ["no-entrypoint"] }


================================================
File: tests/swap/programs/swap/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/system-accounts/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
system_accounts = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: tests/system-accounts/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/system-accounts/package.json
================================================
{
  "name": "system-accounts",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/system-accounts/programs/system-accounts/Cargo.toml
================================================
[package]
name = "system-accounts"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "system_accounts"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/system-accounts/programs/system-accounts/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/system-accounts/programs/system-accounts/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod system_accounts {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    pub authority: Signer<'info>,
    pub wallet: SystemAccount<'info>,
}


================================================
File: tests/system-accounts/tests/system-accounts.js
================================================
const anchor = require("@coral-xyz/anchor");
const splToken = require("@solana/spl-token");
const { assert } = require("chai");

describe("system_accounts", () => {
  anchor.setProvider(anchor.AnchorProvider.local());
  const program = anchor.workspace.SystemAccounts;
  const authority = program.provider.wallet.payer;
  const wallet = anchor.web3.Keypair.generate();

  it("Is initialized!", async () => {
    const tx = await program.rpc.initialize({
      accounts: {
        authority: authority.publicKey,
        wallet: wallet.publicKey,
      },
      signers: [authority],
    });

    console.log("Your transaction signature", tx);
  });

  it("Emits an AccountNotSystemOwned error", async () => {
    const mint = await splToken.Token.createMint(
      program.provider.connection,
      authority,
      authority.publicKey,
      null,
      9,
      splToken.TOKEN_PROGRAM_ID
    );

    const tokenAccount = await mint.createAssociatedTokenAccount(
      wallet.publicKey
    );

    await mint.mintTo(
      tokenAccount,
      authority.publicKey,
      [],
      1 * anchor.web3.LAMPORTS_PER_SOL
    );

    try {
      await program.rpc.initialize({
        accounts: {
          authority: authority.publicKey,
          wallet: tokenAccount,
        },
        signers: [authority],
      });
      assert.ok(false);
    } catch (err) {
      const errMsg = "The given account is not owned by the system program";
      assert.strictEqual(err.error.errorMessage, errMsg);
      assert.strictEqual(err.error.errorCode.number, 3011);
    }
  });
});


================================================
File: tests/sysvars/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
sysvars = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: tests/sysvars/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/sysvars/package.json
================================================
{
  "name": "sysvars",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/sysvars/programs/sysvars/Cargo.toml
================================================
[package]
name = "sysvars"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "sysvars"

[features]
no-entrypoint = []
cpi = ["no-entrypoint"]
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/sysvars/programs/sysvars/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/sysvars/programs/sysvars/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
mod sysvars {
    use super::*;
    pub fn sysvars(_ctx: Context<Sysvars>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Sysvars<'info> {
    pub clock: Sysvar<'info, Clock>,
    pub rent: Sysvar<'info, Rent>,
    pub stake_history: Sysvar<'info, StakeHistory>,
}


================================================
File: tests/sysvars/tests/sysvars.js
================================================
const anchor = require("@coral-xyz/anchor");
const { assert } = require("chai");

describe("sysvars", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.local());
  const program = anchor.workspace.Sysvars;

  it("Is initialized!", async () => {
    const tx = await program.methods
      .sysvars()
      .accounts({
        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
        stakeHistory: anchor.web3.SYSVAR_STAKE_HISTORY_PUBKEY,
      })
      .rpc();
    console.log("Your transaction signature", tx);
  });

  it("Fails when the wrong pubkeys are provided", async () => {
    try {
      await program.methods
        .sysvars()
        .accounts({
          clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,
          rent: anchor.web3.SYSVAR_RENT_PUBKEY,
          stakeHistory: anchor.web3.SYSVAR_REWARDS_PUBKEY,
        })
        .rpc();
      assert.ok(false);
    } catch (err) {
      const errMsg = "The given public key does not match the required sysvar";
      assert.strictEqual(err.error.errorMessage, errMsg);
      assert.strictEqual(err.error.errorCode.number, 3015);
    }
  });
});


================================================
File: tests/tictactoe/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
tictactoe = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[scripts]
test = "yarn run mocha -t 1000000 tests/"


================================================
File: tests/tictactoe/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/tictactoe/package.json
================================================
{
  "name": "tictactoe",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/tictactoe/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/tictactoe/programs/tictactoe/Cargo.toml
================================================
[package]
name = "tictactoe"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "tictactoe"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build", "anchor-spl/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
anchor-spl = { path = "../../../../spl" }


================================================
File: tests/tictactoe/programs/tictactoe/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/typescript/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[programs.localnet]
typescript = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[workspace]
members = ["programs/typescript"]

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"


================================================
File: tests/typescript/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/typescript/package.json
================================================
{
  "name": "typescript-example",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/typescript/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true
  }
}


================================================
File: tests/typescript/migrations/deploy.ts
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
  async function deployAsync(exampleString: string): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log(exampleString);
        resolve();
      }, 2000);
    });
  }

  await deployAsync("Typescript migration example complete.");
};


================================================
File: tests/typescript/programs/shared/Cargo.toml
================================================
[package]
name = "shared"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]


================================================
File: tests/typescript/programs/shared/src/lib.rs
================================================
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}


================================================
File: tests/typescript/programs/typescript/Cargo.toml
================================================
[package]
name = "typescript"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "typescript"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/typescript/programs/typescript/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/typescript/programs/typescript/src/lib.rs
================================================
//! The typescript example serves to show how one would setup an Anchor
//! workspace with TypeScript tests and migrations.

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod typescript {
    use super::*;
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/typescript/tests/typescript.spec.ts
================================================
import * as anchor from "@coral-xyz/anchor";

describe("typescript", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  it("Is initialized!", async () => {
    // Add your test here.
    const program = anchor.workspace.Typescript;
    const tx = await program.rpc.initialize();
    console.log("Your transaction signature", tx);
  });
});


================================================
File: tests/validator-clone/Anchor.toml
================================================
[features]
seeds = false
[programs.localnet]
validator_clone = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[scripts]
test = "yarn run ts-mocha -p ./tsconfig.json -t 1000000 tests/**/*.ts"

[test]
startup_wait = 20000

[test.validator]
url = "https://api.mainnet-beta.solana.com"

[[test.validator.clone]]
address = "AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt"

[[test.validator.clone]]
address = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"

[[test.validator.clone]]
address = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"

[[test.validator.clone]]
address = "So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo"

[[test.validator.clone]]
address = "mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68"

[[test.validator.clone]]
address = "8DKwAVrCEVStDYNPCsmxHtUj8LH9oXNtkVRrBfpNKvhp"

[[test.validator.clone]]
address = "8DKwAVrCEVStDYNPCsmxHtUj8LH9oXNtkVRrBfpNKvhp"

[[test.validator.account_dir]]
directory = "accounts-snapshot"


================================================
File: tests/validator-clone/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/validator-clone/package.json
================================================
{
  "name": "validator-clone",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/validator-clone/tsconfig.json
================================================
{
  "compilerOptions": {
    "types": ["mocha", "chai"],
    "typeRoots": ["./node_modules/@types"],
    "lib": ["es2015"],
    "module": "commonjs",
    "target": "es6",
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}


================================================
File: tests/validator-clone/accounts-snapshot/usdc-mint.json
================================================
{
  "pubkey": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "account": {
    "lamports": 182698617139,
    "data": [
      "AQAAABzjWe1aAS4E+hQrnHUaHF6Hz9CgFhuchf/TG3jN/Nj2pIW9lUPjEQAGAQEAAAAqnl7btTwEZ5CY/3sSZRcUQ0/AjFYqmjuGEQXmctQicw==",
      "base64"
    ],
    "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "executable": false,
    "rentEpoch": 361
  }
}

================================================
File: tests/validator-clone/programs/validator-clone/Cargo.toml
================================================
[package]
name = "validator-clone"
version = "0.1.0"
description = "Created with Anchor"
edition = "2018"

[lib]
crate-type = ["cdylib", "lib"]
name = "validator_clone"

[features]
no-entrypoint = []
no-idl = []
no-log-ix-name = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }


================================================
File: tests/validator-clone/programs/validator-clone/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/validator-clone/programs/validator-clone/src/lib.rs
================================================
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod validator_clone {
    use super::*;

    pub fn initialize(_ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize {}


================================================
File: tests/validator-clone/tests/validator-clone.ts
================================================
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { assert } from "chai";
import { ValidatorClone } from "../target/types/validator_clone";

describe("validator-clone", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const program = anchor.workspace.ValidatorClone as Program<ValidatorClone>;
  const connection = program.provider.connection;

  it("Cloned non-executable account", async () => {
    // Metadata program upgrade authority
    const account = "AqH29mZfQFgRpfwaPoTMWSKJ5kqauoc1FwVBRksZyQrt";
    const [accountInfo] = await anchor.utils.rpc.getMultipleAccounts(
      connection,
      [new anchor.web3.PublicKey(account)]
    );
    assert.isNotNull(accountInfo, "Account " + account + " not found");
  });

  it("Cloned bpf2-program account", async () => {
    // Memo program
    const account = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr";
    const [accountInfo] = await anchor.utils.rpc.getMultipleAccounts(
      connection,
      [new anchor.web3.PublicKey(account)]
    );
    assert.isNotNull(accountInfo, "Account " + account + " not found");
  });

  it("Cloned bpf3-program accounts and their program data", async () => {
    const accounts = [
      // Metadata program
      "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s",
      // Metadata program executable data
      "PwDiXFxQsGra4sFFTT8r1QWRMd4vfumiWC1jfWNfdYT",
      // Solend program
      "So1endDq2YkqhipRh3WViPa8hdiSpxWy6z3Z6tMCpAo",
      // Solend program executable data
      "DMCvGv1fS5rMcAvEDPDDBawPqbDRSzJh2Bo6qXCmgJkR",
    ];
    const accountInfos = await anchor.utils.rpc.getMultipleAccounts(
      connection,
      accounts.map((acc) => new anchor.web3.PublicKey(acc))
    );

    accountInfos.forEach((acc, i) => {
      assert.isNotNull(acc, "Account " + accounts[i] + " not found");
    });
  });

  it("Cloned bpf3-program account and its program data (both explicitly declared)", async () => {
    const accounts = [
      // Mango v3 program
      "mv3ekLzLbnVPNxjSKvqBpU3ZeZXPQdEC3bp5MDEBG68",
      // Mango v3 program executable data
      "8DKwAVrCEVStDYNPCsmxHtUj8LH9oXNtkVRrBfpNKvhp",
    ];
    const accountInfos = await anchor.utils.rpc.getMultipleAccounts(
      connection,
      accounts.map((acc) => new anchor.web3.PublicKey(acc))
    );

    accountInfos.forEach((acc, i) => {
      assert.isNotNull(acc, "Account " + accounts[i] + " not found");
    });
  });

  it("Load accounts from account-dir directory", async () => {
    // USDC mint
    const account = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
    const accountInfo = await connection.getAccountInfo(
      new anchor.web3.PublicKey(account)
    );
    assert.isNotNull(accountInfo, "Account " + account + " not found");
  });
});


================================================
File: tests/zero-copy/Anchor.toml
================================================
[provider]
cluster = "localnet"
wallet = "~/.config/solana/id.json"

[workspace]
members = ["programs/zero-copy", "programs/zero-cpi"]

[scripts]
test = "yarn run mocha -t 1000000 tests/"

[programs.localnet]
zero_cpi = "ErjUjtqKE5AGWUsjseSJCVLtddM6rhaMbDqmhzraF9h6"
zero_copy = "Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS"

[features]



================================================
File: tests/zero-copy/Cargo.toml
================================================
[workspace]
members = [
    "programs/*"
]
resolver = "2"

[profile.release]
overflow-checks = true


================================================
File: tests/zero-copy/package.json
================================================
{
  "name": "zero-copy",
  "version": "0.30.1",
  "license": "(MIT OR Apache-2.0)",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "test": "anchor test"
  }
}


================================================
File: tests/zero-copy/migrations/deploy.js
================================================
// Migrations are an early feature. Currently, they're nothing more than this
// single deploy script that's invoked from the CLI, injecting a provider
// configured from the workspace's Anchor.toml.

const anchor = require("@coral-xyz/anchor");

module.exports = async function (provider) {
  // Configure client to use the provider.
  anchor.setProvider(provider);

  // Add your deploy script here.
};


================================================
File: tests/zero-copy/programs/shared/Cargo.toml
================================================
[package]
name = "shared"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]


================================================
File: tests/zero-copy/programs/shared/src/lib.rs
================================================
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}


================================================
File: tests/zero-copy/programs/zero-copy/Cargo.toml
================================================
[package]
name = "zero-copy"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "zero_copy"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
test-sbf = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
bytemuck = {version = "1.4.0", features = ["derive", "min_const_generics"]}

[dev-dependencies]
anchor-client = { path = "../../../../client", features = ["debug", "async"] }
solana-program-test = "2"


================================================
File: tests/zero-copy/programs/zero-copy/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []

================================================
File: tests/zero-copy/programs/zero-copy/tests/compute_unit_test.rs
================================================
#![cfg(feature = "test-sbf")]

use {
    anchor_client::{
        anchor_lang::Discriminator,
        solana_sdk::{
            account::Account,
            commitment_config::CommitmentConfig,
            pubkey::Pubkey,
            signature::{Keypair, Signer},
            transaction::Transaction,
        },
        Client, Cluster,
    },
    solana_program_test::{tokio, ProgramTest},
    std::rc::Rc,
};

#[tokio::test]
async fn update_foo() {
    let authority = Keypair::new();
    let foo_pubkey = Pubkey::new_unique();
    let foo_account = {
        let mut foo_data = Vec::new();
        foo_data.extend_from_slice(zero_copy::Foo::DISCRIMINATOR);
        foo_data.extend_from_slice(bytemuck::bytes_of(&zero_copy::Foo {
            authority: authority.pubkey(),
            ..zero_copy::Foo::default()
        }));

        Account {
            lamports: 1,
            data: foo_data,
            owner: zero_copy::id(),
            ..Account::default()
        }
    };

    let mut pt = ProgramTest::new("zero_copy", zero_copy::id(), None);
    pt.add_account(foo_pubkey, foo_account);
    pt.set_compute_max_units(4157);
    let (mut banks_client, payer, recent_blockhash) = pt.start().await;

    let client = Client::new_with_options(
        Cluster::Debug,
        Rc::new(Keypair::new()),
        CommitmentConfig::processed(),
    );
    let program = client.program(zero_copy::id()).unwrap();
    let update_ix = program
        .request()
        .accounts(zero_copy::accounts::UpdateFoo {
            foo: foo_pubkey,
            authority: authority.pubkey(),
        })
        .args(zero_copy::instruction::UpdateFoo { data: 1u64 })
        .instructions()
        .unwrap()
        .pop()
        .unwrap();

    let transaction = Transaction::new_signed_with_payer(
        &[update_ix],
        Some(&payer.pubkey()),
        &[&payer, &authority],
        recent_blockhash,
    );

    banks_client.process_transaction(transaction).await.unwrap();
}


================================================
File: tests/zero-copy/programs/zero-cpi/Cargo.toml
================================================
[package]
name = "zero-cpi"
version = "0.1.0"
description = "Created with Anchor"
edition = "2021"

[lib]
crate-type = ["cdylib", "lib"]
name = "zero_cpi"

[features]
no-entrypoint = []
no-idl = []
cpi = ["no-entrypoint"]
default = []
idl-build = ["anchor-lang/idl-build"]

[dependencies]
anchor-lang = { path = "../../../../lang" }
zero-copy = { path = "../zero-copy", features = ["cpi"] }


================================================
File: tests/zero-copy/programs/zero-cpi/Xargo.toml
================================================
[target.bpfel-unknown-unknown.dependencies.std]
features = []


================================================
File: tests/zero-copy/programs/zero-cpi/src/lib.rs
================================================
use anchor_lang::prelude::*;
use zero_copy::cpi::accounts::UpdateBar;
use zero_copy::program::ZeroCopy;
use zero_copy::{self, Bar, Foo};

declare_id!("ErjUjtqKE5AGWUsjseSJCVLtddM6rhaMbDqmhzraF9h6");

#[program]
pub mod zero_cpi {
    use super::*;
    pub fn check_cpi(ctx: Context<CheckCpi>, data: u64) -> Result<()> {
        let cpi_program = ctx.accounts.zero_copy_program.to_account_info();
        let cpi_accounts = UpdateBar {
            authority: ctx.accounts.authority.clone(),
            bar: ctx.accounts.bar.to_account_info(),
            foo: ctx.accounts.foo.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        zero_copy::cpi::update_bar(cpi_ctx, data)?;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CheckCpi<'info> {
    #[account(
        mut,
        has_one = authority,
    )]
    bar: AccountLoader<'info, Bar>,
    #[account(signer)]
    authority: AccountInfo<'info>,
    foo: AccountLoader<'info, Foo>,
    zero_copy_program: Program<'info, ZeroCopy>,
}


================================================
File: ts/build-packages.sh
================================================
cd packages;
for D in */;
    do if [ "$D" = "anchor/" ]; then
        cd $D && yarn && yarn build; cd ..;
    else
        cd $D && yarn init:yarn; cd ..;
    fi
done


================================================
File: ts/package.json
================================================
{
  "name": "@coral-xyz/monorepo",
  "private": true,
  "workspaces": [
    "packages/*",
    "tests"
  ]
}


================================================
File: ts/packages/anchor/README.md
================================================
# @coral-xyz/anchor

[![npm](https://img.shields.io/npm/v/@coral-xyz/anchor.svg?color=blue)](https://www.npmjs.com/package/@coral-xyz/anchor)
[![Docs](https://img.shields.io/badge/docs-typedoc-blue)](https://coral-xyz.github.io/anchor/ts/index.html)

TypeScript client for Anchor programs.

## Note

- `@coral-xyz/anchor` depends on node.js native modules. Therefore, webpack 5 will not work with current version. You will either need to rollback to webpack 4, or use a polyfill for each missing dependency.


================================================
File: ts/packages/anchor/jest.config.js
================================================
module.exports = {
  preset: 'ts-jest/presets/default',
  testEnvironment: 'node',
  testTimeout: 90000,
  resolver: "ts-jest-resolver",
};


================================================
File: ts/packages/anchor/package.json
================================================
{
  "name": "@coral-xyz/anchor",
  "version": "0.30.1",
  "description": "Anchor client",
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "license": "(MIT OR Apache-2.0)",
  "types": "dist/cjs/index.d.ts",
  "homepage": "https://github.com/coral-xyz/anchor#readme",
  "bugs": {
    "url": "https://github.com/coral-xyz/anchor/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "publishConfig": {
    "access": "public"
  },
  "engines": {
    "node": ">=17"
  },
  "scripts": {
    "build": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:node": "cd ../borsh && yarn build && cd ../anchor-errors && yarn build && cd ../anchor && tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** tests/** -w",
    "lint": "prettier src/** tests/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch",
    "prepublishOnly": "yarn build",
    "docs": "typedoc --excludePrivate --includeVersion --out ../../../docs/src/.vuepress/dist/ts/ --readme none src/index.ts",
    "test": "jest tests --detectOpenHandles"
  },
  "dependencies": {
    "@coral-xyz/anchor-errors": "^0.30.1",
    "@coral-xyz/borsh": "^0.30.1",
    "@noble/hashes": "^1.3.1",
    "@solana/web3.js": "^1.69.0",
    "bn.js": "^5.1.2",
    "bs58": "^4.0.1",
    "buffer-layout": "^1.2.2",
    "camelcase": "^6.3.0",
    "cross-fetch": "^3.1.5",
    "eventemitter3": "^4.0.7",
    "pako": "^2.0.3",
    "snake-case": "^3.0.4",
    "superstruct": "^0.15.4",
    "toml": "^3.0.0"
  },
  "devDependencies": {
    "@commitlint/cli": "^11.0.0",
    "@commitlint/config-conventional": "^11.0.0",
    "@rollup/plugin-commonjs": "^21.0.1",
    "@rollup/plugin-node-resolve": "^13.0.6",
    "@rollup/plugin-replace": "^3.0.0",
    "@rollup/plugin-typescript": "^8.3.0",
    "@types/bn.js": "^4.11.6",
    "@types/bs58": "^4.0.1",
    "@types/crypto-hash": "^1.1.2",
    "@types/jest": "^27.4.1",
    "@types/pako": "^1.0.1",
    "@typescript-eslint/eslint-plugin": "^4.6.0",
    "@typescript-eslint/parser": "^4.6.0",
    "eslint": "^7.12.1",
    "eslint-config-prettier": "^6.15.0",
    "husky": "^4.3.0",
    "jest": "27.3.1",
    "jest-config": "27.3.1",
    "lint-staged": "^10.5.0",
    "prettier": "^2.1.2",
    "rimraf": "^3.0.2",
    "rollup": "^2.60.2",
    "ts-jest": "^27.0.7",
    "ts-jest-resolver": "^2.0.0",
    "ts-node": "^9.0.0",
    "tslib": "^2.3.1",
    "typedoc": "^0.22.10",
    "typescript": "^5.5.4"
  },
  "files": [
    "dist",
    "types"
  ]
}


================================================
File: ts/packages/anchor/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/anchor/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "types/",
      "../../node_modules/@types"
    ],
    "paths": {
      "@solana/web3.js": [
        "../../node_modules/@solana/web3.js/lib"
      ]
    }
  }
}


================================================
File: ts/packages/anchor/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/anchor/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/anchor/src/index.ts
================================================
import NodeWallet from "./nodewallet";
import { isBrowser } from "./utils/common.js";

export { default as BN } from "bn.js";
export * as web3 from "@solana/web3.js";
export {
  default as Provider,
  getProvider,
  setProvider,
  AnchorProvider,
} from "./provider.js";
export * from "./error.js";
export { Instruction } from "./coder/borsh/instruction.js";
export { Idl } from "./idl.js";
export { CustomAccountResolver } from "./program/accounts-resolver.js";

export * from "./coder/index.js";
export * as utils from "./utils/index.js";
export * from "./program/index.js";
export * from "./native/index.js";

export declare const workspace: any;
export declare class Wallet extends NodeWallet {}

if (!isBrowser) {
  exports.workspace = require("./workspace.js").default;
  exports.Wallet = require("./nodewallet.js").default;
}


================================================
File: ts/packages/anchor/src/nodewallet.ts
================================================
import { Buffer } from "buffer";
import {
  Keypair,
  PublicKey,
  Transaction,
  VersionedTransaction,
} from "@solana/web3.js";
import { Wallet } from "./provider";
import { isVersionedTransaction } from "./utils/common.js";

/**
 * Node only wallet.
 */
export default class NodeWallet implements Wallet {
  constructor(readonly payer: Keypair) {}

  static local(): NodeWallet | never {
    const process = require("process");

    if (!process.env.ANCHOR_WALLET || process.env.ANCHOR_WALLET === "") {
      throw new Error(
        "expected environment variable `ANCHOR_WALLET` is not set."
      );
    }

    const payer = Keypair.fromSecretKey(
      Buffer.from(
        JSON.parse(
          require("fs").readFileSync(process.env.ANCHOR_WALLET, {
            encoding: "utf-8",
          })
        )
      )
    );

    return new NodeWallet(payer);
  }

  async signTransaction<T extends Transaction | VersionedTransaction>(
    tx: T
  ): Promise<T> {
    if (isVersionedTransaction(tx)) {
      tx.sign([this.payer]);
    } else {
      tx.partialSign(this.payer);
    }

    return tx;
  }

  async signAllTransactions<T extends Transaction | VersionedTransaction>(
    txs: T[]
  ): Promise<T[]> {
    return txs.map((t) => {
      if (isVersionedTransaction(t)) {
        t.sign([this.payer]);
      } else {
        t.partialSign(this.payer);
      }
      return t;
    });
  }

  get publicKey(): PublicKey {
    return this.payer.publicKey;
  }
}


================================================
File: ts/packages/anchor/src/workspace.ts
================================================
import * as toml from "toml";
import camelcase from "camelcase";
import { snakeCase } from "snake-case";
import { Program } from "./program/index.js";
import { isBrowser } from "./utils/common.js";
import { Idl } from "./idl.js";

/**
 * The `workspace` namespace provides a convenience API to automatically
 * search for and deserialize [[Program]] objects defined by compiled IDLs
 * in an Anchor workspace.
 *
 * This API is for Node only.
 */
const workspace = new Proxy(
  {},
  {
    get(workspaceCache: { [key: string]: Program }, programName: string) {
      if (isBrowser) {
        throw new Error("Workspaces aren't available in the browser");
      }

      // Converting `programName` to camelCase enables the ability to use any
      // of the following to access the workspace program:
      // `workspace.myProgram`, `workspace.MyProgram`, `workspace["my-program"]`...
      programName = camelcase(programName);

      // Return early if the program is in cache
      if (workspaceCache[programName]) return workspaceCache[programName];

      const fs = require("fs");
      const path = require("path");

      // Override the workspace programs if the user put them in the config.
      const anchorToml = toml.parse(fs.readFileSync("Anchor.toml"));
      const clusterId = anchorToml.provider.cluster;
      const programs = anchorToml.programs?.[clusterId];
      let programEntry;
      if (programs) {
        programEntry = Object.entries(programs).find(
          ([key]) => camelcase(key) === programName
        )?.[1];
      }

      let idlPath: string;
      let programId;
      if (typeof programEntry === "object" && programEntry.idl) {
        idlPath = programEntry.idl;
        programId = programEntry.address;
      } else {
        // Assuming the IDL file's name to be the snake_case name of the
        // `programName` with `.json` extension results in problems when
        // numbers are involved due to the nature of case conversion from
        // camelCase to snake_case being lossy.
        //
        // To avoid the above problem with numbers, read the `idl` directory and
        // compare the camelCased  version of both file names and `programName`.
        const idlDirPath = path.join("target", "idl");
        const fileName = fs
          .readdirSync(idlDirPath)
          .find((name) => camelcase(path.parse(name).name) === programName);
        if (!fileName) {
          throw new Error(`Failed to find IDL of program \`${programName}\``);
        }

        idlPath = path.join(idlDirPath, fileName);
      }

      if (!fs.existsSync(idlPath)) {
        throw new Error(
          `${idlPath} doesn't exist. Did you run \`anchor build\`?`
        );
      }

      const idl: Idl = JSON.parse(fs.readFileSync(idlPath));
      if (programId) {
        idl.address = programId;
      }
      workspaceCache[programName] = new Program(idl);

      return workspaceCache[programName];
    },
  }
);

export default workspace;


================================================
File: ts/packages/anchor/src/coder/index.ts
================================================
import { IdlEvent } from "../idl.js";
import { Event } from "../program/event.js";

export * from "./borsh/index.js";
export * from "./system/index.js";

/**
 * Coder provides a facade for encoding and decoding all IDL related objects.
 */
export interface Coder<A extends string = string, T extends string = string> {
  /**
   * Instruction coder.
   */
  readonly instruction: InstructionCoder;

  /**
   * Account coder.
   */
  readonly accounts: AccountsCoder<A>;

  /**
   * Coder for events.
   */
  readonly events: EventCoder;

  /**
   * Coder for user-defined types.
   */
  readonly types: TypesCoder<T>;
}

export interface AccountsCoder<A extends string = string> {
  encode<T = any>(accountName: A, account: T): Promise<Buffer>;
  decode<T = any>(accountName: A, acc: Buffer): T;
  decodeUnchecked<T = any>(accountName: A, acc: Buffer): T;
  memcmp(accountName: A, appendData?: Buffer): any;
  size(accountName: A): number;
}

export interface InstructionCoder {
  encode(ixName: string, ix: any): Buffer;
}

export interface EventCoder {
  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    log: string
  ): Event<E, T> | null;
}

export interface TypesCoder<N extends string = string> {
  encode<T = any>(typeName: N, type: T): Buffer;
  decode<T = any>(typeName: N, typeData: Buffer): T;
}


================================================
File: ts/packages/anchor/src/coder/borsh/event.ts
================================================
import { Buffer } from "buffer";
import { Layout } from "buffer-layout";
import * as base64 from "../../utils/bytes/base64.js";
import { Idl, IdlDiscriminator } from "../../idl.js";
import { IdlCoder } from "./idl.js";
import { EventCoder } from "../index.js";

export class BorshEventCoder implements EventCoder {
  /**
   * Maps account type identifier to a layout.
   */
  private layouts: Map<
    string,
    { discriminator: IdlDiscriminator; layout: Layout }
  >;

  public constructor(idl: Idl) {
    if (!idl.events) {
      this.layouts = new Map();
      return;
    }

    const types = idl.types;
    if (!types) {
      throw new Error("Events require `idl.types`");
    }

    const layouts = idl.events.map((ev) => {
      const typeDef = types.find((ty) => ty.name === ev.name);
      if (!typeDef) {
        throw new Error(`Event not found: ${ev.name}`);
      }
      return [
        ev.name,
        {
          discriminator: ev.discriminator,
          layout: IdlCoder.typeDefLayout({ typeDef, types }),
        },
      ] as const;
    });
    this.layouts = new Map(layouts);
  }

  public decode(log: string): {
    name: string;
    data: any;
  } | null {
    let logArr: Buffer;
    // This will throw if log length is not a multiple of 4.
    try {
      logArr = base64.decode(log);
    } catch (e) {
      return null;
    }

    for (const [name, layout] of this.layouts) {
      const givenDisc = logArr.subarray(0, layout.discriminator.length);
      const matches = givenDisc.equals(Buffer.from(layout.discriminator));
      if (matches) {
        return {
          name,
          data: layout.layout.decode(logArr.subarray(givenDisc.length)),
        };
      }
    }

    return null;
  }
}


================================================
File: ts/packages/anchor/src/coder/borsh/index.ts
================================================
import { Idl } from "../../idl.js";
import { BorshInstructionCoder } from "./instruction.js";
import { BorshAccountsCoder } from "./accounts.js";
import { BorshEventCoder } from "./event.js";
import { BorshTypesCoder } from "./types.js";
import { Coder } from "../index.js";

export { BorshInstructionCoder } from "./instruction.js";
export { BorshAccountsCoder } from "./accounts.js";
export { BorshEventCoder } from "./event.js";

/**
 * BorshCoder is the default Coder for Anchor programs implementing the
 * borsh based serialization interface.
 */
export class BorshCoder<A extends string = string, T extends string = string>
  implements Coder
{
  /**
   * Instruction coder.
   */
  readonly instruction: BorshInstructionCoder;

  /**
   * Account coder.
   */
  readonly accounts: BorshAccountsCoder<A>;

  /**
   * Coder for events.
   */
  readonly events: BorshEventCoder;

  /**
   * Coder for user-defined types.
   */
  readonly types: BorshTypesCoder<T>;

  constructor(idl: Idl) {
    this.instruction = new BorshInstructionCoder(idl);
    this.accounts = new BorshAccountsCoder(idl);
    this.events = new BorshEventCoder(idl);
    this.types = new BorshTypesCoder(idl);
  }
}


================================================
File: ts/packages/anchor/src/coder/borsh/types.ts
================================================
import { Buffer } from "buffer";
import { Layout } from "buffer-layout";
import { Idl } from "../../idl.js";
import { IdlCoder } from "./idl.js";
import { TypesCoder } from "../index.js";

/**
 * Encodes and decodes user-defined types.
 */
export class BorshTypesCoder<N extends string = string> implements TypesCoder {
  /**
   * Maps type name to a layout.
   */
  private typeLayouts: Map<N, Layout>;

  public constructor(idl: Idl) {
    const types = idl.types;
    if (!types) {
      this.typeLayouts = new Map();
      return;
    }

    const layouts: [N, Layout][] = types
      .filter((ty) => !ty.generics)
      .map((ty) => [
        ty.name as N,
        IdlCoder.typeDefLayout({ typeDef: ty, types }),
      ]);
    this.typeLayouts = new Map(layouts);
  }

  public encode<T = any>(name: N, type: T): Buffer {
    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.
    const layout = this.typeLayouts.get(name);
    if (!layout) {
      throw new Error(`Unknown type: ${name}`);
    }
    const len = layout.encode(type, buffer);

    return buffer.slice(0, len);
  }

  public decode<T = any>(name: N, data: Buffer): T {
    const layout = this.typeLayouts.get(name);
    if (!layout) {
      throw new Error(`Unknown type: ${name}`);
    }
    return layout.decode(data);
  }
}


================================================
File: ts/packages/anchor/src/coder/system/accounts.ts
================================================
import { AccountsCoder } from "../index.js";
import { Idl } from "../../idl.js";
import * as BufferLayout from "buffer-layout";
import { NONCE_ACCOUNT_LENGTH, PublicKey } from "@solana/web3.js";
import { IdlCoder } from "../borsh/idl.js";

export class SystemAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(private idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "nonce": {
        const buffer = Buffer.alloc(NONCE_ACCOUNT_LENGTH);
        const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "nonce": {
        return decodeNonceAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  // TODO: this won't use the appendData.
  public memcmp(accountName: A, _appendData?: Buffer): any {
    switch (accountName) {
      case "nonce": {
        return {
          dataSize: NONCE_ACCOUNT_LENGTH,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(accountName: A): number {
    return IdlCoder.typeSize({ defined: { name: accountName } }, this.idl);
  }
}

function decodeNonceAccount<T = any>(ix: Buffer): T {
  return NONCE_ACCOUNT_LAYOUT.decode(ix) as T;
}

class WrappedLayout<T, U> extends BufferLayout.Layout<U> {
  layout: BufferLayout.Layout<T>;
  decoder: (data: T) => U;
  encoder: (src: U) => T;

  constructor(
    layout: BufferLayout.Layout<T>,
    decoder: (data: T) => U,
    encoder: (src: U) => T,
    property?: string
  ) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }

  decode(b: Buffer, offset?: number): U {
    return this.decoder(this.layout.decode(b, offset));
  }

  encode(src: U, b: Buffer, offset?: number): number {
    return this.layout.encode(this.encoder(src), b, offset);
  }

  getSpan(b: Buffer, offset?: number): number {
    return this.layout.getSpan(b, offset);
  }
}

function publicKey(property?: string): BufferLayout.Layout<PublicKey> {
  return new WrappedLayout(
    BufferLayout.blob(32),
    (b: Buffer) => new PublicKey(b),
    (key: PublicKey) => key.toBuffer(),
    property
  );
}

const NONCE_ACCOUNT_LAYOUT = BufferLayout.struct([
  BufferLayout.u32("version"),
  BufferLayout.u32("state"),
  publicKey("authorizedPubkey"),
  publicKey("nonce"),
  BufferLayout.struct(
    [BufferLayout.nu64("lamportsPerSignature")],
    "feeCalculator"
  ),
]);


================================================
File: ts/packages/anchor/src/coder/system/events.ts
================================================
import { EventCoder } from "../index.js";
import { Idl } from "../../idl.js";
import { Event } from "../../program/event";
import { IdlEvent } from "../../idl";

export class SystemEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("System program does not have events");
  }
}


================================================
File: ts/packages/anchor/src/coder/system/index.ts
================================================
import { Idl } from "../../idl.js";
import { Coder } from "../index.js";
import { SystemInstructionCoder } from "./instruction.js";
import { SystemAccountsCoder } from "./accounts.js";
import { SystemEventsCoder } from "./events.js";
import { SystemTypesCoder } from "./types.js";

/**
 * Coder for the System program.
 */
export class SystemCoder implements Coder {
  readonly instruction: SystemInstructionCoder;
  readonly accounts: SystemAccountsCoder;
  readonly events: SystemEventsCoder;
  readonly types: SystemTypesCoder;

  constructor(idl: Idl) {
    this.instruction = new SystemInstructionCoder(idl);
    this.accounts = new SystemAccountsCoder(idl);
    this.events = new SystemEventsCoder(idl);
    this.types = new SystemTypesCoder(idl);
  }
}


================================================
File: ts/packages/anchor/src/coder/system/types.ts
================================================
import { TypesCoder } from "../index.js";
import { Idl } from "../../idl.js";

export class SystemTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("System does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("System does not have user-defined types");
  }
}


================================================
File: ts/packages/anchor/src/native/index.ts
================================================
import { Program, Provider } from "../index.js";
import { program as systemProgram, SystemProgram } from "./system.js";

export { SystemProgram } from "./system.js";

export class Native {
  public static system(provider?: Provider): Program<SystemProgram> {
    return systemProgram(provider);
  }
}


================================================
File: ts/packages/anchor/src/program/common.ts
================================================
import EventEmitter from "eventemitter3";
import { PublicKey } from "@solana/web3.js";
import {
  Idl,
  IdlInstruction,
  IdlInstructionAccountItem,
  isCompositeAccounts,
} from "../idl.js";
import { Accounts } from "./context.js";

export type Subscription = {
  listener: number;
  ee: EventEmitter;
};

export function parseIdlErrors(idl: Idl): Map<number, string> {
  const errors = new Map();
  if (idl.errors) {
    idl.errors.forEach((e) => {
      let msg = e.msg ?? e.name;
      errors.set(e.code, msg);
    });
  }
  return errors;
}

export function toInstruction(idlIx: IdlInstruction, ...args: any[]) {
  if (idlIx.args.length != args.length) {
    throw new Error("Invalid argument length");
  }
  const ix: { [key: string]: any } = {};
  let idx = 0;
  idlIx.args.forEach((ixArg) => {
    ix[ixArg.name] = args[idx];
    idx += 1;
  });

  return ix;
}

// Throws error if any account required for the `ix` is not given.
export function validateAccounts(
  ixAccounts: IdlInstructionAccountItem[],
  accounts: Accounts = {}
) {
  ixAccounts.forEach((acc) => {
    if (isCompositeAccounts(acc)) {
      validateAccounts(acc.accounts, accounts[acc.name] as Accounts);
    } else {
      if (!accounts[acc.name]) {
        throw new Error(`Account \`${acc.name}\` not provided.`);
      }
    }
  });
}

// Translates an address to a Pubkey.
export function translateAddress(address: Address): PublicKey {
  return address instanceof PublicKey ? address : new PublicKey(address);
}

/**
 * An address to identify an account on chain. Can be a [[PublicKey]],
 * or Base 58 encoded string.
 */
export type Address = PublicKey | string;


================================================
File: ts/packages/anchor/src/program/context.ts
================================================
import {
  AccountMeta,
  ConfirmOptions,
  Signer,
  TransactionInstruction,
} from "@solana/web3.js";
import { Address } from "./common.js";
import {
  IdlInstructionAccountItem,
  IdlInstructionAccounts,
  IdlInstruction,
} from "../idl.js";

/**
 * Context provides all non-argument inputs for generating Anchor transactions.
 */
export type Context<A extends Accounts = Accounts> = {
  /**
   * Accounts used in the instruction context.
   */
  accounts?: A;

  /**
   * All accounts to pass into an instruction *after* the main `accounts`.
   * This can be used for optional or otherwise unknown accounts.
   */
  remainingAccounts?: AccountMeta[];

  /**
   * Accounts that must sign a given transaction.
   */
  signers?: Array<Signer>;

  /**
   * @deprecated use preInstructions instead.
   * Instructions to run *before* a given method. Often this is used, for
   * example to create accounts prior to executing a method.
   */
  instructions?: TransactionInstruction[];

  /**
   * Instructions to run *before* a given method. Often this is used, for
   * example to create accounts prior to executing a method.
   */
  preInstructions?: TransactionInstruction[];

  /**
   * Instructions to run *after* a given method. Often this is used, for
   * example to close accounts after executing a method.
   */
  postInstructions?: TransactionInstruction[];

  /**
   * Commitment parameters to use for a transaction.
   */
  options?: ConfirmOptions;
};

/**
 * A set of accounts mapping one-to-one to the program's accounts struct, i.e.,
 * the type deriving `#[derive(Accounts)]`.
 *
 * The name of each field should match the name for that account in the IDL.
 *
 * If multiple accounts are nested in the rust program, then they should be
 * nested here.
 */
export type Accounts<
  A extends IdlInstructionAccountItem = IdlInstructionAccountItem
> = {
  [N in A["name"]]: Account<A & { name: N }>;
};

type Account<A extends IdlInstructionAccountItem> =
  A extends IdlInstructionAccounts
    ? Accounts<A["accounts"][number]>
    : A extends { optional: true }
    ? Address | null
    : A extends { signer: true }
    ? Address | undefined
    : Address;

export function splitArgsAndCtx(
  idlIx: IdlInstruction,
  args: any[]
): [any[], Context] {
  let options = {};

  const inputLen = idlIx.args ? idlIx.args.length : 0;
  if (args.length > inputLen) {
    if (args.length !== inputLen + 1) {
      throw new Error(
        `provided too many arguments ${args} to instruction ${
          idlIx?.name
        } expecting: ${idlIx.args?.map((a) => a.name) ?? []}`
      );
    }
    options = args.pop();
  }

  return [args, options];
}


================================================
File: ts/packages/anchor/src/program/namespace/rpc.ts
================================================
import { TransactionSignature } from "@solana/web3.js";
import Provider from "../../provider.js";
import { Idl } from "../../idl.js";
import { splitArgsAndCtx } from "../context.js";
import { TransactionFn } from "./transaction.js";
import { translateError } from "../../error.js";
import {
  AllInstructions,
  InstructionContextFn,
  MakeInstructionsNamespace,
} from "./types.js";

export default class RpcFactory {
  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(
    idlIx: I,
    txFn: TransactionFn<IDL, I>,
    idlErrors: Map<number, string>,
    provider: Provider
  ): RpcFn {
    const rpc: RpcFn<IDL, I> = async (...args) => {
      const tx = txFn(...args);
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      if (provider.sendAndConfirm === undefined) {
        throw new Error(
          "This function requires 'Provider.sendAndConfirm' to be implemented."
        );
      }
      try {
        return await provider.sendAndConfirm(
          tx,
          ctx.signers ?? [],
          ctx.options
        );
      } catch (err) {
        throw translateError(err, idlErrors);
      }
    };

    return rpc;
  }
}

/**
 * The namespace provides async methods to send signed transactions for each
 * *non*-state method on Anchor program.
 *
 * Keys are method names, values are RPC functions returning a
 * [[TransactionInstruction]].
 *
 * ## Usage
 *
 * ```javascript
 * rpc.<method>(...args, ctx);
 * ```
 *
 * ## Parameters
 *
 * 1. `args` - The positional arguments for the program. The type and number
 *    of these arguments depend on the program being used.
 * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.
 *    Always the last parameter in the method call.
 * ```
 *
 * ## Example
 *
 * To send a transaction invoking the `increment` method above,
 *
 * ```javascript
 * const txSignature = await program.rpc.increment({
 *   accounts: {
 *     counter,
 *     authority,
 *   },
 * });
 * ```
 */
export type RpcNamespace<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = MakeInstructionsNamespace<IDL, I, Promise<TransactionSignature>>;

/**
 * RpcFn is a single RPC method generated from an IDL, sending a transaction
 * paid for and signed by the configured provider.
 */
export type RpcFn<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = InstructionContextFn<IDL, I, Promise<TransactionSignature>>;


================================================
File: ts/packages/anchor/src/program/namespace/transaction.ts
================================================
import { Transaction } from "@solana/web3.js";
import { Idl } from "../../idl.js";
import { splitArgsAndCtx } from "../context.js";
import { InstructionFn } from "./instruction.js";
import {
  AllInstructions,
  InstructionContextFn,
  MakeInstructionsNamespace,
} from "./types.js";

export default class TransactionFactory {
  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(
    idlIx: I,
    ixFn: InstructionFn<IDL, I>
  ): TransactionFn<IDL, I> {
    const txFn: TransactionFn<IDL, I> = (...args): Transaction => {
      const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
      const tx = new Transaction();
      if (ctx.preInstructions && ctx.instructions) {
        throw new Error("instructions is deprecated, use preInstructions");
      }
      ctx.preInstructions?.forEach((ix) => tx.add(ix));
      ctx.instructions?.forEach((ix) => tx.add(ix));
      tx.add(ixFn(...args));
      ctx.postInstructions?.forEach((ix) => tx.add(ix));
      return tx;
    };

    return txFn;
  }
}

/**
 * The namespace provides functions to build [[Transaction]] objects for each
 * method of a program.
 *
 * ## Usage
 *
 * ```javascript
 * program.transaction.<method>(...args, ctx);
 * ```
 *
 * ## Parameters
 *
 * 1. `args` - The positional arguments for the program. The type and number
 *    of these arguments depend on the program being used.
 * 2. `ctx`  - [[Context]] non-argument parameters to pass to the method.
 *    Always the last parameter in the method call.
 *
 * ## Example
 *
 * To create an instruction for the `increment` method above,
 *
 * ```javascript
 * const tx = await program.transaction.increment({
 *   accounts: {
 *     counter,
 *   },
 * });
 * ```
 */
export type TransactionNamespace<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = MakeInstructionsNamespace<IDL, I, Transaction>;

/**
 * Tx is a function to create a `Transaction` for a given program instruction.
 */
export type TransactionFn<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = InstructionContextFn<IDL, I, Transaction>;


================================================
File: ts/packages/anchor/src/program/namespace/views.ts
================================================
import { PublicKey } from "@solana/web3.js";
import { Idl, IdlInstructionAccount } from "../../idl.js";
import { SimulateFn } from "./simulate.js";
import {
  AllInstructions,
  InstructionContextFn,
  MakeInstructionsNamespace,
} from "./types";
import { IdlCoder } from "../../coder/borsh/idl";
import { decode } from "../../utils/bytes/base64";

export default class ViewFactory {
  public static build<IDL extends Idl, I extends AllInstructions<IDL>>(
    programId: PublicKey,
    idlIx: AllInstructions<IDL>,
    simulateFn: SimulateFn<IDL>,
    idl: IDL
  ): ViewFn<IDL, I> | undefined {
    const isWritable = idlIx.accounts.find(
      (a: IdlInstructionAccount) => a.writable
    );
    const hasReturn = !!idlIx.returns;
    if (isWritable || !hasReturn) return;

    const view: ViewFn<IDL> = async (...args) => {
      let simulationResult = await simulateFn(...args);
      const returnPrefix = `Program return: ${programId} `;
      let returnLog = simulationResult.raw.find((l) =>
        l.startsWith(returnPrefix)
      );
      if (!returnLog) {
        throw new Error("View expected return log");
      }

      let returnData = decode(returnLog.slice(returnPrefix.length));
      let returnType = idlIx.returns;
      if (!returnType) {
        throw new Error("View expected return type");
      }

      const coder = IdlCoder.fieldLayout({ type: returnType }, idl.types);
      return coder.decode(returnData);
    };
    return view;
  }
}

export type ViewNamespace<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = MakeInstructionsNamespace<IDL, I, Promise<any>>;

/**
 * ViewFn is a single method generated from an IDL. It simulates a method
 * against a cluster configured by the provider, and then parses the events
 * and extracts return data from the raw logs emitted during the simulation.
 */
export type ViewFn<
  IDL extends Idl = Idl,
  I extends AllInstructions<IDL> = AllInstructions<IDL>
> = InstructionContextFn<IDL, I, Promise<any>>;


================================================
File: ts/packages/anchor/src/utils/common.ts
================================================
import { Transaction, VersionedTransaction } from "@solana/web3.js";

/**
 * Returns true if being run inside a web browser,
 * false if in a Node process or electron app.
 */
export const isBrowser =
  process.env.ANCHOR_BROWSER ||
  (typeof window !== "undefined" && !window.process?.hasOwnProperty("type"));

/**
 * Splits an array into chunks
 *
 * @param array Array of objects to chunk.
 * @param size The max size of a chunk.
 * @returns A two dimensional array where each T[] length is < the provided size.
 */
export function chunks<T>(array: T[], size: number): T[][] {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(
    (_, index) => array.slice(index * size, (index + 1) * size)
  );
}

/**
 * Check if a transaction object is a VersionedTransaction or not
 *
 * @param tx
 * @returns bool
 */
export const isVersionedTransaction = (
  tx: Transaction | VersionedTransaction
): tx is VersionedTransaction => {
  return "version" in tx;
};


================================================
File: ts/packages/anchor/src/utils/features.ts
================================================
const _AVAILABLE_FEATURES = new Set(["debug-logs"]);

const _FEATURES = new Map();

export function set(key: string) {
  if (!_AVAILABLE_FEATURES.has(key)) {
    throw new Error("Invalid feature");
  }
  _FEATURES.set(key, true);
}

export function isSet(key: string): boolean {
  return _FEATURES.get(key) !== undefined;
}


================================================
File: ts/packages/anchor/src/utils/index.ts
================================================
export * as sha256 from "./sha256.js";
export * as rpc from "./rpc.js";
export * as publicKey from "./pubkey.js";
export * as bytes from "./bytes/index.js";
export * as token from "./token.js";
export * as features from "./features.js";
export * as registry from "./registry.js";


================================================
File: ts/packages/anchor/src/utils/pubkey.ts
================================================
import { Buffer } from "buffer";
import { PublicKey } from "@solana/web3.js";
import { sha256 } from "@noble/hashes/sha256";

// Sync version of web3.PublicKey.createWithSeed.
export function createWithSeedSync(
  fromPublicKey: PublicKey,
  seed: string,
  programId: PublicKey
): PublicKey {
  const buffer = Buffer.concat([
    fromPublicKey.toBuffer(),
    Buffer.from(seed),
    programId.toBuffer(),
  ]);
  return new PublicKey(sha256(buffer));
}


================================================
File: ts/packages/anchor/src/utils/registry.ts
================================================
import BN from "bn.js";
import fetch from "cross-fetch";
import * as borsh from "@coral-xyz/borsh";
import { Connection, PublicKey } from "@solana/web3.js";

/**
 * Returns a verified build from the anchor registry. null if no such
 * verified build exists, e.g., if the program has been upgraded since the
 * last verified build.
 */
export async function verifiedBuild(
  connection: Connection,
  programId: PublicKey,
  limit: number = 5
): Promise<Build | null> {
  const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
  const [programData, latestBuildsResp] = await Promise.all([
    fetchData(connection, programId),
    fetch(url),
  ]);

  // Filter out all non successful builds.
  const latestBuilds = (await latestBuildsResp.json()).filter(
    (b: Build) => !b.aborted && b.state === "Built" && b.verified === "Verified"
  );
  if (latestBuilds.length === 0) {
    return null;
  }

  // Get the latest build.
  const build = latestBuilds[0];

  // Has the program been upgraded since the last build?
  if (programData.slot.toNumber() !== build.verified_slot) {
    return null;
  }

  // Success.
  return build;
}

/**
 * Returns the program data account for this program, containing the
 * metadata for this program, e.g., the upgrade authority.
 */
export async function fetchData(
  connection: Connection,
  programId: PublicKey
): Promise<ProgramData> {
  const accountInfo = await connection.getAccountInfo(programId);
  if (accountInfo === null) {
    throw new Error("program account not found");
  }
  const { program } = decodeUpgradeableLoaderState(accountInfo.data);
  const programdataAccountInfo = await connection.getAccountInfo(
    program.programdataAddress
  );
  if (programdataAccountInfo === null) {
    throw new Error("program data account not found");
  }
  const { programData } = decodeUpgradeableLoaderState(
    programdataAccountInfo.data
  );
  return programData;
}

const UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum(
  [
    borsh.struct([], "uninitialized"),
    borsh.struct(
      [borsh.option(borsh.publicKey(), "authorityAddress")],
      "buffer"
    ),
    borsh.struct([borsh.publicKey("programdataAddress")], "program"),
    borsh.struct(
      [
        borsh.u64("slot"),
        borsh.option(borsh.publicKey(), "upgradeAuthorityAddress"),
      ],
      "programData"
    ),
  ],
  undefined,
  borsh.u32()
);

export function decodeUpgradeableLoaderState(data: Buffer): any {
  return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
}

export type ProgramData = {
  slot: BN;
  upgradeAuthorityAddress: PublicKey | null;
};

export type Build = {
  aborted: boolean;
  address: string;
  created_at: string;
  updated_at: string;
  descriptor: string[];
  docker: string;
  id: number;
  name: string;
  sha256: string;
  upgrade_authority: string;
  verified: string;
  verified_slot: number;
  state: string;
};


================================================
File: ts/packages/anchor/src/utils/sha256.ts
================================================
import { sha256 } from "@noble/hashes/sha256";

export function hash(data: string): string {
  return new TextDecoder().decode(sha256(data));
}


================================================
File: ts/packages/anchor/src/utils/token.ts
================================================
import { PublicKey } from "@solana/web3.js";

export const TOKEN_PROGRAM_ID = new PublicKey(
  "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
);
export const ASSOCIATED_PROGRAM_ID = new PublicKey(
  "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
);

export function associatedAddress({
  mint,
  owner,
}: {
  mint: PublicKey;
  owner: PublicKey;
}): PublicKey {
  return PublicKey.findProgramAddressSync(
    [owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],
    ASSOCIATED_PROGRAM_ID
  )[0];
}


================================================
File: ts/packages/anchor/src/utils/bytes/base64.ts
================================================
import { Buffer } from "buffer";

export function encode(data: Buffer): string {
  return data.toString("base64");
}

export function decode(data: string): Buffer {
  return Buffer.from(data, "base64");
}


================================================
File: ts/packages/anchor/src/utils/bytes/bs58.ts
================================================
import bs58 from "bs58";

export function encode(data: Buffer | number[] | Uint8Array) {
  return bs58.encode(data);
}

export function decode(data: string) {
  return bs58.decode(data);
}


================================================
File: ts/packages/anchor/src/utils/bytes/hex.ts
================================================
import { Buffer } from "buffer";

export function encode(data: Buffer): string {
  return data.reduce(
    (str, byte) => str + byte.toString(16).padStart(2, "0"),
    "0x"
  );
}

export function decode(data: string): Buffer {
  if (data.indexOf("0x") === 0) {
    data = data.substr(2);
  }
  if (data.length % 2 === 1) {
    data = "0" + data;
  }

  let key = data.match(/.{2}/g);

  if (key === null) {
    return Buffer.from([]);
  }

  return Buffer.from(key.map((byte) => parseInt(byte, 16)));
}


================================================
File: ts/packages/anchor/src/utils/bytes/index.ts
================================================
export * as hex from "./hex.js";
export * as utf8 from "./utf8.js";
export * as bs58 from "./bs58.js";
export * as base64 from "./base64.js";


================================================
File: ts/packages/anchor/src/utils/bytes/utf8.ts
================================================
import { isBrowser } from "../common";

export function decode(array: Uint8Array): string {
  const decoder = isBrowser
    ? new TextDecoder("utf-8") // Browser https://caniuse.com/textencoder.
    : new (require("util").TextDecoder)("utf-8"); // Node.

  return decoder.decode(array);
}

export function encode(input: string): Uint8Array {
  const encoder = isBrowser
    ? new TextEncoder() // Browser.
    : new (require("util").TextEncoder)("utf-8"); // Node.
  return encoder.encode(input);
}


================================================
File: ts/packages/anchor/tests/coder-accounts.spec.ts
================================================
import * as assert from "assert";
import { BorshCoder, Idl } from "../src";

describe("coder.accounts", () => {
  test("Can encode and decode user-defined accounts, including those with consecutive capital letters", () => {
    const idl: Idl = {
      address: "Test111111111111111111111111111111111111111",
      metadata: {
        name: "basic_0",
        version: "0.0.0",
        spec: "0.1.0",
      },
      instructions: [
        {
          name: "initialize",
          discriminator: [],
          accounts: [],
          args: [],
        },
      ],
      accounts: [
        {
          name: "MemberDAO",
          discriminator: [0, 1, 2, 3, 4, 5, 6, 7],
        },
      ],
      types: [
        {
          name: "MemberDAO",
          type: {
            kind: "struct",
            fields: [
              {
                name: "name",
                type: "string",
              },
            ],
          },
        },
      ],
    };
    const coder = new BorshCoder(idl);

    const memberDAO = {
      name: "test",
    };

    coder.accounts.encode("MemberDAO", memberDAO).then((encoded) => {
      assert.deepEqual(coder.accounts.decode("MemberDAO", encoded), memberDAO);
    });
  });
});


================================================
File: ts/packages/anchor/tests/coder-instructions.spec.ts
================================================
import * as assert from "assert";
import { BorshCoder } from "../src";
import { Idl, IdlType } from "../src/idl";
import { toInstruction } from "../src/program/common";

describe("coder.instructions", () => {
  test("Can encode and decode type aliased instruction arguments (byte array)", () => {
    const idl: Idl = {
      address: "Test111111111111111111111111111111111111111",
      metadata: {
        name: "test",
        version: "0.0.0",
        spec: "0.1.0",
      },
      instructions: [
        {
          name: "initialize",
          discriminator: [0, 1, 2, 3, 4, 5, 6, 7],
          accounts: [],
          args: [
            {
              name: "arg",
              type: {
                defined: {
                  name: "AliasTest",
                },
              },
            },
          ],
        },
      ],
      types: [
        {
          name: "AliasTest",
          type: {
            kind: "type",
            alias: {
              array: ["u8", 3] as [IdlType, number],
            },
          },
        },
      ],
    };

    const idlIx = idl.instructions[0];
    const expected = [1, 2, 3];

    const coder = new BorshCoder(idl);
    const ix = toInstruction(idlIx, expected);

    const encoded = coder.instruction.encode(idlIx.name, ix);
    const decoded = coder.instruction.decode(encoded);

    assert.deepStrictEqual(decoded?.data[idlIx.args[0].name], expected);
  });
});


================================================
File: ts/packages/anchor/tests/coder-types.spec.ts
================================================
import * as assert from "assert";
import { BorshCoder, Idl } from "../src";
import BN from "bn.js";

describe("coder.types", () => {
  test("Can encode and decode user-defined types", () => {
    const idl: Idl = {
      address: "Test111111111111111111111111111111111111111",
      metadata: {
        name: "basic_0",
        version: "0.0.0",
        spec: "0.1.0",
      },
      instructions: [
        {
          name: "initialize",
          accounts: [],
          args: [],
          discriminator: [],
        },
      ],
      types: [
        {
          name: "MintInfo",
          type: {
            kind: "struct",
            fields: [
              {
                name: "minted",
                type: "bool",
              },
              {
                name: "metadataUrl",
                type: "string",
              },
            ],
          },
        },
      ],
    };
    const coder = new BorshCoder(idl);

    const mintInfo = {
      minted: true,
      metadataUrl: "hello",
    };
    const encoded = coder.types.encode("MintInfo", mintInfo);

    assert.deepEqual(coder.types.decode("MintInfo", encoded), mintInfo);
  });

  test("Can encode and decode 256-bit integers", () => {
    const idl: Idl = {
      address: "Test111111111111111111111111111111111111111",
      metadata: {
        name: "basic_0",
        version: "0.0.0",
        spec: "0.1.0",
      },
      instructions: [
        {
          name: "initialize",
          accounts: [],
          args: [],
          discriminator: [],
        },
      ],
      types: [
        {
          name: "IntegerTest",
          type: {
            kind: "struct",
            fields: [
              {
                name: "unsigned",
                type: "u256",
              },
              {
                name: "signed",
                type: "i256",
              },
            ],
          },
        },
      ],
    };

    const testing = {
      unsigned: new BN(2588012355),
      signed: new BN(-93842345),
    };

    const coder = new BorshCoder(idl);
    const encoded = coder.types.encode("IntegerTest", testing);
    assert.strictEqual(
      coder.types.decode("IntegerTest", encoded).toString(),
      testing.toString()
    );
  });
});


================================================
File: ts/packages/anchor/tests/program-common.spec.ts
================================================
import BN from "bn.js";
import bs58 from "bs58";
import { PublicKey } from "@solana/web3.js";

import NodeWallet from "../src/nodewallet";
import { translateAddress } from "../src/program/common";

describe("program/common", () => {
  describe("translateAddress", () => {
    it("should accept a valid string address", () => {
      const address = "11111111111111111111111111111111";

      const func = () => translateAddress(address);
      expect(func).not.toThrow();

      const output = func();
      expect(output).toBeInstanceOf(PublicKey);
      expect(new PublicKey(address).equals(output)).toBeTruthy();
    });

    it("should accept a PublicKey address", () => {
      const publicKey = new PublicKey("11111111111111111111111111111111");

      const func = () => translateAddress(publicKey);
      expect(func).not.toThrow();

      const output = func();
      expect(output).toBeInstanceOf(PublicKey);
      expect(new PublicKey(publicKey).equals(output)).toBe(true);
    });

    it("should accept an object with a PublicKey shape { _bn }", () => {
      const obj = {
        _bn: new BN(bs58.decode("11111111111111111111111111111111")),
      } as any as PublicKey;
      const func = () => translateAddress(obj);

      expect(func).not.toThrow();
      const output = func();

      expect(output).toBeInstanceOf(PublicKey);
      expect(new PublicKey(obj).equals(output)).toBe(true);
    });

    it("should not accept an invalid string address", () => {
      const invalid = "invalid";
      const func = () => translateAddress(invalid);
      expect(func).toThrow();
    });

    it("should not accept an invalid object", () => {
      const invalid = {} as PublicKey;
      const func = () => translateAddress(invalid);
      expect(func).toThrow();
    });
  });

  describe("NodeWallet", () => {
    it("should throw an error when ANCHOR_WALLET is unset", () => {
      const oldValue = process.env.ANCHOR_WALLET;
      delete process.env.ANCHOR_WALLET;

      expect(() => NodeWallet.local()).toThrowError(
        "expected environment variable `ANCHOR_WALLET` is not set."
      );

      process.env.ANCHOR_WALLET = oldValue;
    });
  });
});


================================================
File: ts/packages/anchor/tests/transaction.spec.ts
================================================
import TransactionFactory from "../src/program/namespace/transaction";
import InstructionFactory from "../src/program/namespace/instruction";
import { BorshCoder, Idl } from "../src";
import { PublicKey, TransactionInstruction } from "@solana/web3.js";

describe("Transaction", () => {
  const preIx = new TransactionInstruction({
    keys: [],
    programId: PublicKey.default,
    data: Buffer.from("pre"),
  });
  const postIx = new TransactionInstruction({
    keys: [],
    programId: PublicKey.default,
    data: Buffer.from("post"),
  });
  const idl: Idl = {
    address: "Test111111111111111111111111111111111111111",
    metadata: {
      name: "basic_0",
      version: "0.0.0",
      spec: "0.1.0",
    },
    instructions: [
      {
        name: "initialize",
        accounts: [],
        args: [],
        discriminator: [],
      },
    ],
  };

  it("should add pre instructions before method ix", async () => {
    const coder = new BorshCoder(idl);
    const programId = PublicKey.default;
    const ixItem = InstructionFactory.build(
      idl.instructions[0],
      (ixName, ix) => coder.instruction.encode(ixName, ix),
      programId
    );
    const txItem = TransactionFactory.build(idl.instructions[0], ixItem);
    const tx = txItem({ accounts: {}, preInstructions: [preIx] });
    expect(tx.instructions.length).toBe(2);
    expect(tx.instructions[0]).toMatchObject(preIx);
  });

  it("should add post instructions after method ix", async () => {
    const coder = new BorshCoder(idl);
    const programId = PublicKey.default;
    const ixItem = InstructionFactory.build(
      idl.instructions[0],
      (ixName, ix) => coder.instruction.encode(ixName, ix),
      programId
    );
    const txItem = TransactionFactory.build(idl.instructions[0], ixItem);
    const tx = txItem({ accounts: {}, postInstructions: [postIx] });
    expect(tx.instructions.length).toBe(2);
    expect(tx.instructions[1]).toMatchObject(postIx);
  });

  it("should throw error if both preInstructions and instructions are used", async () => {
    const coder = new BorshCoder(idl);
    const programId = PublicKey.default;
    const ixItem = InstructionFactory.build(
      idl.instructions[0],
      (ixName, ix) => coder.instruction.encode(ixName, ix),
      programId
    );
    const txItem = TransactionFactory.build(idl.instructions[0], ixItem);

    expect(() =>
      txItem({ accounts: {}, preInstructions: [preIx], instructions: [preIx] })
    ).toThrow(new Error("instructions is deprecated, use preInstructions"));
  });
});


================================================
File: ts/packages/anchor-errors/package.json
================================================
{
  "name": "@coral-xyz/anchor-errors",
  "version": "0.30.1",
  "description": "Anchor error codes",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": "./dist/index.js"
  },
  "license": "Apache-2.0",
  "publishConfig": {
    "access": "public"
  },
  "engines": {
    "node": ">=10"
  },
  "scripts": {
    "build": "tsc",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc --watch",
    "prepublishOnly": "yarn build",
    "test": "",
    "clean": "rm -rf dist"
  },
  "files": [
    "dist"
  ],
  "devDependencies": {
    "prettier": "^2.1.2"
  }
}


================================================
File: ts/packages/anchor-errors/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "typeRoots": ["./types"]
  },
  "include": ["src/**/*"]
}


================================================
File: ts/packages/borsh/package.json
================================================
{
  "name": "@coral-xyz/borsh",
  "version": "0.30.1",
  "description": "Anchor Borsh",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": "./dist/index.js"
  },
  "license": "Apache-2.0",
  "publishConfig": {
    "access": "public"
  },
  "engines": {
    "node": ">=10"
  },
  "scripts": {
    "build": "tsc",
    "test": "",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "bn.js": "^5.1.2",
    "buffer-layout": "^1.2.0"
  },
  "peerDependencies": {
    "@solana/web3.js": "^1.69.0"
  },
  "files": [
    "dist"
  ],
  "devDependencies": {
    "@types/node": "^18.11.10"
  }
}


================================================
File: ts/packages/borsh/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "typeRoots": ["./types"]
  },
  "include": ["src/**/*"]
}


================================================
File: ts/packages/spl-associated-token-account/idl.json
================================================
{
  "version": "1.1.1",
  "name": "spl_associated_token_account",
  "instructions": [
    {
      "name": "create",
      "accounts": [
        {
          "name": "fundingAddress",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "associatedAccountAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "walletAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "createIdempotent",
      "accounts": [
        {
          "name": "fundingAddress",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "associatedAccountAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "walletAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenMintAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "recoverNested",
      "accounts": [
        {
          "name": "nestedAssociatedAccountAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "nestedTokenMintAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "destinationAssociatedAccountAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "ownerAssociatedAccountAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "ownerTokenMintAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "walletAddress",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "errors": [
    {
      "code": 0,
      "name": "InvalidOwner",
      "msg": "Associated token account owner does not match address derivation"
    }
  ]
}

================================================
File: ts/packages/spl-associated-token-account/package.json
================================================
{
  "name": "@coral-xyz/spl-associated-token-account",
  "description": "Anchor client for Solana Program Library Associated Token Account",
  "version": "1.1.1",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-associated-token-account/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-associated-token-account/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-associated-token-account/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-associated-token-account/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-associated-token-account/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_associated_token_account {
    use super::*;

    pub fn create(ctx: Context<Create>) -> Result<()> {
        Ok(())
    }

    pub fn create_idempotent(ctx: Context<CreateIdempotent>) -> Result<()> {
        Ok(())
    }

    pub fn recover_nested(ctx: Context<RecoverNested>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    #[account(mut)]
    funding_address: Signer<'info>,
    #[account(mut)]
    associated_account_address: AccountInfo<'info>,
    wallet_address: AccountInfo<'info>,
    token_mint_address: AccountInfo<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct CreateIdempotent<'info> {
    #[account(mut)]
    funding_address: Signer<'info>,
    #[account(mut)]
    associated_account_address: AccountInfo<'info>,
    wallet_address: AccountInfo<'info>,
    token_mint_address: AccountInfo<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct RecoverNested<'info> {
    #[account(mut)]
    nested_associated_account_address: AccountInfo<'info>,
    nested_token_mint_address: AccountInfo<'info>,
    #[account(mut)]
    destination_associated_account_address: AccountInfo<'info>,
    owner_associated_account_address: AccountInfo<'info>,
    owner_token_mint_address: AccountInfo<'info>,
    #[account(mut)]
    wallet_address: Signer<'info>,
    token_program: Program<'info, Token>,
}

#[error_code]
pub enum AssociatedTokenAccountError {
    // 0
    /// Associated token account owner does not match address derivation
    #[msg("Associated token account owner does not match address derivation")]
    InvalidOwner,
}


================================================
File: ts/packages/spl-associated-token-account/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-associated-token-account/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplAssociatedTokenAccountAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(accountName: A): number {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }
}


================================================
File: ts/packages/spl-associated-token-account/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplAssociatedTokenAccountEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplAssociatedTokenAccount program does not have events");
  }
}


================================================
File: ts/packages/spl-associated-token-account/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplAssociatedTokenAccountAccountsCoder } from "./accounts";
import { SplAssociatedTokenAccountEventsCoder } from "./events";
import { SplAssociatedTokenAccountInstructionCoder } from "./instructions";
import { SplAssociatedTokenAccountTypesCoder } from "./types";

/**
 * Coder for SplAssociatedTokenAccount
 */
export class SplAssociatedTokenAccountCoder implements Coder {
  readonly accounts: SplAssociatedTokenAccountAccountsCoder;
  readonly events: SplAssociatedTokenAccountEventsCoder;
  readonly instruction: SplAssociatedTokenAccountInstructionCoder;
  readonly types: SplAssociatedTokenAccountTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplAssociatedTokenAccountAccountsCoder(idl);
    this.events = new SplAssociatedTokenAccountEventsCoder(idl);
    this.instruction = new SplAssociatedTokenAccountInstructionCoder(idl);
    this.types = new SplAssociatedTokenAccountTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-associated-token-account/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplAssociatedTokenAccountInstructionCoder
  implements InstructionCoder
{
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "create": {
        return encodeCreate(ix);
      }
      case "createIdempotent": {
        return encodeCreateIdempotent(ix);
      }
      case "recoverNested": {
        return encodeRecoverNested(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplAssociatedTokenAccount does not have state");
  }
}

function encodeCreate({}: any): Buffer {
  return encodeData({ create: {} }, 1);
}

function encodeCreateIdempotent({}: any): Buffer {
  return encodeData({ createIdempotent: {} }, 1);
}

function encodeRecoverNested({}: any): Buffer {
  return encodeData({ recoverNested: {} }, 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(0, B.struct([]), "create");
LAYOUT.addVariant(1, B.struct([]), "createIdempotent");
LAYOUT.addVariant(2, B.struct([]), "recoverNested");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-associated-token-account/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplAssociatedTokenAccountTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error(
      "SplAssociatedTokenAccount does not have user-defined types"
    );
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error(
      "SplAssociatedTokenAccount does not have user-defined types"
    );
  }
}


================================================
File: ts/packages/spl-binary-option/package.json
================================================
{
  "name": "@coral-xyz/spl-binary-option",
  "description": "Anchor client for Solana Program Library Binary Option",
  "version": "0.1.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-binary-option/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-binary-option/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-binary-option/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-binary-option/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-binary-option/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-binary-option/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplBinaryOptionAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "binaryOption": {
        const buffer = Buffer.alloc(202);
        const len = BINARY_OPTION_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "binaryOption": {
        return decodeBinaryOptionAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "binaryOption": {
        return {
          dataSize: 202,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "binaryOption": {
        return 202;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodeBinaryOptionAccount<T = any>(ix: Buffer): T {
  return BINARY_OPTION_LAYOUT.decode(ix) as T;
}

const BINARY_OPTION_LAYOUT: any = B.struct([
  B.u8("decimals"),
  B.u64("circulation"),
  B.bool("settled"),
  B.publicKey("escrowMintAccountPubkey"),
  B.publicKey("escrowAccountPubkey"),
  B.publicKey("longMintAccountPubkey"),
  B.publicKey("shortMintAccountPubkey"),
  B.publicKey("owner"),
  B.publicKey("winningSidePubkey"),
]);


================================================
File: ts/packages/spl-binary-option/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplBinaryOptionEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplBinaryOption program does not have events");
  }
}


================================================
File: ts/packages/spl-binary-option/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplBinaryOptionAccountsCoder } from "./accounts";
import { SplBinaryOptionEventsCoder } from "./events";
import { SplBinaryOptionInstructionCoder } from "./instructions";
import { SplBinaryOptionTypesCoder } from "./types";

/**
 * Coder for SplBinaryOption
 */
export class SplBinaryOptionCoder implements Coder {
  readonly accounts: SplBinaryOptionAccountsCoder;
  readonly events: SplBinaryOptionEventsCoder;
  readonly instruction: SplBinaryOptionInstructionCoder;
  readonly types: SplBinaryOptionTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplBinaryOptionAccountsCoder(idl);
    this.events = new SplBinaryOptionEventsCoder(idl);
    this.instruction = new SplBinaryOptionInstructionCoder(idl);
    this.types = new SplBinaryOptionTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-binary-option/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplBinaryOptionInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "initializeBinaryOption": {
        return encodeInitializeBinaryOption(ix);
      }
      case "trade": {
        return encodeTrade(ix);
      }
      case "settle": {
        return encodeSettle(ix);
      }
      case "collect": {
        return encodeCollect(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplBinaryOption does not have state");
  }
}

function encodeInitializeBinaryOption({ decimals }: any): Buffer {
  return encodeData({ initializeBinaryOption: { decimals } }, 1 + 1);
}

function encodeTrade({ size, buyPrice, sellPrice }: any): Buffer {
  return encodeData({ trade: { size, buyPrice, sellPrice } }, 1 + 8 + 8 + 8);
}

function encodeSettle({}: any): Buffer {
  return encodeData({ settle: {} }, 1);
}

function encodeCollect({}: any): Buffer {
  return encodeData({ collect: {} }, 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(0, B.struct([B.u8("decimals")]), "initializeBinaryOption");
LAYOUT.addVariant(
  1,
  B.struct([B.u64("size"), B.u64("buyPrice"), B.u64("sellPrice")]),
  "trade"
);
LAYOUT.addVariant(2, B.struct([]), "settle");
LAYOUT.addVariant(3, B.struct([]), "collect");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-binary-option/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplBinaryOptionTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplBinaryOption does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplBinaryOption does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/package.json
================================================
{
  "name": "@coral-xyz/spl-binary-oracle-pair",
  "description": "Anchor client for Solana Program Library Binary Oracle Pair",
  "version": "0.1.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-binary-oracle-pair/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-binary-oracle-pair/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplBinaryOraclePairAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "pool": {
        const buffer = Buffer.alloc(179);
        const len = POOL_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "pool": {
        return decodePoolAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "pool": {
        return {
          dataSize: 179,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "pool": {
        return 179;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodePoolAccount<T = any>(ix: Buffer): T {
  return POOL_LAYOUT.decode(ix) as T;
}

const POOL_LAYOUT: any = B.struct([
  B.u8("version"),
  B.u8("bumpSeed"),
  B.publicKey("tokenProgramId"),
  B.publicKey("depositAccount"),
  B.publicKey("tokenPassMint"),
  B.publicKey("tokenFailMint"),
  B.publicKey("decider"),
  B.u64("mintEndSlot"),
  B.u64("decideEndSlot"),
  ((p: string) => {
    const U = B.union(B.u8("discriminator"), null, p);
    U.addVariant(0, B.struct([]), "undecided");
    U.addVariant(1, B.struct([]), "pass");
    U.addVariant(2, B.struct([]), "fail");
    return U;
  })("decision"),
]);


================================================
File: ts/packages/spl-binary-oracle-pair/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplBinaryOraclePairEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplBinaryOraclePair program does not have events");
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplBinaryOraclePairAccountsCoder } from "./accounts";
import { SplBinaryOraclePairEventsCoder } from "./events";
import { SplBinaryOraclePairInstructionCoder } from "./instructions";
import { SplBinaryOraclePairTypesCoder } from "./types";

/**
 * Coder for SplBinaryOraclePair
 */
export class SplBinaryOraclePairCoder implements Coder {
  readonly accounts: SplBinaryOraclePairAccountsCoder;
  readonly events: SplBinaryOraclePairEventsCoder;
  readonly instruction: SplBinaryOraclePairInstructionCoder;
  readonly types: SplBinaryOraclePairTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplBinaryOraclePairAccountsCoder(idl);
    this.events = new SplBinaryOraclePairEventsCoder(idl);
    this.instruction = new SplBinaryOraclePairInstructionCoder(idl);
    this.types = new SplBinaryOraclePairTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-binary-oracle-pair/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplBinaryOraclePairInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "initPool": {
        return encodeInitPool(ix);
      }
      case "deposit": {
        return encodeDeposit(ix);
      }
      case "withdraw": {
        return encodeWithdraw(ix);
      }
      case "decide": {
        return encodeDecide(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplBinaryOraclePair does not have state");
  }
}

function encodeInitPool({ mintEndSlot, decideEndSlot, bumpSeed }: any): Buffer {
  return encodeData(
    { initPool: { mintEndSlot, decideEndSlot, bumpSeed } },
    1 + 8 + 8 + 1
  );
}

function encodeDeposit({ arg }: any): Buffer {
  return encodeData({ deposit: { arg } }, 1 + 8);
}

function encodeWithdraw({ arg }: any): Buffer {
  return encodeData({ withdraw: { arg } }, 1 + 8);
}

function encodeDecide({ arg }: any): Buffer {
  return encodeData({ decide: { arg } }, 1 + 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(
  0,
  B.struct([B.u64("mintEndSlot"), B.u64("decideEndSlot"), B.u8("bumpSeed")]),
  "initPool"
);
LAYOUT.addVariant(1, B.struct([B.u64("arg")]), "deposit");
LAYOUT.addVariant(2, B.struct([B.u64("arg")]), "withdraw");
LAYOUT.addVariant(3, B.struct([B.bool("arg")]), "decide");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-binary-oracle-pair/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplBinaryOraclePairTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplBinaryOraclePair does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplBinaryOraclePair does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-feature-proposal/idl.json
================================================
{
  "version": "1.0.0",
  "name": "spl_feature_proposal",
  "instructions": [
    {
      "name": "propose",
      "accounts": [
        {
          "name": "fundingAddress",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "featureProposalAddress",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "mintAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "distributorTokenAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "acceptanceTokenAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "feature",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rent",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "tokensToMint",
          "type": "u64"
        },
        {
          "name": "acceptanceCriteria",
          "type": {
            "defined": "AcceptanceCriteria"
          }
        }
      ]
    },
    {
      "name": "tally",
      "accounts": [
        {
          "name": "featureProposalAddress",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "acceptanceTokenAddress",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feature",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "clock",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "FeatureProposal",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Uninitialized"
          },
          {
            "name": "Pending",
            "fields": [
              {
                "defined": "AcceptanceCriteria"
              }
            ]
          },
          {
            "name": "Accepted",
            "fields": [
              {
                "name": "tokens_upon_acceptance",
                "type": "u64"
              }
            ]
          },
          {
            "name": "Expired"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "AcceptanceCriteria",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "tokensRequired",
            "type": "u64"
          },
          {
            "name": "deadline",
            "type": "i64"
          }
        ]
      }
    }
  ]
}


================================================
File: ts/packages/spl-feature-proposal/package.json
================================================
{
  "name": "@coral-xyz/spl-feature-proposal",
  "description": "Anchor client for Solana Program Library Feature Proposal Program",
  "version": "1.0.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-feature-proposal/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-feature-proposal/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-feature-proposal/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-feature-proposal/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-feature-proposal/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_feature_proposal {
    use super::*;

    pub fn propose(
        ctx: Context<Propose>,
        tokens_to_mint: u64,
        acceptance_criteria: AcceptanceCriteria,
    ) -> Result<()> {
        Ok(())
    }

    pub fn tally(ctx: Context<Tally>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Propose<'info> {
    #[account(mut)]
    funding_address: Signer<'info>,
    #[account(mut)]
    feature_proposal_address: Signer<'info>,
    #[account(mut)]
    mint_address: AccountInfo<'info>,
    #[account(mut)]
    distributor_token_address: AccountInfo<'info>,
    #[account(mut)]
    acceptance_token_address: AccountInfo<'info>,
    #[account(mut)]
    feature: AccountInfo<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct Tally<'info> {
    #[account(mut)]
    feature_proposal_address: AccountInfo<'info>,
    acceptance_token_address: AccountInfo<'info>,
    #[account(mut)]
    feature: AccountInfo<'info>,
    system_program: Program<'info, System>,
    clock: Sysvar<'info, Clock>,
}

#[account]
pub enum FeatureProposal {
    /// Default account state after creating it
    Uninitialized,
    /// Feature proposal is now pending
    Pending(AcceptanceCriteria),
    /// Feature proposal was accepted and the feature is now active
    Accepted {
        /// The balance of the feature proposal's token account at the time of activation.
        #[allow(dead_code)] // not dead code..
        tokens_upon_acceptance: u64,
    },
    /// Feature proposal was not accepted before the deadline
    Expired,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AcceptanceCriteria {
    /// The balance of the feature proposal's token account must be greater than this amount, and
    /// tallied before the deadline for the feature to be accepted.
    pub tokens_required: u64,

    /// If the required tokens are not tallied by this deadline then the proposal will expire.
    pub deadline: i64,
}


================================================
File: ts/packages/spl-feature-proposal/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-feature-proposal/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplFeatureProposalAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "featureProposal": {
        const buffer = Buffer.alloc(17);
        const len = FEATURE_PROPOSAL_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "featureProposal": {
        return decodeFeatureProposalAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "featureProposal": {
        return {
          dataSize: 17,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "featureProposal": {
        return 17;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodeFeatureProposalAccount<T = any>(ix: Buffer): T {
  return FEATURE_PROPOSAL_LAYOUT.decode(ix) as T;
}

const FEATURE_PROPOSAL_LAYOUT = B.union(B.u8("discriminator"));
FEATURE_PROPOSAL_LAYOUT.addVariant(
  0,
  B.struct([B.u64("tokensRequired"), B.i64("deadline")]),
  "uninitialized"
);
FEATURE_PROPOSAL_LAYOUT.addVariant(1, B.struct([]), "pending");
FEATURE_PROPOSAL_LAYOUT.addVariant(
  2,
  B.struct([B.u64("tokensUponAcceptance")]),
  "accepted"
);
FEATURE_PROPOSAL_LAYOUT.addVariant(3, B.struct([]), "expired");


================================================
File: ts/packages/spl-feature-proposal/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplFeatureProposalEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplFeatureProposal program does not have events");
  }
}


================================================
File: ts/packages/spl-feature-proposal/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplFeatureProposalAccountsCoder } from "./accounts";
import { SplFeatureProposalEventsCoder } from "./events";
import { SplFeatureProposalInstructionCoder } from "./instructions";
import { SplFeatureProposalTypesCoder } from "./types";

/**
 * Coder for SplFeatureProposal
 */
export class SplFeatureProposalCoder implements Coder {
  readonly accounts: SplFeatureProposalAccountsCoder;
  readonly events: SplFeatureProposalEventsCoder;
  readonly instruction: SplFeatureProposalInstructionCoder;
  readonly types: SplFeatureProposalTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplFeatureProposalAccountsCoder(idl);
    this.events = new SplFeatureProposalEventsCoder(idl);
    this.instruction = new SplFeatureProposalInstructionCoder(idl);
    this.types = new SplFeatureProposalTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-feature-proposal/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplFeatureProposalInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "propose": {
        return encodePropose(ix);
      }
      case "tally": {
        return encodeTally(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplFeatureProposal does not have state");
  }
}

function encodePropose({ tokensToMint, acceptanceCriteria }: any): Buffer {
  return encodeData(
    { propose: { tokensToMint, acceptanceCriteria } },
    1 + 8 + 8 + 8
  );
}

function encodeTally({}: any): Buffer {
  return encodeData({ tally: {} }, 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(
  0,
  B.struct([
    B.u64("tokensToMint"),
    B.struct(
      [B.u64("tokensRequired"), B.i64("deadline")],
      "acceptanceCriteria"
    ),
  ]),
  "propose"
);
LAYOUT.addVariant(1, B.struct([]), "tally");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-feature-proposal/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplFeatureProposalTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplFeatureProposal does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplFeatureProposal does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-governance/package.json
================================================
{
  "name": "@coral-xyz/spl-governance",
  "description": "Anchor client for Solana Program Library Governance Program",
  "version": "3.0.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-governance/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-governance/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-governance/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-governance/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-governance/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-governance/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplGovernanceEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplGovernance program does not have events");
  }
}


================================================
File: ts/packages/spl-governance/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplGovernanceAccountsCoder } from "./accounts";
import { SplGovernanceEventsCoder } from "./events";
import { SplGovernanceInstructionCoder } from "./instructions";
import { SplGovernanceTypesCoder } from "./types";

/**
 * Coder for SplGovernance
 */
export class SplGovernanceCoder implements Coder {
  readonly accounts: SplGovernanceAccountsCoder;
  readonly events: SplGovernanceEventsCoder;
  readonly instruction: SplGovernanceInstructionCoder;
  readonly types: SplGovernanceTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplGovernanceAccountsCoder(idl);
    this.events = new SplGovernanceEventsCoder(idl);
    this.instruction = new SplGovernanceInstructionCoder(idl);
    this.types = new SplGovernanceTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-governance/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplGovernanceTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplGovernance does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplGovernance does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-memo/idl.json
================================================
{
  "version": "3.0.1",
  "name": "spl_memo",
  "instructions": [
    {
      "name": "addMemo",
      "accounts": [],
      "args": [
        {
          "name": "memo",
          "type": "string"
        }
      ]
    }
  ]
}

================================================
File: ts/packages/spl-memo/package.json
================================================
{
  "name": "@coral-xyz/spl-memo",
  "description": "Anchor client for Solana Program Library Memo",
  "version": "3.0.1",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-memo/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-memo/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-memo/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-memo/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-memo/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_memo {
    use super::*;

    pub fn add_memo(ctx: Context<AddMemo>, memo: String) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct AddMemo<'info> {
    // All memo accounts are optional and required to be signers
}


================================================
File: ts/packages/spl-memo/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-memo/src/program.ts
================================================
import { PublicKey } from "@solana/web3.js";
import { Program, AnchorProvider } from "@coral-xyz/anchor";

import { SplMemoCoder } from "./coder";

export const SPL_MEMO_PROGRAM_ID = new PublicKey(
  "Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo"
);

interface GetProgramParams {
  programId?: PublicKey;
  provider?: AnchorProvider;
}

export function splMemoProgram(params?: GetProgramParams): Program<SplMemo> {
  return new Program<SplMemo>(
    IDL,
    params?.programId ?? SPL_MEMO_PROGRAM_ID,
    params?.provider,
    new SplMemoCoder(IDL)
  );
}

type SplMemo = {
  version: "3.0.1";
  name: "spl_memo";
  instructions: [
    {
      name: "addMemo";
      accounts: [];
      args: [
        {
          name: "memo";
          type: "string";
        }
      ];
    }
  ];
};

const IDL: SplMemo = {
  version: "3.0.1",
  name: "spl_memo",
  instructions: [
    {
      name: "addMemo",
      accounts: [],
      args: [
        {
          name: "memo",
          type: "string",
        },
      ],
    },
  ],
};


================================================
File: ts/packages/spl-memo/src/coder/accounts.ts
================================================
// @ts-nocheck
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplMemoAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}


================================================
File: ts/packages/spl-memo/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplMemoEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplMemo program does not have events");
  }
}


================================================
File: ts/packages/spl-memo/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplMemoAccountsCoder } from "./accounts";
import { SplMemoEventsCoder } from "./events";
import { SplMemoInstructionCoder } from "./instructions";
import { SplMemoTypesCoder } from "./types";

/**
 * Coder for SplMemo
 */
export class SplMemoCoder implements Coder {
  readonly accounts: SplMemoAccountsCoder;
  readonly events: SplMemoEventsCoder;
  readonly instruction: SplMemoInstructionCoder;
  readonly types: SplMemoTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplMemoAccountsCoder(idl);
    this.events = new SplMemoEventsCoder(idl);
    this.instruction = new SplMemoInstructionCoder(idl);
    this.types = new SplMemoTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-memo/src/coder/instructions.ts
================================================
// @ts-nocheck
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplMemoInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "addMemo": {
        return encodeAddMemo(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplMemo does not have state");
  }
}

function encodeAddMemo({ memo }: any): Buffer {
  return Buffer.from(memo);
}


================================================
File: ts/packages/spl-memo/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplMemoTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplMemo does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplMemo does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-name-service/idl.json
================================================
{
  "version": "0.2.0",
  "name": "spl_name_service",
  "instructions": [
    {
      "name": "create",
      "accounts": [
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "payer",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "nameAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "nameOwner",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "hashedName",
          "type": "bytes"
        },
        {
          "name": "lamports",
          "type": "u64"
        },
        {
          "name": "space",
          "type": "u32"
        }
      ]
    },
    {
      "name": "update",
      "accounts": [
        {
          "name": "nameAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "nameUpdateSigner",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "offset",
          "type": "u32"
        },
        {
          "name": "data",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "transfer",
      "accounts": [
        {
          "name": "nameAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "nameOwner",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "newOwner",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "delete",
      "accounts": [
        {
          "name": "nameAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "nameOwner",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "refundTarget",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "NameRecordHeader",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "parentName",
            "type": "publicKey"
          },
          {
            "name": "owner",
            "type": "publicKey"
          },
          {
            "name": "class",
            "type": "publicKey"
          }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 0,
      "name": "OutOfSpace",
      "msg": "Out of space"
    }
  ]
}

================================================
File: ts/packages/spl-name-service/package.json
================================================
{
  "name": "@coral-xyz/spl-name-service",
  "description": "Anchor client for Solana Program Library Name Service",
  "version": "0.2.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-name-service/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-name-service/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-name-service/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-name-service/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-name-service/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_name_service {
    use super::*;

    pub fn create(
        ctx: Context<Create>,
        hashed_name: Vec<u8>,
        lamports: u64,
        space: u32,
    ) -> Result<()> {
        Ok(())
    }

    pub fn update(ctx: Context<Update>, offset: u32, data: Vec<u8>) -> Result<()> {
        Ok(())
    }

    pub fn transfer(ctx: Context<Transfer>, new_owner: Pubkey) -> Result<()> {
        Ok(())
    }

    pub fn delete(ctx: Context<Delete>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Create<'info> {
    system_program: Program<'info, System>,
    #[account(mut)]
    payer: Signer<'info>,
    #[account(mut)]
    name_account: AccountInfo<'info>,
    name_owner: AccountInfo<'info>,
    // optional_name_class: Signer<'info>,
    // optional_Pubkey: AccountInfo<'info>,
    // optional_name_parent: AccountInfo<'info>,
    // optional_Pubkey: AccountInfo<'info>,
    // optional_key: Signer<'info>,
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(mut)]
    name_account: AccountInfo<'info>,
    name_update_signer: Signer<'info>,
    // #[account(mut)]
    // optional_name_parent: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    name_account: AccountInfo<'info>,
    name_owner: Signer<'info>,
    // optional_key: Signer<'info>,
}

#[derive(Accounts)]
pub struct Delete<'info> {
    #[account(mut)]
    name_account: AccountInfo<'info>,
    name_owner: Signer<'info>,
    #[account(mut)]
    refund_target: AccountInfo<'info>,
}

#[account]
pub struct NameRecordHeader {
    // Names are hierarchical.  `parent_name` contains the account address of the parent
    // name, or `Pubkey::default()` if no parent exists.
    pub parent_name: Pubkey,

    // The owner of this name
    pub owner: Pubkey,

    // The class of data this account represents (DNS record, twitter handle, SPL Token name/symbol, etc)
    //
    // If `Pubkey::default()` the data is unspecified.
    pub class: Pubkey,
}

#[error_code]
pub enum NameServiceError {
    #[msg("Out of space")]
    OutOfSpace,
}


================================================
File: ts/packages/spl-name-service/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-name-service/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplNameServiceAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "nameRecordHeader": {
        const buffer = Buffer.alloc(96);
        const len = NAME_RECORD_HEADER_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "nameRecordHeader": {
        return decodeNameRecordHeaderAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "nameRecordHeader": {
        return {
          dataSize: 96,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "nameRecordHeader": {
        return 96;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodeNameRecordHeaderAccount<T = any>(ix: Buffer): T {
  return NAME_RECORD_HEADER_LAYOUT.decode(ix) as T;
}

const NAME_RECORD_HEADER_LAYOUT: any = B.struct([
  B.publicKey("parentName"),
  B.publicKey("owner"),
  B.publicKey("class"),
]);


================================================
File: ts/packages/spl-name-service/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplNameServiceEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplNameService program does not have events");
  }
}


================================================
File: ts/packages/spl-name-service/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplNameServiceAccountsCoder } from "./accounts";
import { SplNameServiceEventsCoder } from "./events";
import { SplNameServiceInstructionCoder } from "./instructions";
import { SplNameServiceTypesCoder } from "./types";

/**
 * Coder for SplNameService
 */
export class SplNameServiceCoder implements Coder {
  readonly accounts: SplNameServiceAccountsCoder;
  readonly events: SplNameServiceEventsCoder;
  readonly instruction: SplNameServiceInstructionCoder;
  readonly types: SplNameServiceTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplNameServiceAccountsCoder(idl);
    this.events = new SplNameServiceEventsCoder(idl);
    this.instruction = new SplNameServiceInstructionCoder(idl);
    this.types = new SplNameServiceTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-name-service/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplNameServiceInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "create": {
        return encodeCreate(ix);
      }
      case "update": {
        return encodeUpdate(ix);
      }
      case "transfer": {
        return encodeTransfer(ix);
      }
      case "delete": {
        return encodeDelete(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplNameService does not have state");
  }
}

function encodeCreate({ hashedName, lamports, space }: any): Buffer {
  return encodeData(
    { create: { hashedName, lamports, space } },
    1 + 4 + hashedName.length + 8 + 4
  );
}

function encodeUpdate({ offset, data }: any): Buffer {
  return encodeData({ update: { offset, data } }, 1 + 4 + 4 + data.length);
}

function encodeTransfer({ newOwner }: any): Buffer {
  return encodeData({ transfer: { newOwner } }, 1 + 32);
}

function encodeDelete({}: any): Buffer {
  return encodeData({ delete: {} }, 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(
  0,
  B.struct([B.bytes("hashedName"), B.u64("lamports"), B.u32("space")]),
  "create"
);
LAYOUT.addVariant(1, B.struct([B.u32("offset"), B.bytes("data")]), "update");
LAYOUT.addVariant(2, B.struct([B.publicKey("newOwner")]), "transfer");
LAYOUT.addVariant(3, B.struct([]), "delete");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-name-service/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplNameServiceTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplNameService does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplNameService does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-record/idl.json
================================================
{
  "version": "0.1.0",
  "name": "spl_record",
  "instructions": [
    {
      "name": "initialize",
      "accounts": [
        {
          "name": "recordAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "write",
      "accounts": [
        {
          "name": "recordAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signer",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "offset",
          "type": "u64"
        },
        {
          "name": "data",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "setAuthority",
      "accounts": [
        {
          "name": "recordAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signer",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "newAuthority",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "closeAccount",
      "accounts": [
        {
          "name": "recordAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "signer",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "receiver",
          "isMut": true,
          "isSigner": false
        }
      ],
      "args": []
    }
  ],
  "accounts": [
    {
      "name": "RecordData",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "authority",
            "type": "publicKey"
          },
          {
            "name": "data",
            "type": {
              "defined": "Data"
            }
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "Data",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "bytes",
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          }
        ]
      }
    }
  ],
  "errors": [
    {
      "code": 0,
      "name": "IncorrectAuthority",
      "msg": "Incorrect authority provided on update or delete"
    },
    {
      "code": 1,
      "name": "Overflow",
      "msg": "Calculation overflow"
    }
  ]
}

================================================
File: ts/packages/spl-record/package.json
================================================
{
  "name": "@coral-xyz/spl-record",
  "description": "Anchor client for Solana Program Library Record Program",
  "version": "0.1.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-record/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-record/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-record/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-record/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-record/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_record {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn write(ctx: Context<Write>, offset: u64, data: Vec<u8>) -> Result<()> {
        Ok(())
    }

    pub fn set_authority(ctx: Context<SetAuthority>) -> Result<()> {
        Ok(())
    }

    pub fn close_account(ctx: Context<CloseAccount>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    record_account: AccountInfo<'info>,
    authority: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct Write<'info> {
    #[account(mut)]
    record_account: AccountInfo<'info>,
    signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetAuthority<'info> {
    #[account(mut)]
    record_account: AccountInfo<'info>,
    signer: Signer<'info>,
    new_authority: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CloseAccount<'info> {
    #[account(mut)]
    record_account: AccountInfo<'info>,
    signer: Signer<'info>,
    #[account(mut)]
    receiver: AccountInfo<'info>,
}

#[account]
pub struct RecordData {
    /// Struct version, allows for upgrades to the program
    pub version: u8,

    /// The account allowed to update the data
    pub authority: Pubkey,

    /// The data contained by the account, could be anything serializable
    pub data: Data,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Data {
    /// The data contained by the account, could be anything or serializable
    pub bytes: [u8; 8],
}

#[error_code]
pub enum RecordError {
    /// Incorrect authority provided on update or delete
    #[msg("Incorrect authority provided on update or delete")]
    IncorrectAuthority,

    /// Calculation overflow
    #[msg("Calculation overflow")]
    Overflow,
}


================================================
File: ts/packages/spl-record/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-record/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplRecordAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "recordData": {
        const buffer = Buffer.alloc(41);
        const len = RECORD_DATA_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "recordData": {
        return decodeRecordDataAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "recordData": {
        return {
          dataSize: 41,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "recordData": {
        return 41;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodeRecordDataAccount<T = any>(ix: Buffer): T {
  return RECORD_DATA_LAYOUT.decode(ix) as T;
}

const RECORD_DATA_LAYOUT: any = B.struct([
  B.u8("version"),
  B.publicKey("authority"),
  B.struct([B.seq(B.u8(), 8, "bytes")], "data"),
]);


================================================
File: ts/packages/spl-record/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplRecordEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplRecord program does not have events");
  }
}


================================================
File: ts/packages/spl-record/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplRecordAccountsCoder } from "./accounts";
import { SplRecordEventsCoder } from "./events";
import { SplRecordInstructionCoder } from "./instructions";
import { SplRecordTypesCoder } from "./types";

/**
 * Coder for SplRecord
 */
export class SplRecordCoder implements Coder {
  readonly accounts: SplRecordAccountsCoder;
  readonly events: SplRecordEventsCoder;
  readonly instruction: SplRecordInstructionCoder;
  readonly types: SplRecordTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplRecordAccountsCoder(idl);
    this.events = new SplRecordEventsCoder(idl);
    this.instruction = new SplRecordInstructionCoder(idl);
    this.types = new SplRecordTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-record/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplRecordInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "initialize": {
        return encodeInitialize(ix);
      }
      case "write": {
        return encodeWrite(ix);
      }
      case "setAuthority": {
        return encodeSetAuthority(ix);
      }
      case "closeAccount": {
        return encodeCloseAccount(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplRecord does not have state");
  }
}

function encodeInitialize({}: any): Buffer {
  return encodeData({ initialize: {} }, 1);
}

function encodeWrite({ offset, data }: any): Buffer {
  return encodeData({ write: { offset, data } }, 1 + 8 + 4 + data.length);
}

function encodeSetAuthority({}: any): Buffer {
  return encodeData({ setAuthority: {} }, 1);
}

function encodeCloseAccount({}: any): Buffer {
  return encodeData({ closeAccount: {} }, 1);
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(0, B.struct([]), "initialize");
LAYOUT.addVariant(1, B.struct([B.u64("offset"), B.bytes("data")]), "write");
LAYOUT.addVariant(2, B.struct([]), "setAuthority");
LAYOUT.addVariant(3, B.struct([]), "closeAccount");

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-record/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplRecordTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplRecord does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplRecord does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-stake-pool/package.json
================================================
{
  "name": "@coral-xyz/spl-stake-pool",
  "description": "Anchor client for Solana Program Library Stake Pool",
  "version": "0.7.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-stake-pool/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-stake-pool/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-stake-pool/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-stake-pool/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-stake-pool/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-stake-pool/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplStakePoolEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplStakePool program does not have events");
  }
}


================================================
File: ts/packages/spl-stake-pool/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplStakePoolAccountsCoder } from "./accounts";
import { SplStakePoolEventsCoder } from "./events";
import { SplStakePoolInstructionCoder } from "./instructions";
import { SplStakePoolTypesCoder } from "./types";

/**
 * Coder for SplStakePool
 */
export class SplStakePoolCoder implements Coder {
  readonly accounts: SplStakePoolAccountsCoder;
  readonly events: SplStakePoolEventsCoder;
  readonly instruction: SplStakePoolInstructionCoder;
  readonly types: SplStakePoolTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplStakePoolAccountsCoder(idl);
    this.events = new SplStakePoolEventsCoder(idl);
    this.instruction = new SplStakePoolInstructionCoder(idl);
    this.types = new SplStakePoolTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-stake-pool/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplStakePoolTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplStakePool does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplStakePool does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-stateless-asks/idl.json
================================================
{
  "version": "0.1.0",
  "name": "spl_stateless_asks",
  "instructions": [
    {
      "name": "acceptOffer",
      "accounts": [
        {
          "name": "makerWallet",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "takerWallet",
          "isMut": false,
          "isSigner": true
        },
        {
          "name": "makerSrcAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "makerDstAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "takerSrcAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "takerDstAccount",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "makerMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "takerMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "hasMetadata",
          "type": "bool"
        },
        {
          "name": "makerSize",
          "type": "u64"
        },
        {
          "name": "takerSize",
          "type": "u64"
        },
        {
          "name": "bumpSeed",
          "type": "u8"
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 0,
      "name": "PublicKeyMismatch",
      "msg": "PublicKeyMismatch"
    },
    {
      "code": 1,
      "name": "InvalidMintAuthority",
      "msg": "InvalidMintAuthority"
    },
    {
      "code": 2,
      "name": "UninitializedAccount",
      "msg": "UninitializedAccount"
    },
    {
      "code": 3,
      "name": "IncorrectOwner",
      "msg": "IncorrectOwner"
    },
    {
      "code": 4,
      "name": "PublicKeysShouldBeUnique",
      "msg": "PublicKeysShouldBeUnique"
    },
    {
      "code": 5,
      "name": "StatementFalse",
      "msg": "StatementFalse"
    },
    {
      "code": 6,
      "name": "NotRentExempt",
      "msg": "NotRentExempt"
    },
    {
      "code": 7,
      "name": "NumericalOverflow",
      "msg": "NumericalOverflow"
    }
  ]
}

================================================
File: ts/packages/spl-stateless-asks/package.json
================================================
{
  "name": "@coral-xyz/spl-stateless-asks",
  "description": "Anchor client for Solana Program Library Stateless Asks",
  "version": "0.1.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-stateless-asks/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-stateless-asks/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-stateless-asks/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-stateless-asks/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-stateless-asks/program/lib.rs
================================================
// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_stateless_asks {
    use super::*;

    pub fn accept_offer(
        ctx: Context<AcceptOffer>,
        has_metadata: bool,
        maker_size: u64,
        taker_size: u64,
        bump_seed: u8,
    ) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct AcceptOffer<'info> {
    maker_wallet: AccountInfo<'info>,
    taker_wallet: Signer<'info>,
    #[account(mut)]
    maker_src_account: AccountInfo<'info>,
    #[account(mut)]
    maker_dst_account: AccountInfo<'info>,
    #[account(mut)]
    taker_src_account: AccountInfo<'info>,
    #[account(mut)]
    taker_dst_account: AccountInfo<'info>,
    maker_mint: AccountInfo<'info>,
    taker_mint: AccountInfo<'info>,
    authority: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    // optional_system_program: Program<'info, System>,
}

#[error_code]
pub enum UtilError {
    #[msg("PublicKeyMismatch")]
    PublicKeyMismatch,
    #[msg("InvalidMintAuthority")]
    InvalidMintAuthority,
    #[msg("UninitializedAccount")]
    UninitializedAccount,
    #[msg("IncorrectOwner")]
    IncorrectOwner,
    #[msg("PublicKeysShouldBeUnique")]
    PublicKeysShouldBeUnique,
    #[msg("StatementFalse")]
    StatementFalse,
    #[msg("NotRentExempt")]
    NotRentExempt,
    #[msg("NumericalOverflow")]
    NumericalOverflow,
}


================================================
File: ts/packages/spl-stateless-asks/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-stateless-asks/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplStatelessAsksAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}


================================================
File: ts/packages/spl-stateless-asks/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplStatelessAsksEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplStatelessAsks program does not have events");
  }
}


================================================
File: ts/packages/spl-stateless-asks/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplStatelessAsksAccountsCoder } from "./accounts";
import { SplStatelessAsksEventsCoder } from "./events";
import { SplStatelessAsksInstructionCoder } from "./instructions";
import { SplStatelessAsksTypesCoder } from "./types";

/**
 * Coder for SplStatelessAsks
 */
export class SplStatelessAsksCoder implements Coder {
  readonly accounts: SplStatelessAsksAccountsCoder;
  readonly events: SplStatelessAsksEventsCoder;
  readonly instruction: SplStatelessAsksInstructionCoder;
  readonly types: SplStatelessAsksTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplStatelessAsksAccountsCoder(idl);
    this.events = new SplStatelessAsksEventsCoder(idl);
    this.instruction = new SplStatelessAsksInstructionCoder(idl);
    this.types = new SplStatelessAsksTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-stateless-asks/src/coder/instructions.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { Idl, InstructionCoder } from "@coral-xyz/anchor";

export class SplStatelessAsksInstructionCoder implements InstructionCoder {
  constructor(_idl: Idl) {}

  encode(ixName: string, ix: any): Buffer {
    switch (ixName) {
      case "acceptOffer": {
        return encodeAcceptOffer(ix);
      }

      default: {
        throw new Error(`Invalid instruction: ${ixName}`);
      }
    }
  }

  encodeState(_ixName: string, _ix: any): Buffer {
    throw new Error("SplStatelessAsks does not have state");
  }
}

function encodeAcceptOffer({
  hasMetadata,
  makerSize,
  takerSize,
  bumpSeed,
}: any): Buffer {
  return encodeData(
    { acceptOffer: { hasMetadata, makerSize, takerSize, bumpSeed } },
    1 + 1 + 8 + 8 + 1
  );
}

const LAYOUT = B.union(B.u8("instruction"));
LAYOUT.addVariant(
  0,
  B.struct([
    B.bool("hasMetadata"),
    B.u64("makerSize"),
    B.u64("takerSize"),
    B.u8("bumpSeed"),
  ]),
  "acceptOffer"
);

function encodeData(ix: any, span: number): Buffer {
  const b = Buffer.alloc(span);
  LAYOUT.encode(ix, b);
  return b;
}


================================================
File: ts/packages/spl-stateless-asks/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplStatelessAsksTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplStatelessAsks does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplStatelessAsks does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-token/package.json
================================================
{
  "name": "@coral-xyz/spl-token",
  "description": "Anchor client for Solana Program Library Token",
  "version": "0.30.1",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-token/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-token/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-token/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-token/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-token/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-token/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplTokenEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplToken program does not have events");
  }
}


================================================
File: ts/packages/spl-token/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplTokenAccountsCoder } from "./accounts";
import { SplTokenEventsCoder } from "./events";
import { SplTokenInstructionCoder } from "./instructions";
import { SplTokenTypesCoder } from "./types";

/**
 * Coder for SplToken
 */
export class SplTokenCoder implements Coder {
  readonly accounts: SplTokenAccountsCoder;
  readonly events: SplTokenEventsCoder;
  readonly instruction: SplTokenInstructionCoder;
  readonly types: SplTokenTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplTokenAccountsCoder(idl);
    this.events = new SplTokenEventsCoder(idl);
    this.instruction = new SplTokenInstructionCoder(idl);
    this.types = new SplTokenTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-token/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplTokenTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplToken does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplToken does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-token-lending/package.json
================================================
{
  "name": "@coral-xyz/spl-token-lending",
  "description": "Anchor client for Solana Program Library Token Lending",
  "version": "0.2.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-token-lending/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-token-lending/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-token-lending/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-token-lending/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-token-lending/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-token-lending/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplTokenLendingEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplTokenLending program does not have events");
  }
}


================================================
File: ts/packages/spl-token-lending/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplTokenLendingAccountsCoder } from "./accounts";
import { SplTokenLendingEventsCoder } from "./events";
import { SplTokenLendingInstructionCoder } from "./instructions";
import { SplTokenLendingTypesCoder } from "./types";

/**
 * Coder for SplTokenLending
 */
export class SplTokenLendingCoder implements Coder {
  readonly accounts: SplTokenLendingAccountsCoder;
  readonly events: SplTokenLendingEventsCoder;
  readonly instruction: SplTokenLendingInstructionCoder;
  readonly types: SplTokenLendingTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplTokenLendingAccountsCoder(idl);
    this.events = new SplTokenLendingEventsCoder(idl);
    this.instruction = new SplTokenLendingInstructionCoder(idl);
    this.types = new SplTokenLendingTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-token-lending/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplTokenLendingTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplTokenLending does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplTokenLending does not have user-defined types");
  }
}


================================================
File: ts/packages/spl-token-swap/package.json
================================================
{
  "name": "@coral-xyz/spl-token-swap",
  "description": "Anchor client for Solana Program Library Token Swap",
  "version": "3.0.0",
  "author": "acheron <acheroncrypto@gmail.com>",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/coral-xyz/anchor.git"
  },
  "files": [
    "dist"
  ],
  "module": "./dist/esm/index.js",
  "main": "./dist/cjs/index.js",
  "browser": "./dist/browser/index.js",
  "types": "./dist/cjs/index.d.ts",
  "scripts": {
    "init:yarn": "yarn && yarn lint:fix && yarn build:yarn",
    "init:npm": "npm i && npm run lint:fix && npm run build:npm",
    "build:yarn": "rimraf dist/ && yarn build:node && yarn build:browser",
    "build:npm": "rimraf dist/ && npm run build:node && npm run build:browser",
    "build:node": "tsc && tsc -p tsconfig.cjs.json",
    "build:browser": "rollup --config",
    "lint:fix": "prettier src/** -w",
    "lint": "prettier src/** --check",
    "watch": "tsc -p tsconfig.cjs.json --watch"
  },
  "dependencies": {
    "@coral-xyz/anchor": "=0.30.1",
    "@native-to-anchor/buffer-layout": "=0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "=21.0.2",
    "@rollup/plugin-node-resolve": "=13.1.3",
    "@rollup/plugin-replace": "=3.1.0",
    "@rollup/plugin-typescript": "=8.3.1",
    "@types/node": "=17.0.21",
    "prettier": "=2.7.1",
    "rimraf": "=3.0.2",
    "rollup": "=2.70.1",
    "rollup-plugin-terser": "=7.0.2",
    "tslib": "=2.3.1",
    "typescript": "=4.6.2"
  }
}


================================================
File: ts/packages/spl-token-swap/rollup.config.ts
================================================
import nodeResolve from "@rollup/plugin-node-resolve";
import typescript from "@rollup/plugin-typescript";
import replace from "@rollup/plugin-replace";
import commonjs from "@rollup/plugin-commonjs";
import { terser } from "rollup-plugin-terser";

const env = process.env.NODE_ENV;

export default {
  input: "src/index.ts",
  plugins: [
    commonjs(),
    nodeResolve({
      browser: true,
      extensions: [".js", ".ts"],
      dedupe: ["bn.js", "buffer"],
      preferBuiltins: false,
    }),
    typescript({
      tsconfig: "./tsconfig.base.json",
      moduleResolution: "node",
      outDir: "types",
      target: "es2019",
      outputToFilesystem: false,
    }),
    replace({
      preventAssignment: true,
      values: {
        "process.env.NODE_ENV": JSON.stringify(env),
        "process.env.ANCHOR_BROWSER": JSON.stringify(true),
      },
    }),
    terser(),
  ],
  external: [
    "@coral-xyz/borsh",
    "@solana/web3.js",
    "bn.js",
    "bs58",
    "buffer",
    "camelcase",
    "eventemitter3",
    "@noble/hashes/sha256",
    "pako",
    "toml",
  ],
  output: {
    file: "dist/browser/index.js",
    format: "es",
    sourcemap: true,
  },
};


================================================
File: ts/packages/spl-token-swap/tsconfig.base.json
================================================
{
  "include": [
    "./src/**/*"
  ],
  "compilerOptions": {
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "noImplicitAny": false,
    "strictNullChecks": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "composite": true,
    "baseUrl": ".",
    "typeRoots": [
      "node_modules/@types"
    ],
  }
}


================================================
File: ts/packages/spl-token-swap/tsconfig.cjs.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2019",
    "outDir": "dist/cjs/",
    "rootDir": "./src"
  }
}


================================================
File: ts/packages/spl-token-swap/tsconfig.json
================================================
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "moduleResolution": "node",
    "module": "es2022",
    "target": "es2019",
    "outDir": "dist/esm/",
    "rootDir": "./src",
  }
}


================================================
File: ts/packages/spl-token-swap/src/index.ts
================================================
export * from "./program";


================================================
File: ts/packages/spl-token-swap/src/coder/accounts.ts
================================================
// @ts-nocheck
import * as B from "@native-to-anchor/buffer-layout";
import { AccountsCoder, Idl } from "@coral-xyz/anchor";
import { IdlTypeDef } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplTokenSwapAccountsCoder<A extends string = string>
  implements AccountsCoder
{
  constructor(_idl: Idl) {}

  public async encode<T = any>(accountName: A, account: T): Promise<Buffer> {
    switch (accountName) {
      case "swap": {
        const buffer = Buffer.alloc(324);
        const len = SWAP_LAYOUT.encode(account, buffer);
        return buffer.slice(0, len);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public decode<T = any>(accountName: A, ix: Buffer): T {
    return this.decodeUnchecked(accountName, ix);
  }

  public decodeUnchecked<T = any>(accountName: A, ix: Buffer): T {
    switch (accountName) {
      case "swap": {
        return decodeSwapAccount(ix);
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public memcmp(
    accountName: A,
    _appendData?: Buffer
  ): { dataSize?: number; offset?: number; bytes?: string } {
    switch (accountName) {
      case "swap": {
        return {
          dataSize: 324,
        };
      }
      default: {
        throw new Error(`Invalid account name: ${accountName}`);
      }
    }
  }

  public size(idlAccount: IdlTypeDef): number {
    switch (idlAccount.name) {
      case "swap": {
        return 324;
      }
      default: {
        throw new Error(`Invalid account name: ${idlAccount.name}`);
      }
    }
  }
}

function decodeSwapAccount<T = any>(ix: Buffer): T {
  return SWAP_LAYOUT.decode(ix) as T;
}

const SWAP_LAYOUT: any = B.struct([
  B.u8("version"),
  B.bool("isInitialized"),
  B.u8("bumpSeed"),
  B.publicKey("tokenProgramId"),
  B.publicKey("tokenA"),
  B.publicKey("tokenB"),
  B.publicKey("poolMint"),
  B.publicKey("tokenAMint"),
  B.publicKey("tokenBMint"),
  B.publicKey("poolFeeAccount"),
  B.struct(
    [
      B.u64("tradeFeeNumerator"),
      B.u64("tradeFeeDenominator"),
      B.u64("ownerTradeFeeNumerator"),
      B.u64("ownerTradeFeeDenominator"),
      B.u64("ownerWithdrawFeeNumerator"),
      B.u64("ownerWithdrawFeeDenominator"),
      B.u64("hostFeeNumerator"),
      B.u64("hostFeeDenominator"),
    ],
    "fees"
  ),
  B.struct(
    [
      ((p: string) => {
        const U = B.union(B.u8("discriminator"), null, p);
        U.addVariant(0, B.struct([]), "constantProduct");
        U.addVariant(1, B.struct([]), "constantPrice");
        U.addVariant(2, B.struct([]), "stable");
        U.addVariant(3, B.struct([]), "offset");
        return U;
      })("curveType"),
      B.seq(B.u8(), 32, "calculator"),
    ],
    "swapCurve"
  ),
]);


================================================
File: ts/packages/spl-token-swap/src/coder/events.ts
================================================
import { Idl, Event, EventCoder } from "@coral-xyz/anchor";
import { IdlEvent } from "@coral-xyz/anchor/dist/cjs/idl";

export class SplTokenSwapEventsCoder implements EventCoder {
  constructor(_idl: Idl) {}

  decode<E extends IdlEvent = IdlEvent, T = Record<string, string>>(
    _log: string
  ): Event<E, T> | null {
    throw new Error("SplTokenSwap program does not have events");
  }
}


================================================
File: ts/packages/spl-token-swap/src/coder/index.ts
================================================
import { Idl, Coder } from "@coral-xyz/anchor";

import { SplTokenSwapAccountsCoder } from "./accounts";
import { SplTokenSwapEventsCoder } from "./events";
import { SplTokenSwapInstructionCoder } from "./instructions";
import { SplTokenSwapTypesCoder } from "./types";

/**
 * Coder for SplTokenSwap
 */
export class SplTokenSwapCoder implements Coder {
  readonly accounts: SplTokenSwapAccountsCoder;
  readonly events: SplTokenSwapEventsCoder;
  readonly instruction: SplTokenSwapInstructionCoder;
  readonly types: SplTokenSwapTypesCoder;

  constructor(idl: Idl) {
    this.accounts = new SplTokenSwapAccountsCoder(idl);
    this.events = new SplTokenSwapEventsCoder(idl);
    this.instruction = new SplTokenSwapInstructionCoder(idl);
    this.types = new SplTokenSwapTypesCoder(idl);
  }
}


================================================
File: ts/packages/spl-token-swap/src/coder/types.ts
================================================
import { Idl, TypesCoder } from "@coral-xyz/anchor";

export class SplTokenSwapTypesCoder implements TypesCoder {
  constructor(_idl: Idl) {}

  encode<T = any>(_name: string, _type: T): Buffer {
    throw new Error("SplTokenSwap does not have user-defined types");
  }
  decode<T = any>(_name: string, _typeData: Buffer): T {
    throw new Error("SplTokenSwap does not have user-defined types");
  }
}


================================================
File: ts/tests/package.json
================================================
{
  "name": "@coral-xyz/tests",
  "version": "0.1.0",
  "private": true,
  "main": "index.js",
  "scripts": {
    "test": "rimraf dist && tsc -p . && ts-node dist"
  },
  "devDependencies": {
    "@types/node": "*",
    "rimraf": "*",
    "ts-node": "*",
    "typescript": "*"
  },
  "dependencies": {}
}


================================================
File: ts/tests/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["esnext"],
    "target": "ES2019",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "noImplicitAny": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node"]
  },
  "exclude": ["node_modules"]
}


================================================
File: ts/tests/src/constants.ts
================================================
import { PublicKey } from "@solana/web3.js";

// Change if needed
export const SPL_ATA_PROGRAM_ID = new PublicKey(
  "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
  // "Gf4u1KmyV3kbHtGUbbLAcGRW8eKYUPTD7bTfBnqsU3Qc"
);
export const SPL_BINARY_OPTION_PROGRAM_ID = new PublicKey(
  "betw959P4WToez4DkuXwNsJszqbpe3HuY56AcG5yevx"
  // "A1hdS8fZfzKv3HhC4vbmrLGqwagXsotq134cxon5VENj"
);
export const SPL_BINARY_ORACLE_PAIR_PROGRAM_ID = new PublicKey(
  "Fd7btgySsrjuo25CJCj7oE7VPMyezDhnx7pZkj2v69Nk"
  // "ABPZtwmic6WgbJ7gUiSJdoY8EoxHFisamm46SJqARrDn"
);
export const SPL_FEATURE_PROPOSAL_PROGRAM_ID = new PublicKey(
  "Feat1YXHhH6t1juaWF74WLcfv4XoNocjXA6sPWHNgAse"
  // "9LFem7sbDXAgo3x6WCmhUKw3F4LTLzbpgF6z6v4i28wF"
);
export const SPL_MEMO_PROGRAM_ID = new PublicKey(
  "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
  // "8voWJyjpHjfbwsiTzpTi9HGpkRLwxTYm9MoeTBjXGNmw"
);
export const SPL_NAME_SERVICE_PROGRAM_ID = new PublicKey(
  "namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"
  // "CNbPGDMaGg4kQ7V8aYQfwvYRBEGhuBAuRZ8xdNFxQzWH"
);
export const SPL_RECORD_PROGRAM_ID = new PublicKey(
  "ReciQBw6sQKH9TVVJQDnbnJ5W7FP539tPHjZhRF4E9r"
  // "BKXzaCZdiwKaDWYYJErYUNboBJjE9zH6tegMnWFcg3y6"
);
export const SPL_STAKE_POOL_PROGRAM_ID = new PublicKey(
  "SPoo1Ku8WFXoNDMHPsrGSTSG1Y47rzgn41SLUNakuHy"
  // "DVhiaSgob9RxuFSUuHp3oB8vCYPNsnFWPXNYqpbNdDFX"
);
export const SPL_STATELESS_ASKS_PROGRAM_ID = new PublicKey(
  "DsowZuLsMv2Fjn9S2yUBwm62HPt42NdeMNXh7mM9nS9K"
);
export const SPL_TOKEN_PROGRAM_ID = new PublicKey(
  "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
  // "G3VapiV9ASomTQKR93Vm9T67HTXuj61gcAkqTq3ArHfT"
);
export const SPL_TOKEN_2022_PROGRAM_ID = new PublicKey(
  "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
  // "CQjRzEDPDRJxmV96XT9MvkMew6fSrHjzAQAya2cSQ7ni"
);
export const SPL_TOKEN_LENDING_PROGRAM_ID = new PublicKey(
  "6TvznH3B2e3p2mbhufNBpgSrLx6UkgvxtVQvopEZ2kuH"
  // "92531Wv1AGo5uCW5j8AesvCpj4KXLMs1PgJXv3YUeQWx"
);
export const SPL_TOKEN_SWAP_PROGRAM_ID = new PublicKey(
  "SwapsVeCiPHMUAtzQWZw7RjsKjgCjhwU55QGu4U1Szw"
  // "F7ySqYVC2X9YFkCTcoAgVBsZCpUHeRfXvWV8ysERoNGb"
);

export const NATIVE_MINT_PK = new PublicKey(
  "So11111111111111111111111111111111111111112"
);


================================================
File: ts/tests/src/index.ts
================================================
// Tests are for whether we are able to call native Solana programs and fetch
// program state through Anchor client and not for whether internal program logic
// works as intended. For the latter case, check out the program's repository.
//
// Tests are for the latest versions of the programs as of 2022-08-20, in order for
// tests to work, make sure the programs are up-to date in your local validator.

import * as SPL from "./spl";
import { mainTest, programTest } from "./utils";

// You can remove `await`s if you want to run tests in parallel(faster).
mainTest(async () => {
  await programTest(SPL.associatedTokenAccountTests);
  await programTest(SPL.binaryOptionTests);
  await programTest(SPL.binaryOraclePairTests);
  await programTest(SPL.featureProposalTests);
  await programTest(SPL.memoTests);
  await programTest(SPL.nameServiceTests);
  await programTest(SPL.recordTests);
  await programTest(SPL.splTokenTests);
  await programTest(SPL.stakePoolTests);
  await programTest(SPL.statelessAsksTests);
  await programTest(SPL.tokenSwapTests);
});


================================================
File: ts/tests/src/spl/associated-token-account.ts
================================================
import { splAssociatedTokenAccountProgram } from "@coral-xyz/spl-associated-token-account";
import { splTokenProgram } from "@coral-xyz/spl-token";
import { Keypair, PublicKey, SystemProgram } from "@solana/web3.js";

import { SPL_ATA_PROGRAM_ID, SPL_TOKEN_PROGRAM_ID } from "../constants";
import {
  createMint,
  getAta,
  getProvider,
  loadKp,
  sendAndConfirmTx,
  test,
} from "../utils";

export async function associatedTokenAccountTests() {
  const provider = await getProvider();
  const ataProgram = splAssociatedTokenAccountProgram({
    provider,
    programId: SPL_ATA_PROGRAM_ID,
  });
  const tokenProgram = splTokenProgram({
    provider,
    programId: SPL_TOKEN_PROGRAM_ID,
  });
  const kp = await loadKp();

  let mintPk: PublicKey;
  let ataPk: PublicKey;

  async function create() {
    mintPk = await createMint();
    ataPk = await getAta(mintPk, kp.publicKey);

    const createAtaIx = await ataProgram.methods
      .create()
      .accounts({
        associatedAccountAddress: ataPk,
        fundingAddress: kp.publicKey,
        systemProgram: SystemProgram.programId,
        tokenMintAddress: mintPk,
        tokenProgram: tokenProgram.programId,
        walletAddress: kp.publicKey,
      })
      .instruction();

    await sendAndConfirmTx([createAtaIx], [kp]);
  }

  async function createIdempotent() {
    const randomPk = new Keypair().publicKey;

    const createAtaIdempotentIx = await ataProgram.methods
      .createIdempotent()
      .accounts({
        associatedAccountAddress: await getAta(mintPk, randomPk),
        fundingAddress: kp.publicKey,
        systemProgram: SystemProgram.programId,
        tokenMintAddress: mintPk,
        tokenProgram: tokenProgram.programId,
        walletAddress: randomPk,
      })
      .instruction();

    await sendAndConfirmTx([createAtaIdempotentIx], [kp]);
  }

  async function recoverNested() {
    // Create ata address for the ata
    const nestedAtaPk = await getAta(mintPk, ataPk);
    const createAtaIx = await ataProgram.methods
      .create()
      .accounts({
        associatedAccountAddress: nestedAtaPk,
        fundingAddress: kp.publicKey,
        systemProgram: SystemProgram.programId,
        tokenMintAddress: mintPk,
        tokenProgram: tokenProgram.programId,
        walletAddress: ataPk,
      })
      .instruction();
    const recoverNestedIx = await ataProgram.methods
      .recoverNested()
      .accounts({
        destinationAssociatedAccountAddress: ataPk,
        nestedAssociatedAccountAddress: nestedAtaPk,
        nestedTokenMintAddress: mintPk,
        ownerAssociatedAccountAddress: ataPk,
        ownerTokenMintAddress: mintPk,
        tokenProgram: tokenProgram.programId,
        walletAddress: kp.publicKey,
      })
      .instruction();

    await sendAndConfirmTx([createAtaIx], [kp]);
    await sendAndConfirmTx([recoverNestedIx], [kp]);
  }

  await test(create);
  await test(createIdempotent);
  await test(recoverNested);
}


================================================
File: ts/tests/src/spl/feature-proposal.ts
================================================
import { splFeatureProposalProgram } from "@coral-xyz/spl-feature-proposal";
import { splTokenProgram } from "@coral-xyz/spl-token";
import { BN } from "@coral-xyz/anchor";
import {
  Keypair,
  PublicKey,
  SystemProgram,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_RENT_PUBKEY,
} from "@solana/web3.js";

import {
  SPL_FEATURE_PROPOSAL_PROGRAM_ID,
  SPL_TOKEN_PROGRAM_ID,
} from "../constants";
import { getProvider, loadKp, sendAndConfirmTx, test } from "../utils";

export async function featureProposalTests() {
  const provider = await getProvider();
  const program = splFeatureProposalProgram({
    provider,
    programId: SPL_FEATURE_PROPOSAL_PROGRAM_ID,
  });
  const tokenProgram = splTokenProgram({
    provider,
    programId: SPL_TOKEN_PROGRAM_ID,
  });
  const kp = await loadKp();

  let featureProposalPk: PublicKey;
  let acceptanceTokenAccountPk: PublicKey;
  let featureIdPk: PublicKey;

  async function propose() {
    const featureProposalKp = new Keypair();
    featureProposalPk = featureProposalKp.publicKey;

    const [mintPk] = await PublicKey.findProgramAddress(
      [featureProposalPk.toBuffer(), Buffer.from("mint")],
      program.programId
    );
    const [distributorTokenAccountPk] = await PublicKey.findProgramAddress(
      [featureProposalPk.toBuffer(), Buffer.from("distributor")],
      program.programId
    );
    [acceptanceTokenAccountPk] = await PublicKey.findProgramAddress(
      [featureProposalPk.toBuffer(), Buffer.from("acceptance")],
      program.programId
    );
    [featureIdPk] = await PublicKey.findProgramAddress(
      [featureProposalPk.toBuffer(), Buffer.from("feature-id")],
      program.programId
    );

    const proposeIx = await program.methods
      .propose(new BN(10), { tokensRequired: new BN(5), deadline: new BN(24) })
      .accounts({
        fundingAddress: kp.publicKey,
        featureProposalAddress: featureProposalPk,
        mintAddress: mintPk,
        distributorTokenAddress: distributorTokenAccountPk,
        acceptanceTokenAddress: acceptanceTokenAccountPk,
        feature: featureIdPk,
        systemProgram: SystemProgram.programId,
        tokenProgram: tokenProgram.programId,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .instruction();

    await sendAndConfirmTx([proposeIx], [kp, featureProposalKp]);
  }

  async function tally() {
    const tallyIx = await program.methods
      .tally()
      .accounts({
        featureProposalAddress: featureProposalPk,
        acceptanceTokenAddress: acceptanceTokenAccountPk,
        feature: featureIdPk,
        systemProgram: SystemProgram.programId,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .instruction();

    await sendAndConfirmTx([tallyIx], [kp]);
  }

  async function fetchFeatureProposal() {
    const featureProposal = await program.account.featureProposal.fetch(
      featureProposalPk
    );
    if (!featureProposal.expired) {
      throw new Error("Feature should be expired.");
    }
  }

  await test(propose);
  await test(tally);
  await test(fetchFeatureProposal);
}


================================================
File: ts/tests/src/spl/index.ts
================================================
export { associatedTokenAccountTests } from "./associated-token-account";
export { binaryOptionTests } from "./binary-option";
export { binaryOraclePairTests } from "./binary-oracle-pair";
export { featureProposalTests } from "./feature-proposal";
export { memoTests } from "./memo";
export { nameServiceTests } from "./name-service";
export { recordTests } from "./record";
export { splTokenTests } from "./token";
export { stakePoolTests } from "./stake-pool";
export { statelessAsksTests } from "./stateless-asks";
export { tokenLendingTests } from "./token-lending";
export { tokenSwapTests } from "./token-swap";


================================================
File: ts/tests/src/spl/memo.ts
================================================
import assert from "assert";
import { splMemoProgram } from "@coral-xyz/spl-memo";
import { Keypair } from "@solana/web3.js";

import { SPL_MEMO_PROGRAM_ID } from "../constants";
import { confirmTx, getProvider, loadKp, test } from "../utils";

export async function memoTests() {
  const provider = await getProvider();
  const program = splMemoProgram({
    provider,
    programId: SPL_MEMO_PROGRAM_ID,
  });
  const kp = await loadKp();

  const msg = "Memo from Anchor";
  let memoTxHash: string;

  async function memo() {
    memoTxHash = await program.methods.addMemo(msg).accounts({}).rpc();
  }

  async function fetchMemoTx() {
    await confirmTx(memoTxHash);
    const tx = await provider.connection.getTransaction(memoTxHash);
    const logs = tx?.meta?.logMessages;
    if (!logs) throw new Error("No transaction logs!");

    const memoLine = logs.find((l) => l.startsWith("Program log: Memo"));
    if (!memoLine) throw new Error("No memo line!");

    assert(memoLine === `Program log: Memo (len ${msg.length}): "${msg}"`);
  }

  async function memoWithSigners() {
    const otherSigner = new Keypair();
    await program.methods
      .addMemo("Memo with signers")
      .remainingAccounts([
        { pubkey: kp.publicKey, isSigner: true, isWritable: false },
        { pubkey: otherSigner.publicKey, isSigner: true, isWritable: false },
      ])
      .signers([otherSigner])
      .rpc();
  }

  await test(memo);
  await test(fetchMemoTx);
  await test(memoWithSigners);
}


================================================
File: ts/tests/src/spl/name-service.ts
================================================
import { createHash } from "crypto";
import { splNameServiceProgram } from "@coral-xyz/spl-name-service";
import { BN } from "@coral-xyz/anchor";

import { SPL_NAME_SERVICE_PROGRAM_ID } from "../constants";
import { confirmTx, getProvider, loadKp, test } from "../utils";
import { Keypair, PublicKey, SystemProgram } from "@solana/web3.js";

export async function nameServiceTests() {
  const provider = await getProvider();
  const program = splNameServiceProgram({
    provider,
    programId: SPL_NAME_SERVICE_PROGRAM_ID,
  });
  const kp = await loadKp();

  const getHashedName = (s: string) => {
    return createHash("sha256")
      .update(PREFIX + s, "utf8")
      .digest();
  };

  const PREFIX = "SPL Name Service";
  const NAME = "anchor" + Math.floor(Math.random() * 1000);
  const UPDATE_NAME = "acheron";

  const newOwnerKp = new Keypair();
  let nameAccountPk: PublicKey;

  async function create() {
    const HASHED_NAME = getHashedName(NAME);
    const seeds = [HASHED_NAME, Buffer.alloc(32), Buffer.alloc(32)];
    [nameAccountPk] = await PublicKey.findProgramAddress(
      seeds,
      program.programId
    );

    const nameAccountTotalSpace = HASHED_NAME.byteLength * 10;
    const nameAccountLamports =
      await provider.connection.getMinimumBalanceForRentExemption(
        nameAccountTotalSpace
      );

    await program.methods
      .create(
        HASHED_NAME,
        new BN(nameAccountLamports),
        nameAccountTotalSpace - program.account.nameRecordHeader.size
      )
      .accounts({
        systemProgram: SystemProgram.programId,
        payer: kp.publicKey,
        nameAccount: nameAccountPk,
        nameOwner: kp.publicKey,
      })
      .remainingAccounts([
        {
          pubkey: PublicKey.default,
          isSigner: false,
          isWritable: false,
        },
        {
          pubkey: PublicKey.default,
          isSigner: false,
          isWritable: false,
        },
      ])
      .rpc();
  }

  async function update() {
    const HASHED_UPDATE_NAME = getHashedName(UPDATE_NAME);
    await program.methods
      .update(0, HASHED_UPDATE_NAME)
      .accounts({
        nameAccount: nameAccountPk,
        nameUpdateSigner: kp.publicKey,
      })
      .rpc();
  }

  async function transfer() {
    await program.methods
      .transfer(newOwnerKp.publicKey)
      .accounts({
        nameAccount: nameAccountPk,
        nameOwner: kp.publicKey,
      })
      .rpc();
  }

  async function del() {
    const txHash = await program.methods
      .delete()
      .accounts({
        nameAccount: nameAccountPk,
        nameOwner: newOwnerKp.publicKey,
        refundTarget: kp.publicKey,
      })
      .signers([newOwnerKp])
      .rpc();

    await confirmTx(txHash);
  }

  async function fetchNameRecord() {
    try {
      await program.account.nameRecordHeader.fetch(nameAccountPk);
      throw new Error("Account should not exist.");
    } catch {}
  }

  await test(create);
  await test(update);
  await test(transfer);
  await test(del);
  await test(fetchNameRecord);
}


================================================
File: ts/tests/src/spl/record.ts
================================================
import assert from "assert";
import { splRecordProgram } from "@coral-xyz/spl-record";
import { Keypair, PublicKey } from "@solana/web3.js";
import { BN } from "@coral-xyz/anchor";

import { SPL_RECORD_PROGRAM_ID } from "../constants";
import {
  confirmTx,
  getProvider,
  loadKp,
  sendAndConfirmTx,
  test,
} from "../utils";

export async function recordTests() {
  const provider = await getProvider();
  const program = splRecordProgram({
    provider,
    programId: SPL_RECORD_PROGRAM_ID,
  });
  const kp = await loadKp();

  const RECORD_DATA = Buffer.alloc(8).fill(1);
  const newAuthorityKp = new Keypair();
  let recordPk: PublicKey;

  async function initialize() {
    const recordKp = new Keypair();
    recordPk = recordKp.publicKey;
    const createRecordAccountIx =
      await program.account.recordData.createInstruction(recordKp);
    const initIx = await program.methods
      .initialize()
      .accounts({
        recordAccount: recordKp.publicKey,
        authority: kp.publicKey,
      })
      .instruction();

    await sendAndConfirmTx([createRecordAccountIx, initIx], [kp, recordKp]);
  }

  async function write() {
    await program.methods
      .write(new BN(0), RECORD_DATA)
      .accounts({
        recordAccount: recordPk,
        signer: kp.publicKey,
      })
      .rpc();
  }

  async function setAuthority() {
    await program.methods
      .setAuthority()
      .accounts({
        recordAccount: recordPk,
        signer: kp.publicKey,
        newAuthority: newAuthorityKp.publicKey,
      })
      .rpc();

    try {
      await write();
      throw new Error("Authority did not update.");
    } catch {}
  }

  async function fetchRecordDataAccount() {
    const record = await program.account.recordData.fetch(recordPk);
    assert(record.authority.equals(newAuthorityKp.publicKey));
    assert(record.data.bytes.every((b, i) => b === RECORD_DATA[i]));
  }

  async function closeAccount() {
    const txHash = await program.methods
      .closeAccount()
      .accounts({
        recordAccount: recordPk,
        signer: newAuthorityKp.publicKey,
        receiver: kp.publicKey,
      })
      .signers([newAuthorityKp])
      .rpc();

    await confirmTx(txHash);

    try {
      await program.account.recordData.fetch(recordPk);
      throw new Error("Record account did not close.");
    } catch {}
  }

  await test(initialize);
  await test(write);
  await test(setAuthority);
  await test(fetchRecordDataAccount);
  await test(closeAccount);
}


================================================
File: ts/tests/src/spl/stateless-asks.ts
================================================
import { splStatelessAsksProgram } from "@coral-xyz/spl-stateless-asks";
import { splTokenProgram } from "@coral-xyz/spl-token";
import { BN } from "@coral-xyz/anchor";
import { Keypair, PublicKey } from "@solana/web3.js";

import {
  SPL_STATELESS_ASKS_PROGRAM_ID,
  SPL_TOKEN_PROGRAM_ID,
} from "../constants";
import {
  createAta,
  createMint,
  getProvider,
  loadKp,
  sendAndConfirmTx,
  test,
} from "../utils";

export async function statelessAsksTests() {
  const provider = await getProvider();
  const program = splStatelessAsksProgram({
    provider,
    programId: SPL_STATELESS_ASKS_PROGRAM_ID,
  });
  const tokenProgram = splTokenProgram({
    provider,
    programId: SPL_TOKEN_PROGRAM_ID,
  });
  const kp = await loadKp();

  async function acceptOffer() {
    const makerKp = new Keypair();
    const makerPk = makerKp.publicKey;
    const makerMintPk = await createMint();
    const takerMintPk = await createMint();
    const makerSrcTokenAccountPk = await createAta(makerMintPk, makerPk);
    const makerDstTokenAccountPk = await createAta(takerMintPk, makerPk);

    const takerSrcTokenAccountPk = await createAta(takerMintPk, kp.publicKey);
    const takerDstTokenAccountPk = await createAta(makerMintPk, kp.publicKey);

    const makerSize = new BN(500);
    const takerSize = new BN(400);

    const [authorityPk, bump] = await PublicKey.findProgramAddress(
      [
        Buffer.from("stateless_offer"),
        makerPk.toBuffer(),
        makerMintPk.toBuffer(),
        takerMintPk.toBuffer(),
        makerSize.toBuffer("le", 8),
        takerSize.toBuffer("le", 8),
      ],
      program.programId
    );

    const mintMakerSrcIx = await tokenProgram.methods
      .mintTo(makerSize)
      .accounts({
        account: makerSrcTokenAccountPk,
        mint: makerMintPk,
        owner: kp.publicKey,
      })
      .instruction();
    const makerSrcApproveIx = await tokenProgram.methods
      .approve(makerSize)
      .accounts({
        delegate: authorityPk,
        owner: makerPk,
        source: makerSrcTokenAccountPk,
      })
      .instruction();

    const mintTakerSrcIx = await tokenProgram.methods
      .mintTo(takerSize)
      .accounts({
        account: takerSrcTokenAccountPk,
        mint: takerMintPk,
        owner: kp.publicKey,
      })
      .instruction();

    const acceptOfferIx = await program.methods
      .acceptOffer(false, makerSize, takerSize, bump)
      .accounts({
        makerWallet: makerPk,
        takerWallet: kp.publicKey,
        makerSrcAccount: makerSrcTokenAccountPk,
        makerDstAccount: makerDstTokenAccountPk,
        takerSrcAccount: takerSrcTokenAccountPk,
        takerDstAccount: takerDstTokenAccountPk,
        makerMint: makerMintPk,
        takerMint: takerMintPk,
        authority: authorityPk,
        tokenProgram: tokenProgram.programId,
      })
      .instruction();

    await sendAndConfirmTx(
      [mintMakerSrcIx, makerSrcApproveIx, mintTakerSrcIx, acceptOfferIx],
      [kp, makerKp]
    );
  }

  await test(acceptOffer);
}


================================================
File: .github/issue_template.md
================================================
⚠️ Don't use issues for support questions ("How does x feature work in Anchor? How to do x in Anchor?"). Instead: 

 - Check [Solana Stack Exchange](https://solana.stackexchange.com/) - chances are someone has already had the same issue, and there's already an answer there. If not, write a new question! 
 - See [the Anchor Discord](https://discord.gg/NHHGSXAnXk) (but don't ping maintainers). ⚠


================================================
File: .github/actions/git-diff/action.yaml
================================================
name: "Git diff"
description: "Check git changes "
runs:
  using: "composite"
  steps:
      - run: git diff --exit-code
        shell: bash


================================================
File: .github/actions/setup/action.yaml
================================================
name: "Setup"
description: "Setup"
runs:
  using: "composite"
  steps:
    - run: sudo apt-get update && sudo apt-get install -y pkg-config build-essential libudev-dev
      shell: bash
    - run: echo "ANCHOR_VERSION=$(cat ./VERSION)" >> $GITHUB_ENV
      shell: bash
    - run: git submodule update --init --recursive --depth 1
      shell: bash


================================================
File: .github/actions/setup-solana/action.yaml
================================================
name: "Setup Solana"
description: "Setup Solana"
runs:
  using: "composite"
  steps:
    - uses: actions/cache@v3
      name: Cache Solana Tool Suite
      id: cache-solana
      with:
        path: |
          ~/.cache/solana/
          ~/.local/share/solana/
        key: solana-${{ runner.os }}-v0000-${{ env.SOLANA_CLI_VERSION }}-${{ env.SOLANG_VERSION }}
    - uses: nick-fields/retry@v2
      if: steps.cache-solana.outputs.cache-hit != 'true'
      with:
        retry_wait_seconds: 300
        timeout_minutes: 2
        max_attempts: 10
        retry_on: error
        shell: bash
        command: sh -c "$(curl -sSfL https://release.anza.xyz/v${{ env.SOLANA_CLI_VERSION }}/install)"
    - run: echo "/home/runner/.local/share/solana/install/active_release/bin" >> $GITHUB_PATH
      shell: bash
    - run: solana-keygen new --no-bip39-passphrase
      shell: bash
    - run: solana config set --url localhost
      shell: bash


================================================
File: .github/actions/setup-ts/action.yaml
================================================
name: "Setup ts"
description: "Setup ts"
runs:
  using: "composite"
  steps:
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
    - uses: actions/cache@v3
      name: Cache Typescript node_modules
      id: cache-typescript-node-modules
      with:
        path: |
          ./ts/node_modules/
        key: solana-${{ runner.os }}-v0000-${{ env.NODE_VERSION }}-${{ hashFiles('./ts/**/yarn.lock') }}
    - uses: actions/cache@v3
      name: Cache Typescript Dist
      id: cache-typescript-dist
      with:
        path: |
          ./ts/dist/
        key: solana-${{ runner.os }}-v0000-${{ env.NODE_VERSION }}-${{ hashFiles('./ts/**/*.ts') }}
    - run: cd ts/packages/borsh && yarn --frozen-lockfile && yarn build && yarn link && cd ../../../
      shell: bash
    - run: cd ts/packages/anchor-errors && yarn --frozen-lockfile && yarn build && yarn link && cd ../../../
      shell: bash
    - run: cd ts/packages/anchor && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
      shell: bash
    - run: cd ts/packages/spl-associated-token-account && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
      shell: bash
    - run: cd ts/packages/spl-token && yarn --frozen-lockfile && yarn build:node && yarn link && cd ../../../
      shell: bash
    - run: cd examples/tutorial && yarn link @coral-xyz/anchor @coral-xyz/borsh && yarn --frozen-lockfile && cd ../../
      shell: bash
    - run: cd tests && yarn link @coral-xyz/anchor @coral-xyz/borsh @coral-xyz/spl-associated-token-account @coral-xyz/spl-token && yarn --frozen-lockfile && cd ..
      shell: bash


================================================
File: .github/workflows/no-caching-tests.yaml
================================================
name: No Caching Tests

on:
  push:
    branches:
      - master

jobs:
  no-caching-tests:
    name: Reusable
    uses: ./.github/workflows/reusable-tests.yaml
    with:
      cache: false
      solana_cli_version: 2.1.0
      node_version: 20.16.0
      cargo_profile: release
      anchor_binary_name: anchor-binary-no-caching


================================================
File: .github/workflows/release.yaml
================================================
name: Release

on:
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"

  pull_request:
    branches:
      - master
    paths:
      - VERSION
      - ./github/workflows/release.yaml

env:
  DIST: dist-${{ github.ref_name }}

jobs:
  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        target:
          - aarch64-apple-darwin
          - x86_64-unknown-linux-gnu
          - x86_64-apple-darwin
          - x86_64-pc-windows-msvc
        include:
          - target: aarch64-apple-darwin
            os: macos-latest

          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest

          - target: x86_64-apple-darwin
            os: macos-latest

          - target: x86_64-pc-windows-msvc
            os: windows-latest

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable
          target: ${{ matrix.target }}

      - name: Build release binary
        run: cargo build --package anchor-cli --release --locked --target ${{ matrix.target }}

      - name: Prepare
        if: startsWith(github.ref, 'refs/tags/')
        id: prepare
        shell: bash
        run: |
          version=$(echo $GITHUB_REF_NAME | cut -dv -f2)
          ext=""
          [[ "${{ matrix.os }}" == windows-latest ]] && ext=".exe"

          mkdir $DIST
          mv "target/${{ matrix.target }}/release/anchor$ext" $DIST/anchor-$version-${{ matrix.target }}$ext

          echo "version=$version" >> $GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        if: startsWith(github.ref, 'refs/tags/')
        with:
          name: anchor-${{ steps.prepare.outputs.version }}-${{ matrix.target }}
          path: ${{ env.DIST }}
          overwrite: true
          retention-days: 1

  upload:
    name: Upload binaries to release
    if: startsWith(github.ref, 'refs/tags/')
    needs: [build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          path: ${{ env.DIST }}

      - name: Upload
        shell: bash
        run: GH_TOKEN=${{ secrets.GITHUB_TOKEN }} gh release upload $GITHUB_REF_NAME $DIST/*/* --clobber


================================================
File: .github/workflows/tests.yaml
================================================
name: Tests

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  tests:
    name: Reusable
    uses: ./.github/workflows/reusable-tests.yaml
    with:
      cache: true
      solana_cli_version: 2.1.0
      node_version: 20.16.0
      cargo_profile: debug
      anchor_binary_name: anchor-binary


